From a95a9fcbb51c80eeeaf9ec532a1a9f1be029bafe Mon Sep 17 00:00:00 2001
From: septs <github@septs.pw>
Date: Sat, 12 Aug 2023 05:52:49 +0800
Subject: [PATCH] add hatlab gateboard-one

---
 HATLab-GateBoard-One.config                   | 288 +++++
 HATLab-GateBoard-One.feeds                    |   4 +
 helper/build.sh                               |  17 +
 helper/flash-sd.sh                            |  10 +
 package/kernel/8563-watchdog/Makefile         |  29 +
 .../kernel/8563-watchdog/files/8563-watchdog  |  17 +
 .../8563-watchdog/files/8563-watchdog.init    |  18 +
 package/kernel/linux/modules/netdevices.mk    |   2 +-
 ...-Add-dt-config-load-eeprom-from-file.patch |  48 +
 .../mtk-eip93/999-add-esp-hw-offload.patch    |  10 +
 .../IPSec-ESP-HW-Offload-Performance.txt      |  68 ++
 package/kernel/mtk-eip93/LICENSE              | 339 ++++++
 package/kernel/mtk-eip93/Makefile             | 155 +++
 package/kernel/mtk-eip93/README.md            |  47 +
 .../kernel/mtk-eip93/mediatek,mtk-eip93.yaml  |  41 +
 package/kernel/mtk-eip93/src/Makefile         |  11 +
 package/kernel/mtk-eip93/src/eip93-aead.c     | 778 ++++++++++++++
 package/kernel/mtk-eip93/src/eip93-aead.h     |  31 +
 package/kernel/mtk-eip93/src/eip93-aes.h      |  15 +
 package/kernel/mtk-eip93/src/eip93-cipher.c   | 440 ++++++++
 package/kernel/mtk-eip93/src/eip93-cipher.h   |  63 ++
 package/kernel/mtk-eip93/src/eip93-common.c   | 750 ++++++++++++++
 package/kernel/mtk-eip93/src/eip93-common.h   |  34 +
 package/kernel/mtk-eip93/src/eip93-des.h      |  15 +
 package/kernel/mtk-eip93/src/eip93-hash.c     | 659 ++++++++++++
 package/kernel/mtk-eip93/src/eip93-hash.h     |  68 ++
 package/kernel/mtk-eip93/src/eip93-ipsec.c    | 980 ++++++++++++++++++
 package/kernel/mtk-eip93/src/eip93-ipsec.h    |  45 +
 package/kernel/mtk-eip93/src/eip93-main.c     | 692 +++++++++++++
 package/kernel/mtk-eip93/src/eip93-main.h     | 173 ++++
 package/kernel/mtk-eip93/src/eip93-prng.c     | 358 +++++++
 package/kernel/mtk-eip93/src/eip93-prng.h     |  34 +
 package/kernel/mtk-eip93/src/eip93-regs.h     | 383 +++++++
 package/rdloader/Makefile                     |  54 +
 package/rdloader/src/CMakeLists.txt           |   9 +
 package/rdloader/src/LICENSE                  | 674 ++++++++++++
 package/rdloader/src/blkid2.c                 |  40 +
 package/rdloader/src/blkid2.h                 |  10 +
 package/rdloader/src/cmdline.c                | 204 ++++
 package/rdloader/src/cmdline.h                |  24 +
 package/rdloader/src/insmod.c                 | 161 +++
 package/rdloader/src/insmod.h                 |  10 +
 package/rdloader/src/main.c                   | 261 +++++
 package/rdloader/src/mkdev_node.c             | 272 +++++
 package/rdloader/src/mkdev_node.h             |  10 +
 package/rdloader/src/mknod.c                  | 217 ++++
 package/rdloader/src/mknod.h                  |  11 +
 package/rdloader/src/switch_root.c            | 108 ++
 package/rdloader/src/switch_root.h            |  12 +
 scripts/gen-rddependencies.sh                 |  12 +
 scripts/mkits.sh                              | 136 ++-
 .../dts/mt7621_hatlab_gateboard-one.dts       | 384 +++++++
 .../files/drivers/mmc/host/mtk-mmc/sd.c       |   8 +-
 target/linux/ramips/image/Makefile            |   2 +-
 target/linux/ramips/image/mt7621.mk           |  88 ++
 .../mt7621/base-files/etc/board.d/02_network  |   3 +
 .../mt7621/base-files/lib/upgrade/hatlab.sh   |  88 ++
 .../mt7621/base-files/lib/upgrade/platform.sh |  25 +
 .../mt7621/base-files/sbin/fixup-mac-address  |   4 +
 target/linux/ramips/mt7621/config-5.4         |   9 +
 .../9900-spi-nor-add-p25d40h.patch            |  12 +
 .../9901-gpio-mt7621-irq-workaround.patch     |  11 +
 .../ramips/patches-5.4/9902-rtl8211fs.patch   | 149 +++
 .../9909-mt7621-add-l2c-er35-workaround.patch | 142 +++
 .../patches-5.4/999-add-esp-hw-offload.patch  |  11 +
 .../9999-mt7621-disable-highmem.patch         |  13 +
 66 files changed, 9783 insertions(+), 13 deletions(-)
 create mode 100644 HATLab-GateBoard-One.config
 create mode 100644 HATLab-GateBoard-One.feeds
 create mode 100755 helper/build.sh
 create mode 100755 helper/flash-sd.sh
 create mode 100644 package/kernel/8563-watchdog/Makefile
 create mode 100644 package/kernel/8563-watchdog/files/8563-watchdog
 create mode 100644 package/kernel/8563-watchdog/files/8563-watchdog.init
 create mode 100644 package/kernel/mt76/patches/999-Add-dt-config-load-eeprom-from-file.patch
 create mode 100644 package/kernel/mtk-eip93/999-add-esp-hw-offload.patch
 create mode 100644 package/kernel/mtk-eip93/IPSec-ESP-HW-Offload-Performance.txt
 create mode 100644 package/kernel/mtk-eip93/LICENSE
 create mode 100644 package/kernel/mtk-eip93/Makefile
 create mode 100644 package/kernel/mtk-eip93/README.md
 create mode 100644 package/kernel/mtk-eip93/mediatek,mtk-eip93.yaml
 create mode 100644 package/kernel/mtk-eip93/src/Makefile
 create mode 100644 package/kernel/mtk-eip93/src/eip93-aead.c
 create mode 100644 package/kernel/mtk-eip93/src/eip93-aead.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-aes.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-cipher.c
 create mode 100644 package/kernel/mtk-eip93/src/eip93-cipher.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-common.c
 create mode 100644 package/kernel/mtk-eip93/src/eip93-common.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-des.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-hash.c
 create mode 100644 package/kernel/mtk-eip93/src/eip93-hash.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-ipsec.c
 create mode 100644 package/kernel/mtk-eip93/src/eip93-ipsec.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-main.c
 create mode 100644 package/kernel/mtk-eip93/src/eip93-main.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-prng.c
 create mode 100644 package/kernel/mtk-eip93/src/eip93-prng.h
 create mode 100644 package/kernel/mtk-eip93/src/eip93-regs.h
 create mode 100644 package/rdloader/Makefile
 create mode 100644 package/rdloader/src/CMakeLists.txt
 create mode 100644 package/rdloader/src/LICENSE
 create mode 100644 package/rdloader/src/blkid2.c
 create mode 100644 package/rdloader/src/blkid2.h
 create mode 100644 package/rdloader/src/cmdline.c
 create mode 100644 package/rdloader/src/cmdline.h
 create mode 100644 package/rdloader/src/insmod.c
 create mode 100644 package/rdloader/src/insmod.h
 create mode 100644 package/rdloader/src/main.c
 create mode 100644 package/rdloader/src/mkdev_node.c
 create mode 100644 package/rdloader/src/mkdev_node.h
 create mode 100644 package/rdloader/src/mknod.c
 create mode 100644 package/rdloader/src/mknod.h
 create mode 100644 package/rdloader/src/switch_root.c
 create mode 100644 package/rdloader/src/switch_root.h
 create mode 100755 scripts/gen-rddependencies.sh
 create mode 100644 target/linux/ramips/dts/mt7621_hatlab_gateboard-one.dts
 create mode 100644 target/linux/ramips/mt7621/base-files/lib/upgrade/hatlab.sh
 create mode 100644 target/linux/ramips/patches-5.4/9900-spi-nor-add-p25d40h.patch
 create mode 100644 target/linux/ramips/patches-5.4/9901-gpio-mt7621-irq-workaround.patch
 create mode 100644 target/linux/ramips/patches-5.4/9902-rtl8211fs.patch
 create mode 100644 target/linux/ramips/patches-5.4/9909-mt7621-add-l2c-er35-workaround.patch
 create mode 100644 target/linux/ramips/patches-5.4/999-add-esp-hw-offload.patch
 create mode 100644 target/linux/ramips/patches-5.4/9999-mt7621-disable-highmem.patch

diff --git a/HATLab-GateBoard-One.config b/HATLab-GateBoard-One.config
new file mode 100644
index 0000000..e19e297
--- /dev/null
+++ b/HATLab-GateBoard-One.config
@@ -0,0 +1,288 @@
+CONFIG_ALL_KMODS=y
+CONFIG_ALL_NONSHARED=y
+CONFIG_DEVEL=y
+CONFIG_COLLECT_KERNEL_DEBUG=y
+
+CONFIG_IMAGEOPT=y
+CONFIG_JSON_OVERVIEW_IMAGE_INFO=y
+CONFIG_KERNEL_BUILD_DOMAIN="buildhost"
+CONFIG_KERNEL_BUILD_USER="builder"
+# CONFIG_KERNEL_KALLSYMS is not set
+CONFIG_PACKAGE_cgi-io=y
+CONFIG_PACKAGE_libiwinfo-lua=y
+CONFIG_PACKAGE_liblua=y
+CONFIG_PACKAGE_liblucihttp=y
+CONFIG_PACKAGE_liblucihttp-lua=y
+CONFIG_PACKAGE_libubus-lua=y
+CONFIG_PACKAGE_lua=y
+CONFIG_PACKAGE_luci=y
+CONFIG_PACKAGE_luci-app-firewall=y
+CONFIG_PACKAGE_luci-app-opkg=y
+CONFIG_PACKAGE_luci-base=y
+CONFIG_PACKAGE_luci-lib-base=y
+CONFIG_PACKAGE_luci-lib-ip=y
+CONFIG_PACKAGE_luci-lib-jsonc=y
+CONFIG_PACKAGE_luci-lib-nixio=y
+CONFIG_PACKAGE_luci-mod-admin-full=y
+CONFIG_PACKAGE_luci-mod-network=y
+CONFIG_PACKAGE_luci-mod-status=y
+CONFIG_PACKAGE_luci-mod-system=y
+CONFIG_PACKAGE_luci-proto-ipv6=y
+CONFIG_PACKAGE_luci-proto-ppp=y
+CONFIG_PACKAGE_luci-ssl=y
+CONFIG_PACKAGE_luci-theme-bootstrap=y
+CONFIG_PACKAGE_px5g-wolfssl=y
+CONFIG_PACKAGE_rpcd=y
+CONFIG_PACKAGE_rpcd-mod-file=y
+CONFIG_PACKAGE_rpcd-mod-iwinfo=y
+CONFIG_PACKAGE_rpcd-mod-luci=y
+CONFIG_PACKAGE_rpcd-mod-rrdns=y
+CONFIG_PACKAGE_uhttpd=y
+CONFIG_PACKAGE_uhttpd-mod-ubus=y
+CONFIG_REPRODUCIBLE_DEBUG_INFO=y
+
+# CONFIG_AUTOREBUILD is not set
+
+CONFIG_VERSIONOPT=y
+CONFIG_VERSION_BUG_URL=""
+CONFIG_VERSION_CODE_FILENAMES=y
+CONFIG_VERSION_DIST="OpenWrt"
+CONFIG_VERSION_FILENAMES=y
+CONFIG_VERSION_HOME_URL=""
+CONFIG_VERSION_HWREV=""
+CONFIG_VERSION_MANUFACTURER=""
+CONFIG_VERSION_MANUFACTURER_URL=""
+CONFIG_VERSION_PRODUCT=""
+CONFIG_VERSION_SUPPORT_URL=""
+
+CONFIG_VERSION_NUMBER="21.02.5"
+CONFIG_VERSION_CODE="r16554-1d4dea6d4f"
+CONFIG_VERSION_REPO="https://downloads.openwrt.org/releases/21.02.5"
+
+# ---HATLab-GateBoard-One---
+
+# ---Target Config---
+CONFIG_TARGET_ramips=y
+CONFIG_TARGET_ramips_mt7621=y
+CONFIG_TARGET_ramips_mt7621_DEVICE_hatlab_gateboard-one=y
+# ---END Target Config---
+
+# ---Image Config---
+# CONFIG_TARGET_ROOTFS_INITRAMFS is not set
+CONFIG_TARGET_ROOTFS_SQUASHFS=y
+CONFIG_TARGET_ROOTFS_EXT4FS=y
+CONFIG_TARGET_EXT4_JOURNAL=y
+CONFIG_TARGET_ROOTFS_PARTSIZE=104
+# ---END Image Config---
+
+# ---Kernel Config---
+CONFIG_KERNEL_DEVMEM=y
+# ---END Kernel Config---
+
+# ---Busybox Custom---
+CONFIG_BUSYBOX_CUSTOM=y
+CONFIG_BUSYBOX_CONFIG_DEVMEM=y
+CONFIG_BUSYBOX_CONFIG_TELNET=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_TELNET_TTYPE=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_TELNET_AUTOLOGIN=y
+CONFIG_BUSYBOX_CONFIG_FEATURE_TELNET_WIDTH=y
+# ---END Busybox Custom---
+
+# ---Additional Filesystem---
+CONFIG_PACKAGE_kmod-loop=y
+CONFIG_PACKAGE_kmod-fs-vfat=y
+CONFIG_PACKAGE_kmod-fs-exfat=y
+# ---END Additional Filesystem---
+
+# ---Filesystem tools---
+CONFIG_PACKAGE_sgdisk=y
+CONFIG_PACKAGE_losetup=y
+CONFIG_PACKAGE_resize2fs=y
+CONFIG_PACKAGE_partx-utils=y
+CONFIG_PACKAGE_block-mount=y
+# ---END Filesystem tools---
+
+# ---Crypto Engine---
+CONFIG_PACKAGE_libopenssl=y
+CONFIG_PACKAGE_libopenssl-devcrypto=y
+CONFIG_PACKAGE_openssl-util=y
+CONFIG_PACKAGE_kmod-cryptodev=y
+CONFIG_PACKAGE_kmod-crypto-hw-eip93=y
+CONFIG_CRYPTO_DEV_EIP93_AES=y
+CONFIG_CRYPTO_DEV_EIP93_DES=y
+CONFIG_CRYPTO_DEV_EIP93_AEAD=y
+CONFIG_CRYPTO_DEV_EIP93_IPSEC=y
+# CONFIG_CRYPTO_DEV_EIP93_HASH is not set
+# CONFIG_CRYPTO_DEV_EIP93_PRNG is not set
+CONFIG_PACKAGE_kmod-ipsec=y
+CONFIG_PACKAGE_kmod-ipsec4=y
+# ---END Crypto Engine---
+
+# ---EBTABLES---
+CONFIG_PACKAGE_kmod-ebtables=y
+CONFIG_PACKAGE_ebtables=y
+# ---END EBTABLES---
+
+# ---Netowrk Related---
+CONFIG_PACKAGE_kmod-bonding=y
+CONFIG_PACKAGE_kmod-l2tp-eth=y
+CONFIG_PACKAGE_iptables-mod-tproxy=y
+# CONFIG_PACKAGE_ip-tiny is not set
+CONFIG_PACKAGE_ip-full=y
+# CONFIG_PACKAGE_dnsmasq is not set
+CONFIG_PACKAGE_dnsmasq-full=y
+CONFIG_PACKAGE_libnl=y
+CONFIG_PACKAGE_ipset=y
+CONFIG_PACKAGE_resolveip=y
+CONFIG_PACKAGE_ethtool=y
+CONFIG_PACKAGE_netcat=y
+CONFIG_PACKAGE_socat=y
+CONFIG_PACKAGE_tcpdump=y
+CONFIG_PACKAGE_rpcapd=y
+CONFIG_PACKAGE_curl=y
+CONFIG_LIBCURL_OPENSSL=y
+CONFIG_PACKAGE_proto-bonding=y
+# ---END Netowrk Related---
+
+# ---Additional Wireless Driver---
+CONFIG_PACKAGE_kmod-mt76=y
+CONFIG_PACKAGE_kmod-mt7615e=y
+CONFIG_PACKAGE_kmod-mt7615-common=y
+CONFIG_PACKAGE_kmod-mt7615-firmware=y
+CONFIG_PACKAGE_kmod-mt7915e=y
+CONFIG_PACKAGE_kmod-ath9k=y
+CONFIG_PACKAGE_kmod-ath10k=y
+CONFIG_PACKAGE_ath10k-firmware-qca99x0=y
+CONFIG_PACKAGE_ath10k-firmware-qca9984=y
+CONFIG_PACKAGE_ath10k-firmware-qca9888=y
+CONFIG_PACKAGE_ath10k-firmware-qca9887=y
+CONFIG_PACKAGE_ath10k-firmware-qca9377=y
+CONFIG_PACKAGE_ath10k-firmware-qca6174=y
+CONFIG_PACKAGE_ath10k-board-qca99x0=y
+CONFIG_PACKAGE_ath10k-board-qca9984=y
+CONFIG_PACKAGE_ath10k-board-qca988x=y
+CONFIG_PACKAGE_ath10k-board-qca9888=y
+CONFIG_PACKAGE_ath10k-board-qca9887=y
+CONFIG_PACKAGE_ath10k-board-qca9377=y
+# --- Modems ---
+CONFIG_PACKAGE_kmod-usb-serial-option=y
+CONFIG_PACKAGE_kmod-usb-net-rndis=y
+CONFIG_PACKAGE_kmod-usb-net-qmi-wwan=y
+CONFIG_PACKAGE_kmod-usb-net-cdc-mbim=y
+CONFIG_PACKAGE_umbim=y
+CONFIG_PACKAGE_uqmi=y
+CONFIG_PACKAGE_usb-modeswitch=y
+CONFIG_PACKAGE_luci-proto-qmi=y
+CONFIG_PACKAGE_luci-proto-3g=y
+# ---END Wireless Driver---
+
+# # ---IPSec Related---
+# CONFIG_PACKAGE_kmod-crypto-user=y
+# CONFIG_PACKAGE_kmod-crypto-acompress=y
+# CONFIG_PACKAGE_kmod-crypto-aead=y
+# CONFIG_PACKAGE_kmod-crypto-arc4=y
+# CONFIG_PACKAGE_kmod-crypto-authenc=y
+# CONFIG_PACKAGE_kmod-crypto-cbc=y
+# CONFIG_PACKAGE_kmod-crypto-ccm=y
+# CONFIG_PACKAGE_kmod-crypto-cmac=y
+# CONFIG_PACKAGE_kmod-crypto-crc32=y
+# CONFIG_PACKAGE_kmod-crypto-crc32c=y
+# CONFIG_PACKAGE_kmod-crypto-ctr=y
+# CONFIG_PACKAGE_kmod-crypto-cts=y
+# CONFIG_PACKAGE_kmod-crypto-deflate=y
+# CONFIG_PACKAGE_kmod-crypto-des=y
+# CONFIG_PACKAGE_kmod-crypto-ecb=y
+# CONFIG_PACKAGE_kmod-crypto-ecdh=y
+# CONFIG_PACKAGE_kmod-crypto-echainiv=y
+# CONFIG_PACKAGE_kmod-crypto-fcrypt=y
+# CONFIG_PACKAGE_kmod-crypto-gcm=y
+# CONFIG_PACKAGE_kmod-crypto-gf128=y
+# CONFIG_PACKAGE_kmod-crypto-ghash=y
+# CONFIG_PACKAGE_kmod-crypto-hash=y
+# CONFIG_PACKAGE_kmod-crypto-hmac=y
+# CONFIG_PACKAGE_kmod-crypto-kpp=y
+# CONFIG_PACKAGE_kmod-crypto-lib-blake2s=y
+# CONFIG_PACKAGE_kmod-crypto-lib-chacha20=y
+# CONFIG_PACKAGE_kmod-crypto-lib-chacha20poly1305=y
+# CONFIG_PACKAGE_kmod-crypto-lib-curve25519=y
+# CONFIG_PACKAGE_kmod-crypto-lib-poly1305=y
+# CONFIG_PACKAGE_kmod-crypto-md4=y
+# CONFIG_PACKAGE_kmod-crypto-md5=y
+# CONFIG_PACKAGE_kmod-crypto-michael-mic=y
+# CONFIG_PACKAGE_kmod-crypto-misc=y
+# CONFIG_PACKAGE_kmod-crypto-null=y
+# CONFIG_PACKAGE_kmod-crypto-pcbc=y
+# CONFIG_PACKAGE_kmod-crypto-pcompress=y
+# CONFIG_PACKAGE_kmod-crypto-rmd160=y
+# CONFIG_PACKAGE_kmod-crypto-rng=y
+# CONFIG_PACKAGE_kmod-crypto-seqiv=y
+# CONFIG_PACKAGE_kmod-crypto-sha1=y
+# CONFIG_PACKAGE_kmod-crypto-sha256=y
+# CONFIG_PACKAGE_kmod-crypto-sha512=y
+# CONFIG_PACKAGE_kmod-crypto-test=y
+# CONFIG_PACKAGE_kmod-crypto-user=y
+# CONFIG_PACKAGE_kmod-crypto-wq=y
+# CONFIG_PACKAGE_kmod-crypto-xcbc=y
+# CONFIG_PACKAGE_kmod-crypto-xts=y
+# 
+# CONFIG_PACKAGE_strongswan=y
+# CONFIG_PACKAGE_strongswan-full=y
+# 
+# # ---END IPSec Related---
+
+# ---Build luci---
+CONFIG_PACKAGE_luci-compat=y
+CONFIG_PACKAGE_luci-proto-relay=y
+CONFIG_PACKAGE_luci-proto-bonding=y
+CONFIG_LUCI_LANG_en=y
+CONFIG_LUCI_LANG_zh_Hans=y
+# ---END Build luci---
+
+# ---Build full wpad---
+# CONFIG_PACKAGE_wpad-basic-wolfssl is not set
+CONFIG_PACKAGE_wpad-openssl=y
+# ---END Build full wpad---
+
+# ---DNS Server---
+CONFIG_PACKAGE_smartdns=y
+CONFIG_PACKAGE_luci-app-smartdns=y
+# ---END DNS Server---
+
+# ---USB Server---
+CONFIG_PACKAGE_kmod-usbip=y
+CONFIG_PACKAGE_usbip=y
+
+CONFIG_PACKAGE_kmod-usbip-server=y
+CONFIG_PACKAGE_usbip-server=y
+
+CONFIG_PACKAGE_kmod-usbip-client=y
+CONFIG_PACKAGE_usbip-client=y
+# ---END USB Server---
+
+# ---System Utils---
+CONFIG_PACKAGE_usbutils=y
+CONFIG_PACKAGE_pciutils=y
+CONFIG_PACKAGE_lsblk=y
+CONFIG_PACKAGE_lm-sensors=y
+CONFIG_PACKAGE_htop=y
+CONFIG_HTOP_LMSENSORS=y
+CONFIG_PACKAGE_sudo=y
+# ---END System Utils---
+
+# ---Serial Tools---
+CONFIG_PACKAGE_coreutils-stty=y
+CONFIG_PACKAGE_minicom=y
+CONFIG_PACKAGE_screen=y
+# ---END Serial Tools---
+
+# ---Debug Tools---
+CONFIG_PACKAGE_dtc=y
+CONFIG_PACKAGE_strace=y
+CONFIG_PACKAGE_gdb=y
+CONFIG_PACKAGE_gdbserver=y
+CONFIG_PACKAGE_i2c-tools=y
+# ---END Debug Tools---
+
+# ---Additional packages---
+CONFIG_PACKAGE_iperf3=y
+# ---END Additional packages---
diff --git a/HATLab-GateBoard-One.feeds b/HATLab-GateBoard-One.feeds
new file mode 100644
index 0000000..62821a0
--- /dev/null
+++ b/HATLab-GateBoard-One.feeds
@@ -0,0 +1,4 @@
+src-git-full packages https://git.openwrt.org/feed/packages.git^0b16e3f359fe9d015861596d63c5bde4c56daa2e
+src-git-full luci https://git.openwrt.org/project/luci.git^afd001293996ee6557ea14b438d95b41bd75f132
+src-git-full routing https://git.openwrt.org/feed/routing.git^25e76489c83cfcee61e36a491896e1e9bfc3ec13
+src-git-full telephony https://git.openwrt.org/feed/telephony.git^89cc8fccf757614eac1d45a684f4971393e0d984
\ No newline at end of file
diff --git a/helper/build.sh b/helper/build.sh
new file mode 100755
index 0000000..8e0ce6e
--- /dev/null
+++ b/helper/build.sh
@@ -0,0 +1,17 @@
+#!/bin/sh
+JOBS="$(grep -c ^processor /proc/cpuinfo)"
+cat ./HATLab-GateBoard-One.feeds > ./feeds.conf.default
+./scripts/feeds update -a
+
+rm -rf ./feeds/packages/net/smartdns/
+git clone https://github.com/pymumu/openwrt-smartdns ./feeds/packages/net/smartdns/
+rm -rf ./feeds/luci/applications/luci-app-smartdns/
+git clone https://github.com/pymumu/luci-app-smartdns ./feeds/luci/applications/luci-app-smartdns/
+
+./scripts/feeds install -a
+rm -f ./.config*
+touch ./.config
+cat ./HATLab-GateBoard-One.config > ./.config
+make defconfig
+make download -j "${JOBS}"
+make -j "${JOBS}"
diff --git a/helper/flash-sd.sh b/helper/flash-sd.sh
new file mode 100755
index 0000000..8292801
--- /dev/null
+++ b/helper/flash-sd.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+DRV="/dev/sdb"
+TYPE="ext4"
+umount "${DRV}1"
+umount "${DRV}2"
+umount "${DRV}3"
+umount "${DRV}4"
+gzip -dkc bin/targets/ramips/mt7621/*-ramips-mt7621-hatlab_gateboard-one-${TYPE}-combined.img.gz | dd of="${DRV}" bs=4k
+sync
+gparted
diff --git a/package/kernel/8563-watchdog/Makefile b/package/kernel/8563-watchdog/Makefile
new file mode 100644
index 0000000..81956a1
--- /dev/null
+++ b/package/kernel/8563-watchdog/Makefile
@@ -0,0 +1,29 @@
+include $(TOPDIR)/rules.mk
+
+PKG_NAME:=8563-watchdog
+PKG_RELEASE:=1
+
+include $(INCLUDE_DIR)/package.mk
+
+define Package/8563-watchdog
+  SECTION:=base
+  CATEGORY:=Base system
+  TITLE:=8563 watchdog
+  URL:=
+endef
+
+define Package/8563-watchdog/description
+ This package contains the hw watchdog script for PCF8563 timer interrupt.
+endef
+
+define Build/Compile
+endef
+
+define Package/8563-watchdog/install
+	$(INSTALL_DIR) $(1)/etc/init.d/
+	$(INSTALL_DIR) $(1)/sbin/
+	$(INSTALL_BIN) ./files/8563-watchdog.init $(1)/etc/init.d/8563-watchdog
+	$(INSTALL_BIN) ./files/8563-watchdog $(1)/sbin/8563-watchdog
+endef
+
+$(eval $(call BuildPackage,8563-watchdog))
diff --git a/package/kernel/8563-watchdog/files/8563-watchdog b/package/kernel/8563-watchdog/files/8563-watchdog
new file mode 100644
index 0000000..193dde2
--- /dev/null
+++ b/package/kernel/8563-watchdog/files/8563-watchdog
@@ -0,0 +1,17 @@
+#!/bin/sh
+
+BUS="0"
+ADDR="0x51"
+TIMEOUT="0x78" # 120 seconds
+let TICK="5"
+
+trap "" INT HUP
+
+i2cset -y -f ${BUS} ${ADDR} 0x0F ${TIMEOUT}	# reset Timer
+i2cset -y -f ${BUS} ${ADDR} 0x0E 0x82 # enable Timer countdown
+i2cset -y -f ${BUS} ${ADDR} 0x01 0x11 # enable Timer interrupt
+
+while true; do
+	i2cset -y -f ${BUS} ${ADDR} 0x0F ${TIMEOUT} # reset Timer
+	sleep ${TICK}
+done
diff --git a/package/kernel/8563-watchdog/files/8563-watchdog.init b/package/kernel/8563-watchdog/files/8563-watchdog.init
new file mode 100644
index 0000000..a2edc7a
--- /dev/null
+++ b/package/kernel/8563-watchdog/files/8563-watchdog.init
@@ -0,0 +1,18 @@
+#!/bin/sh /etc/rc.common
+#
+# Copyright (C) 2011 OpenWrt.org
+#
+
+START=11
+STOP=11
+
+USE_PROCD=1
+NAME=8563-watchdog
+PROG=/sbin/8563-watchdog
+
+start_service() {
+	procd_open_instance
+	procd_set_param command "${PROG}" "${gpio}"
+	procd_set_param respawn
+	procd_close_instance
+}
diff --git a/package/kernel/linux/modules/netdevices.mk b/package/kernel/linux/modules/netdevices.mk
index 901bddd..0f95685 100644
--- a/package/kernel/linux/modules/netdevices.mk
+++ b/package/kernel/linux/modules/netdevices.mk
@@ -668,7 +668,7 @@ $(eval $(call KernelPackage,igbvf))
 define KernelPackage/ixgbe
   SUBMENU:=$(NETWORK_DEVICES_MENU)
   TITLE:=Intel(R) 82598/82599 PCI-Express 10 Gigabit Ethernet support
-  DEPENDS:=@PCI_SUPPORT +kmod-mdio +kmod-ptp +kmod-hwmon-core +kmod-libphy
+  DEPENDS:=@PCI_SUPPORT +kmod-mdio +kmod-ptp +kmod-hwmon-core +kmod-libphy +kmod-ipsec
   KCONFIG:=CONFIG_IXGBE \
     CONFIG_IXGBE_VXLAN=n \
     CONFIG_IXGBE_HWMON=y \
diff --git a/package/kernel/mt76/patches/999-Add-dt-config-load-eeprom-from-file.patch b/package/kernel/mt76/patches/999-Add-dt-config-load-eeprom-from-file.patch
new file mode 100644
index 0000000..b46a8d1
--- /dev/null
+++ b/package/kernel/mt76/patches/999-Add-dt-config-load-eeprom-from-file.patch
@@ -0,0 +1,48 @@
+Copyright (C) 2022 Aodzip <aodzip@gmail.com>
+--- a/eeprom.c	2022-05-26 14:53:21.103004472 +0800
++++ b/eeprom.c	2022-05-26 14:53:13.250974442 +0800
+@@ -7,6 +7,7 @@
+ #include <linux/mtd/mtd.h>
+ #include <linux/mtd/partitions.h>
+ #include <linux/etherdevice.h>
++#include <linux/firmware.h>
+ #include "mt76.h"
+ 
+ int mt76_get_of_eeprom(struct mt76_dev *dev, void *eep, int offset, int len)
+@@ -15,6 +16,8 @@
+ 	struct device_node *np = dev->dev->of_node;
+ 	struct mtd_info *mtd;
+ 	const __be32 *list;
++	const char *eepfilename;
++	const struct firmware *eepfile;
+ 	const void *data;
+ 	const char *part;
+ 	phandle phandle;
+@@ -25,6 +28,27 @@
+ 	if (!np)
+ 		return -ENOENT;
+ 
++	eepfile = NULL;
++	ret = of_property_read_string(np, "mediatek,eeprom-file", &eepfilename);
++	if (ret == 0) {
++		ret = request_firmware(&eepfile, eepfilename, dev->dev);
++		if (ret) {
++			dev_err(dev->dev, "Failed to load eeprom file %s\n", eepfilename);
++			goto out_eepfile;
++		}
++		if (eepfile->size > len) {
++			dev_err(dev->dev, "eeprom file %s is too large\n", eepfilename);
++			ret = -1;
++			goto out_eepfile;
++		}
++		memcpy(eep, eepfile->data, eepfile->size);
++	}
++out_eepfile:
++	if(eepfile)
++		release_firmware(eepfile);
++	if(ret == 0)
++		return 0;
++
+ 	data = of_get_property(np, "mediatek,eeprom-data", &size);
+ 	if (data) {
+ 		if (size > len)
diff --git a/package/kernel/mtk-eip93/999-add-esp-hw-offload.patch b/package/kernel/mtk-eip93/999-add-esp-hw-offload.patch
new file mode 100644
index 0000000..5ac6310
--- /dev/null
+++ b/package/kernel/mtk-eip93/999-add-esp-hw-offload.patch
@@ -0,0 +1,10 @@
+--- a/net/ipv4/Kconfig
++++ b/net/ipv4/Kconfig
+@@ -356,6 +356,7 @@ config INET_AH
+ config INET_ESP
+ 	tristate "IP: ESP transformation"
+ 	select XFRM_ESP
++	select XFRM_OFFLOAD
+ 	help
+ 	  Support for IPsec ESP (Encapsulating Security Payload).
+ 
diff --git a/package/kernel/mtk-eip93/IPSec-ESP-HW-Offload-Performance.txt b/package/kernel/mtk-eip93/IPSec-ESP-HW-Offload-Performance.txt
new file mode 100644
index 0000000..3393028
--- /dev/null
+++ b/package/kernel/mtk-eip93/IPSec-ESP-HW-Offload-Performance.txt
@@ -0,0 +1,68 @@
+PC <------> WAN router LAN <---> mac mini (iperf3 server)
+    IPSec
+
+iperf3 -c server-ip --bidir -P2 
+
+
+[ ID][Role] Interval           Transfer     Bitrate         Retr
+[  5][TX-C]   0.00-10.00  sec   133 MBytes   112 Mbits/sec   60             sender
+[  5][TX-C]   0.00-10.02  sec   133 MBytes   111 Mbits/sec                  receiver
+[  7][TX-C]   0.00-10.00  sec   118 MBytes  99.2 Mbits/sec   33             sender
+[  7][TX-C]   0.00-10.02  sec   117 MBytes  98.4 Mbits/sec                  receiver
+[SUM][TX-C]   0.00-10.00  sec   251 MBytes   211 Mbits/sec   93             sender
+[SUM][TX-C]   0.00-10.02  sec   250 MBytes   209 Mbits/sec                  receiver
+[  9][RX-C]   0.00-10.00  sec  72.9 MBytes  61.2 Mbits/sec                  sender
+[  9][RX-C]   0.00-10.02  sec  72.5 MBytes  60.7 Mbits/sec                  receiver
+[ 11][RX-C]   0.00-10.00  sec  67.5 MBytes  56.6 Mbits/sec                  sender
+[ 11][RX-C]   0.00-10.02  sec  67.2 MBytes  56.3 Mbits/sec                  receiver
+[SUM][RX-C]   0.00-10.00  sec   140 MBytes   118 Mbits/sec                  sender
+[SUM][RX-C]   0.00-10.02  sec   140 MBytes   117 Mbits/sec                  receiver
+
+AES128-SHA1
+
+SUM TX 210
+SUM RX 117
+
+TOTAL: 327 Mbps Full Duplex
+
+[ ID][Role] Interval           Transfer     Bitrate         Retr
+[  5][TX-C]   0.00-10.00  sec   151 MBytes   127 Mbits/sec    4             sender
+[  5][TX-C]   0.00-10.02  sec   149 MBytes   125 Mbits/sec                  receiver
+[  7][TX-C]   0.00-10.00  sec   132 MBytes   110 Mbits/sec    3             sender
+[  7][TX-C]   0.00-10.02  sec   131 MBytes   110 Mbits/sec                  receiver
+[SUM][TX-C]   0.00-10.00  sec   283 MBytes   237 Mbits/sec    7             sender
+[SUM][TX-C]   0.00-10.02  sec   280 MBytes   234 Mbits/sec                  receiver
+[  9][RX-C]   0.00-10.00  sec  43.6 MBytes  36.6 Mbits/sec                  sender
+[  9][RX-C]   0.00-10.02  sec  43.2 MBytes  36.2 Mbits/sec                  receiver
+[ 11][RX-C]   0.00-10.00  sec  79.3 MBytes  66.5 Mbits/sec                  sender
+[ 11][RX-C]   0.00-10.02  sec  78.7 MBytes  65.9 Mbits/sec                  receiver
+[SUM][RX-C]   0.00-10.00  sec   123 MBytes   103 Mbits/sec                  sender
+[SUM][RX-C]   0.00-10.02  sec   122 MBytes   102 Mbits/sec                  receiver
+
+AES256-SHA256
+
+SUM TX 235
+SUM RX 102
+
+TOTAL: 337 Mbps Full Duplex
+
+[ ID][Role] Interval           Transfer     Bitrate         Retr
+[  5][TX-C]   0.00-10.00  sec   165 MBytes   138 Mbits/sec  189             sender
+[  5][TX-C]   0.00-10.02  sec   162 MBytes   136 Mbits/sec                  receiver
+[  7][TX-C]   0.00-10.00  sec  90.5 MBytes  75.9 Mbits/sec   92             sender
+[  7][TX-C]   0.00-10.02  sec  89.3 MBytes  74.7 Mbits/sec                  receiver
+[SUM][TX-C]   0.00-10.00  sec   255 MBytes   214 Mbits/sec  281             sender
+[SUM][TX-C]   0.00-10.02  sec   252 MBytes   211 Mbits/sec                  receiver
+[  9][RX-C]   0.00-10.00  sec  68.6 MBytes  57.5 Mbits/sec                  sender
+[  9][RX-C]   0.00-10.02  sec  68.3 MBytes  57.1 Mbits/sec                  receiver
+[ 11][RX-C]   0.00-10.00  sec   106 MBytes  88.6 Mbits/sec                  sender
+[ 11][RX-C]   0.00-10.02  sec   105 MBytes  88.0 Mbits/sec                  receiver
+[SUM][RX-C]   0.00-10.00  sec   174 MBytes   146 Mbits/sec                  sender
+[SUM][RX-C]   0.00-10.02  sec   173 MBytes   145 Mbits/sec                  receiver
+
+AES128CTR-SHA256
+
+SUM TX 212
+SUM RX 145
+
+TOTAL: 357 Mbps Ful Duplex
diff --git a/package/kernel/mtk-eip93/LICENSE b/package/kernel/mtk-eip93/LICENSE
new file mode 100644
index 0000000..d159169
--- /dev/null
+++ b/package/kernel/mtk-eip93/LICENSE
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/package/kernel/mtk-eip93/Makefile b/package/kernel/mtk-eip93/Makefile
new file mode 100644
index 0000000..dd86a59
--- /dev/null
+++ b/package/kernel/mtk-eip93/Makefile
@@ -0,0 +1,155 @@
+#
+# Copyright (C) 2006-2019 OpenWrt.org
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=mtk-eip93
+PKG_RELEASE:=1.5
+
+include $(INCLUDE_DIR)/kernel.mk
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/crypto-hw-eip93
+	SECTION:=kernel
+	CATEGORY:=Kernel modules
+	SUBMENU:=Cryptographic API modules
+	DEPENDS:= @TARGET_ramips_mt7621 +kmod-crypto-manager +kmod-crypto-authenc +kmod-crypto-des +kmod-ipsec +kmod-ipsec4
+	KCONFIG:=
+	TITLE:=MTK EIP93 crypto module
+	FILES:=$(PKG_BUILD_DIR)/crypto-hw-eip93.ko
+	AUTOLOAD:=$(call AutoProbe,crypto-hw-eip93)
+	MENU:=1
+endef
+
+define KernelPackage/crypto-hw-eip93/config
+if PACKAGE_kmod-crypto-hw-eip93
+
+comment "Build Options"
+
+config CRYPTO_DEV_EIP93
+	tristate
+		
+config CRYPTO_DEV_EIP93_AES
+	bool "Register AES algorithm implementatons with the Crypto API"
+	default y
+	select CRYPTO_DEV_EIP93
+	help
+	  Selecting this will offload AES - ECB, CBC and CTR crypto
+	  to the EIP-93 crypto engine.
+
+config CRYPTO_DEV_EIP93_DES
+	bool "Register DES algorithm implementatons with the Crypto API"
+	default y
+	select CRYPTO_DEV_EIP93
+	help
+	  Selecting this will offload DES / 3DES - ECB and CBC crypto
+	  to the EIP-93 crypto engine.
+
+config CRYPTO_DEV_EIP93_AEAD
+	bool "Register AEAD algorithm implementatons with the Crypto API"
+	default y
+	select CRYPTO_DEV_EIP93
+	help
+	  Selecting this will offload AEAD authenc(hmac(x), cipher(y))
+	  to the EIP-93 crypto engine.
+
+config CRYPTO_DEV_EIP93_HASH
+	bool "Register HASH algorithm implementatons with the Crypto API"
+	default n
+	select CRYPTO_DEV_EIP93
+	help
+	  Selecting this will offload SHA1, SHA224 and SHA256 hash algorithm
+	  and HMAC(SHA1), HMAC(SHA224) and HMAC(SHA256) to the EIP-93 crypto
+	  engine.
+
+config CRYPTO_DEV_EIP93_PRNG
+	bool "Register PRNG device with the Crypto API"
+	default n
+	select CRYPTO_DEV_EIP93
+	help
+	  Selecting this will add the ANSI X9.31 Pseudo Random Number Generator
+	  to the EIP-93 crypto engine.
+
+config CRYPTO_DEV_EIP93_IPSEC
+	bool "Register IPSec ESP hardware offloading"
+	default n
+	select CRYPTO_DEV_EIP93
+	select CRYPTO_DEV_EIP93_PRNG
+	select XFRM_OFFLOAD
+	help
+	  Selecting this will add ESP HW offloading for IPSec
+	  to the EIP-93 crypto engine. Requires IPSec offload
+	  to be selected with the Mediatek Ethernet Driver
+
+config CRYPTO_DEV_EIP93_POLL
+	bool "Disable interrupt and use polling. (experimental)"
+	default n
+	help
+ 	  Selecting this will disable interrupts and use polling for
+	  the EIP-93 crypto engine. (increases CPU load but improves
+	  OpenSSL user-space crypto.
+
+endif
+endef
+
+EXTRA_KCONFIG:= 
+
+ifdef CONFIG_CRYPTO_DEV_EIP93
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93=y
+endif
+
+ifdef CONFIG_CRYPTO_DEV_EIP93_AES
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_AES=y
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_SKCIPHER=y
+endif
+
+ifdef CONFIG_CRYPTO_DEV_EIP93_DES
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_DES=y
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_SKCIPHER=y
+endif
+
+ifdef CONFIG_CRYPTO_DEV_EIP93_AEAD
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_AEAD=y
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_HMAC=y
+endif
+
+ifdef CONFIG_CRYPTO_DEV_EIP93_HASH
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_HASH=y
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_HMAC=y
+endif
+
+ifdef CONFIG_CRYPTO_DEV_EIP93_PRNG
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_PRNG=y
+endif
+
+ifdef CONFIG_CRYPTO_DEV_EIP93_IPSEC
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_IPSEC=y
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_HMAC=y
+endif
+ifdef CONFIG_CRYPTO_DEV_EIP93_POLL
+	EXTRA_KCONFIG += CONFIG_CRYPTO_DEV_EIP93_POLL=y
+endif
+
+EXTRA_CFLAGS:= \
+	$(patsubst CONFIG_%, -DCONFIG_%=1, $(patsubst %=m,%,$(filter %=m,$(EXTRA_KCONFIG)))) \
+	$(patsubst CONFIG_%, -DCONFIG_%=1, $(patsubst %=y,%,$(filter %=y,$(EXTRA_KCONFIG))))
+
+MAKE_OPTS:= \
+	$(KERNEL_MAKE_FLAGS) \
+	M="$(PKG_BUILD_DIR)" \
+	EXTRA_CFLAGS="$(EXTRA_CFLAGS)" \
+	$(EXTRA_KCONFIG)
+
+define Build/Compile
+	$(MAKE) -C "$(LINUX_DIR)" \
+		$(MAKE_OPTS) \
+		modules
+endef
+
+$(eval $(call KernelPackage,crypto-hw-eip93))
diff --git a/package/kernel/mtk-eip93/README.md b/package/kernel/mtk-eip93/README.md
new file mode 100644
index 0000000..f2549ac
--- /dev/null
+++ b/package/kernel/mtk-eip93/README.md
@@ -0,0 +1,47 @@
+# Mediatek EIP93 Crypto Engine
+
+Linux Crypto Driver for the EIP-93. This Crypto engine is
+available in the Mediatek MT7621 SoC.
+
+This should be added to your device DTS or better yet to the mt7621.dtsi:
+
+	crypto: crypto@1e004000 {
+		status = "okay";
+
+		compatible = "mediatek,mtk-eip93";
+		reg = <0x1e004000 0x1000>;
+		
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+It enables hardware crypto for:
+* des ecb/cbc
+* 3des ecb/cbc
+* aes ecb / cbc / ctr /rfc3686 with 128/192/256 keysize.
+
+Authentication:
+* authenc(hmac(md5/sha1/sha224/sha256), des / 3des - cbc)
+* authenc(hmac(md5/sha1/224/256, des / 3des - cbc)
+* authenc(hmac(sha1/sha256), cbc / rfc3686(ctr) - aes) with 128/192/256 keysize
+
+Testing has been done on Linux Kernel v5.10.76 with all the extended tests enabled.
+
+copy or clone into "package/kernel"
+
+For ESP HW offload: copy the 999-add-esp-hw-offload.patch to "target/linux/ramips/patches-5.10"
+in the OpenWrt build system. This is a work-around to add XFRM_OFFLOAD to ESP4.
+DO NOT! use esp4/6-offload from the kernel: this will replace it!
+
+Experimental feature: Use Polling vs IRQ should not be used together with ESP HW offload.
+it is intended to be used when you want to use the driver from userspace e.g. with openssl and /dev/crypto
+
+For best performance move the interupt to another CPU. On the MT7621A I suggest moving it to CPU2:
+cat /proc/interrupt
+
+echo 4 >/proc/irq/21/smp_affinity (replace 21 with another number if its different, like on the MT7621S)
+
+TODO:
+finish the ansi prng implementation.
+
+finish ahash implemention for simple sha1/256 and hmac(sha1/sha256).
diff --git a/package/kernel/mtk-eip93/mediatek,mtk-eip93.yaml b/package/kernel/mtk-eip93/mediatek,mtk-eip93.yaml
new file mode 100644
index 0000000..6116599
--- /dev/null
+++ b/package/kernel/mtk-eip93/mediatek,mtk-eip93.yaml
@@ -0,0 +1,41 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/crypto/mediatek,mtk-eip93.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Mediatek EIP93 crypto engine
+
+maintainers:
+  - Richard van Schagen <vschagen@icloud.com>
+
+properties:
+  compatible:
+    enum:
+      - mediatek, mtk-eip93
+
+  reg:
+    maxItems: 1
+
+  interrupts-parent:
+    maxItems: 1
+
+  interrupts:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupt-parent
+  - interrupts
+
+additionalProperties: false
+
+examples:
+  - |
+    crypto: crypto@1e004000 {
+         compatible = "mediatek,mtk-eip93";
+         reg = <0x1e004000 0x1000>;
+         interrupt-parent = <&gic>;
+         interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+    };
diff --git a/package/kernel/mtk-eip93/src/Makefile b/package/kernel/mtk-eip93/src/Makefile
new file mode 100644
index 0000000..bd61beb
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0-only
+obj-m := crypto-hw-eip93.o
+
+crypto-hw-eip93-$(CONFIG_CRYPTO_DEV_EIP93) += eip93-main.o \
+						eip93-common.o
+
+crypto-hw-eip93-$(CONFIG_CRYPTO_DEV_EIP93_SKCIPHER) += eip93-cipher.o
+crypto-hw-eip93-$(CONFIG_CRYPTO_DEV_EIP93_AEAD) += eip93-aead.o
+crypto-hw-eip93-$(CONFIG_CRYPTO_DEV_EIP93_HASH) += eip93-hash.o
+crypto-hw-eip93-$(CONFIG_CRYPTO_DEV_EIP93_PRNG) += eip93-prng.o
+crypto-hw-eip93-$(CONFIG_CRYPTO_DEV_EIP93_IPSEC) += eip93-ipsec.o
diff --git a/package/kernel/mtk-eip93/src/eip93-aead.c b/package/kernel/mtk-eip93/src/eip93-aead.c
new file mode 100644
index 0000000..49a42a4
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-aead.c
@@ -0,0 +1,778 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#include <crypto/aead.h>
+#include <crypto/aes.h>
+#include <crypto/authenc.h>
+#include <crypto/ctr.h>
+#include <crypto/hmac.h>
+#include <crypto/internal/aead.h>
+#include <crypto/md5.h>
+#include <crypto/null.h>
+#include <crypto/sha.h>
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+#include <crypto/internal/des.h>
+#endif
+
+#include <linux/crypto.h>
+#include <linux/dma-mapping.h>
+
+#include "eip93-aead.h"
+#include "eip93-cipher.h"
+#include "eip93-regs.h"
+#include "eip93-common.h"
+
+void mtk_aead_handle_result(struct crypto_async_request *async, int err)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(async->tfm);
+	struct mtk_device *mtk = ctx->mtk;
+	struct aead_request *req = aead_request_cast(async);
+	struct mtk_cipher_reqctx *rctx = aead_request_ctx(req);
+
+	mtk_unmap_dma(mtk, rctx, req->src, req->dst);
+	mtk_handle_result(mtk, rctx, req->iv);
+
+	if (err == 1)
+		err = -EBADMSG;
+	if (err == 4)
+		err = 0; //SPI error
+
+	aead_request_complete(req, err);
+}
+
+static int mtk_aead_send_req(struct crypto_async_request *async)
+{
+	struct aead_request *req = aead_request_cast(async);
+	struct mtk_cipher_reqctx *rctx = aead_request_ctx(req);
+	int err;
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_POLL)
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct mtk_device *mtk = ctx->mtk;
+#endif
+
+	err = check_valid_request(rctx);
+	if (err) {
+		aead_request_complete(req, err);
+		return err;
+	}
+
+	err = mtk_send_req(async, req->iv, rctx);
+	if (err != -EINPROGRESS)
+		return err;
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_POLL)
+	mtk_handle_result_polling(mtk);
+#endif
+	return -EINPROGRESS;
+}
+
+/* Crypto aead API functions */
+static int mtk_aead_cra_init(struct crypto_tfm *tfm)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct mtk_alg_template *tmpl = container_of(tfm->__crt_alg,
+				struct mtk_alg_template, alg.aead.base);
+	u32 flags = tmpl->flags;
+	char *alg_base;
+
+	memset(ctx, 0, sizeof(*ctx));
+
+	crypto_aead_set_reqsize(__crypto_aead_cast(tfm),
+			sizeof(struct mtk_cipher_reqctx));
+
+	ctx->mtk = tmpl->mtk;
+	ctx->in_first = true;
+	ctx->out_first = true;
+
+	ctx->sa_in = kzalloc(sizeof(struct saRecord_s), GFP_KERNEL);
+	if (!ctx->sa_in)
+		return -ENOMEM;
+
+	ctx->sa_base_in = dma_map_single(ctx->mtk->dev, ctx->sa_in,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	ctx->sa_out = kzalloc(sizeof(struct saRecord_s), GFP_KERNEL);
+	if (!ctx->sa_out)
+		return -ENOMEM;
+
+	ctx->sa_base_out = dma_map_single(ctx->mtk->dev, ctx->sa_out,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	/* software workaround for now */
+	if (IS_HASH_MD5(flags))
+		alg_base = "md5";
+	if (IS_HASH_SHA1(flags))
+		alg_base = "sha1";
+	if (IS_HASH_SHA224(flags))
+		alg_base = "sha224";
+	if (IS_HASH_SHA256(flags))
+		alg_base = "sha256";
+
+	ctx->shash = crypto_alloc_shash(alg_base, 0, CRYPTO_ALG_NEED_FALLBACK);
+
+	if (IS_ERR(ctx->shash)) {
+		dev_err(ctx->mtk->dev, "base driver %s could not be loaded.\n",
+				alg_base);
+		return PTR_ERR(ctx->shash);
+	}
+
+	return 0;
+}
+
+static void mtk_aead_cra_exit(struct crypto_tfm *tfm)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	if (ctx->shash)
+		crypto_free_shash(ctx->shash);
+
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_out,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+	kfree(ctx->sa_in);
+	kfree(ctx->sa_out);
+}
+
+static int mtk_aead_setkey(struct crypto_aead *ctfm, const u8 *key,
+			unsigned int len)
+{
+	struct crypto_tfm *tfm = crypto_aead_tfm(ctfm);
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct mtk_alg_template *tmpl = container_of(tfm->__crt_alg,
+				struct mtk_alg_template, alg.skcipher.base);
+	u32 flags = tmpl->flags;
+	u32 nonce = 0;
+	struct crypto_authenc_keys keys;
+	struct crypto_aes_ctx aes;
+	struct saRecord_s *saRecord = ctx->sa_out;
+	int sa_size = sizeof(struct saRecord_s);
+	int err = -EINVAL;
+
+	if (crypto_authenc_extractkeys(&keys, key, len))
+		return err;
+
+	if (IS_RFC3686(flags)) {
+		if (keys.enckeylen < CTR_RFC3686_NONCE_SIZE)
+			return err;
+
+		keys.enckeylen -= CTR_RFC3686_NONCE_SIZE;
+		memcpy(&nonce, keys.enckey + keys.enckeylen,
+						CTR_RFC3686_NONCE_SIZE);
+	}
+
+	switch ((flags & MTK_ALG_MASK)) {
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+	case MTK_ALG_DES:
+		err = verify_aead_des_key(ctfm, keys.enckey, keys.enckeylen);
+		break;
+	case MTK_ALG_3DES:
+		if (keys.enckeylen != DES3_EDE_KEY_SIZE)
+			return -EINVAL;
+
+		err = verify_aead_des3_key(ctfm, keys.enckey, keys.enckeylen);
+		break;
+#endif
+	case MTK_ALG_AES:
+		err = aes_expandkey(&aes, keys.enckey, keys.enckeylen);
+	}
+	if (err)
+		return err;
+
+	ctx->blksize = crypto_aead_blocksize(ctfm);
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in, sa_size,
+								DMA_TO_DEVICE);
+
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_out, sa_size,
+								DMA_TO_DEVICE);
+	/* Encryption key */
+	mtk_set_saRecord(saRecord, keys.enckeylen, flags);
+	saRecord->saCmd0.bits.opCode = 1;
+	saRecord->saCmd0.bits.digestLength = ctx->authsize >> 2;
+
+	memcpy(saRecord->saKey, keys.enckey, keys.enckeylen);
+	ctx->saNonce = nonce;
+	saRecord->saNonce = nonce;
+
+	/* authentication key */
+	err = mtk_authenc_setkey(ctx->shash, saRecord, keys.authkey,
+							keys.authkeylen);
+
+	saRecord->saCmd0.bits.direction = 0;
+	memcpy(ctx->sa_in, saRecord, sa_size);
+	ctx->sa_in->saCmd0.bits.direction = 1;
+	ctx->sa_in->saCmd1.bits.copyDigest = 0;
+
+	ctx->sa_base_out = dma_map_single(ctx->mtk->dev, ctx->sa_out, sa_size,
+								DMA_TO_DEVICE);
+	ctx->sa_base_in = dma_map_single(ctx->mtk->dev, ctx->sa_in, sa_size,
+								DMA_TO_DEVICE);
+	ctx->in_first = true;
+	ctx->out_first = true;
+
+	return err;
+}
+
+static int mtk_aead_setauthsize(struct crypto_aead *ctfm,
+				unsigned int authsize)
+{
+	struct crypto_tfm *tfm = crypto_aead_tfm(ctfm);
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_out,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	ctx->authsize = authsize;
+	ctx->sa_in->saCmd0.bits.digestLength = ctx->authsize >> 2;
+	ctx->sa_out->saCmd0.bits.digestLength = ctx->authsize >> 2;
+
+	ctx->sa_base_out = dma_map_single(ctx->mtk->dev, ctx->sa_out,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+	ctx->sa_base_in = dma_map_single(ctx->mtk->dev, ctx->sa_in,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+	return 0;
+}
+
+static void mtk_aead_setassoc(struct mtk_crypto_ctx *ctx,
+			struct aead_request *req, bool in)
+{
+	struct saRecord_s *saRecord;
+
+	if (in) {
+		dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+		saRecord = ctx->sa_in;
+		saRecord->saCmd1.bits.hashCryptOffset = req->assoclen >> 2;
+
+		ctx->sa_base_in = dma_map_single(ctx->mtk->dev, ctx->sa_in,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+		ctx->assoclen_in = req->assoclen;
+	} else {
+		dma_unmap_single(ctx->mtk->dev, ctx->sa_base_out,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+		saRecord = ctx->sa_out;
+		saRecord->saCmd1.bits.hashCryptOffset = req->assoclen >> 2;
+
+		ctx->sa_base_out = dma_map_single(ctx->mtk->dev, ctx->sa_out,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+		ctx->assoclen_out = req->assoclen;
+	}
+}
+
+static int mtk_aead_crypt(struct aead_request *req)
+{
+	struct mtk_cipher_reqctx *rctx = aead_request_ctx(req);
+	struct crypto_async_request *async = &req->base;
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct crypto_aead *aead = crypto_aead_reqtfm(req);
+
+	rctx->textsize = req->cryptlen;
+	rctx->blksize = ctx->blksize;
+	rctx->assoclen = req->assoclen;
+	rctx->authsize = ctx->authsize;
+	rctx->sg_src = req->src;
+	rctx->sg_dst = req->dst;
+	rctx->ivsize = crypto_aead_ivsize(aead);
+	rctx->flags |= MTK_DESC_AEAD;
+
+	if IS_DECRYPT(rctx->flags)
+		rctx->textsize -= rctx->authsize;
+
+	return mtk_aead_send_req(async);
+}
+
+static int mtk_aead_encrypt(struct aead_request *req)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct mtk_cipher_reqctx *rctx = aead_request_ctx(req);
+	struct mtk_alg_template *tmpl = container_of(req->base.tfm->__crt_alg,
+				struct mtk_alg_template, alg.aead.base);
+
+	rctx->flags = tmpl->flags;
+	rctx->flags |= MTK_ENCRYPT;
+	if (ctx->out_first) {
+		mtk_aead_setassoc(ctx, req, false);
+		ctx->out_first = false;
+	}
+
+	if (req->assoclen != ctx->assoclen_out) {
+		dev_err(ctx->mtk->dev, "Request AAD length error\n");
+		return -EINVAL;
+	}
+
+	rctx->saRecord_base = ctx->sa_base_out;
+
+	return mtk_aead_crypt(req);
+}
+
+static int mtk_aead_decrypt(struct aead_request *req)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct mtk_cipher_reqctx *rctx = aead_request_ctx(req);
+	struct mtk_alg_template *tmpl = container_of(req->base.tfm->__crt_alg,
+				struct mtk_alg_template, alg.aead.base);
+
+	rctx->flags = tmpl->flags;
+	rctx->flags |= MTK_DECRYPT;
+	if (ctx->in_first) {
+		mtk_aead_setassoc(ctx, req, true);
+		ctx->in_first = false;
+	}
+
+	if (req->assoclen != ctx->assoclen_in) {
+		dev_err(ctx->mtk->dev, "Request AAD length error\n");
+		return -EINVAL;
+	}
+
+	rctx->saRecord_base = ctx->sa_base_in;
+
+	return mtk_aead_crypt(req);
+}
+
+/* Available authenc algorithms in this module */
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+struct mtk_alg_template mtk_alg_authenc_hmac_md5_cbc_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_MD5 | MTK_MODE_CBC | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= AES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = MD5_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(md5),cbc(aes))",
+			.cra_driver_name =
+				"authenc(hmac(md5-eip93), cbc(aes-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha1_cbc_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA1 | MTK_MODE_CBC | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= AES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA1_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha1),cbc(aes))",
+			.cra_driver_name =
+				"authenc(hmac(sha1-eip93),cbc(aes-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha224_cbc_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA224 | MTK_MODE_CBC | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= AES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA224_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha224),cbc(aes))",
+			.cra_driver_name =
+				"authenc(hmac(sha224-eip93),cbc(aes-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha256_cbc_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA256 | MTK_MODE_CBC | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= AES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA256_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha256),cbc(aes))",
+			.cra_driver_name =
+				"authenc(hmac(sha256-eip93),cbc(aes-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_md5_rfc3686_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_MD5 |
+			MTK_MODE_CTR | MTK_MODE_RFC3686 | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= CTR_RFC3686_IV_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = MD5_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(md5),rfc3686(ctr(aes)))",
+			.cra_driver_name =
+			"authenc(hmac(md5-eip93),rfc3686(ctr(aes-eip93)))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = 1,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha1_rfc3686_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA1 |
+			MTK_MODE_CTR | MTK_MODE_RFC3686 | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= CTR_RFC3686_IV_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA1_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha1),rfc3686(ctr(aes)))",
+			.cra_driver_name =
+			"authenc(hmac(sha1-eip93),rfc3686(ctr(aes-eip93)))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = 1,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha224_rfc3686_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA224 |
+			MTK_MODE_CTR | MTK_MODE_RFC3686 | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= CTR_RFC3686_IV_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA224_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha224),rfc3686(ctr(aes)))",
+			.cra_driver_name =
+			"authenc(hmac(sha224-eip93),rfc3686(ctr(aes-eip93)))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = 1,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha256_rfc3686_aes = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA256 |
+			MTK_MODE_CTR | MTK_MODE_RFC3686 | MTK_ALG_AES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= CTR_RFC3686_IV_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA256_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha256),rfc3686(ctr(aes)))",
+			.cra_driver_name =
+			"authenc(hmac(sha256-eip93),rfc3686(ctr(aes-eip93)))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = 1,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+struct mtk_alg_template mtk_alg_authenc_hmac_md5_cbc_des = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_MD5 | MTK_MODE_CBC | MTK_ALG_DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = MD5_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(md5),cbc(des))",
+			.cra_driver_name =
+				"authenc(hmac(md5-eip93),cbc(des-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha1_cbc_des = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA1 | MTK_MODE_CBC | MTK_ALG_DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA1_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha1),cbc(des))",
+			.cra_driver_name =
+				"authenc(hmac(sha1-eip93),cbc(des-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha224_cbc_des = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA224 | MTK_MODE_CBC | MTK_ALG_DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA224_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha224),cbc(des))",
+			.cra_driver_name =
+				"authenc(hmac(sha224-eip93),cbc(des-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha256_cbc_des = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA256 | MTK_MODE_CBC | MTK_ALG_DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA256_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha256),cbc(des))",
+			.cra_driver_name =
+				"authenc(hmac(sha256-eip93),cbc(des-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_md5_cbc_des3_ede = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_MD5 | MTK_MODE_CBC | MTK_ALG_3DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES3_EDE_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = MD5_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(md5),cbc(des3_ede))",
+			.cra_driver_name =
+				"authenc(hmac(md5-eip93),cbc(des3_ede-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0x0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha1_cbc_des3_ede = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA1 | MTK_MODE_CBC | MTK_ALG_3DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES3_EDE_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA1_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha1),cbc(des3_ede))",
+			.cra_driver_name =
+				"authenc(hmac(sha1-eip93),cbc(des3_ede-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0x0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha224_cbc_des3_ede = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA224 | MTK_MODE_CBC | MTK_ALG_3DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES3_EDE_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA224_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha224),cbc(des3_ede))",
+			.cra_driver_name =
+			"authenc(hmac(sha224-eip93),cbc(des3_ede-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0x0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_authenc_hmac_sha256_cbc_des3_ede = {
+	.type = MTK_ALG_TYPE_AEAD,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA256 | MTK_MODE_CBC | MTK_ALG_3DES,
+	.alg.aead = {
+		.setkey = mtk_aead_setkey,
+		.encrypt = mtk_aead_encrypt,
+		.decrypt = mtk_aead_decrypt,
+		.ivsize	= DES3_EDE_BLOCK_SIZE,
+		.setauthsize = mtk_aead_setauthsize,
+		.maxauthsize = SHA256_DIGEST_SIZE,
+		.base = {
+			.cra_name = "authenc(hmac(sha256),cbc(des3_ede))",
+			.cra_driver_name =
+			"authenc(hmac(sha256-eip93),cbc(des3_ede-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0x0,
+			.cra_init = mtk_aead_cra_init,
+			.cra_exit = mtk_aead_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+#endif
diff --git a/package/kernel/mtk-eip93/src/eip93-aead.h b/package/kernel/mtk-eip93/src/eip93-aead.h
new file mode 100644
index 0000000..889c5bd
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-aead.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+#ifndef _EIP93_AEAD_H_
+#define _EIP93_AEAD_H_
+
+extern struct mtk_alg_template mtk_alg_authenc_hmac_md5_cbc_aes;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha1_cbc_aes;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha224_cbc_aes;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha256_cbc_aes;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_md5_rfc3686_aes;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha1_rfc3686_aes;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha224_rfc3686_aes;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha256_rfc3686_aes;
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+extern struct mtk_alg_template mtk_alg_authenc_hmac_md5_cbc_des;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha1_cbc_des;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha224_cbc_des;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha256_cbc_des;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_md5_cbc_des3_ede;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha1_cbc_des3_ede;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha224_cbc_des3_ede;
+extern struct mtk_alg_template mtk_alg_authenc_hmac_sha256_cbc_des3_ede;
+#endif
+
+void mtk_aead_handle_result(struct crypto_async_request *async,	int err);
+
+#endif /* _EIP93_AEAD_H_ */
diff --git a/package/kernel/mtk-eip93/src/eip93-aes.h b/package/kernel/mtk-eip93/src/eip93-aes.h
new file mode 100644
index 0000000..1d0b985
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-aes.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+#ifndef _EIP93_AES_H_
+#define _EIP93_AES_H_
+
+extern struct mtk_alg_template mtk_alg_ecb_aes;
+extern struct mtk_alg_template mtk_alg_cbc_aes;
+extern struct mtk_alg_template mtk_alg_ctr_aes;
+extern struct mtk_alg_template mtk_alg_rfc3686_aes;
+
+#endif /* _EIP93_AES_H_ */
diff --git a/package/kernel/mtk-eip93/src/eip93-cipher.c b/package/kernel/mtk-eip93/src/eip93-cipher.c
new file mode 100644
index 0000000..4ae3efc
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-cipher.c
@@ -0,0 +1,440 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+#include <crypto/aes.h>
+#include <crypto/ctr.h>
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+#include <crypto/internal/des.h>
+#endif
+#include <linux/dma-mapping.h>
+
+#include "eip93-cipher.h"
+#include "eip93-common.h"
+#include "eip93-regs.h"
+
+void mtk_skcipher_handle_result(struct crypto_async_request *async, int err)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(async->tfm);
+	struct mtk_device *mtk = ctx->mtk;
+	struct skcipher_request *req = skcipher_request_cast(async);
+	struct mtk_cipher_reqctx *rctx = skcipher_request_ctx(req);
+
+	mtk_unmap_dma(mtk, rctx, req->src, req->dst);
+	mtk_handle_result(mtk, rctx, req->iv);
+
+	skcipher_request_complete(req, err);
+}
+
+static int mtk_skcipher_send_req(struct crypto_async_request *async)
+{
+	struct skcipher_request *req = skcipher_request_cast(async);
+	struct mtk_cipher_reqctx *rctx = skcipher_request_ctx(req);
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_POLL)
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(async->tfm);
+	struct mtk_device *mtk = ctx->mtk;
+#endif
+	int err;
+
+	err = check_valid_request(rctx);
+
+	if (err) {
+		skcipher_request_complete(req, err);
+		return err;
+	}
+	err = mtk_send_req(async, req->iv, rctx);
+	if (err != -EINPROGRESS)
+		return err;
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_POLL)
+	mtk_handle_result_polling(mtk);
+#endif
+	return -EINPROGRESS;
+}
+
+/* Crypto skcipher API functions */
+static int mtk_skcipher_cra_init(struct crypto_tfm *tfm)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct mtk_alg_template *tmpl = container_of(tfm->__crt_alg,
+				struct mtk_alg_template, alg.skcipher.base);
+
+	crypto_skcipher_set_reqsize(__crypto_skcipher_cast(tfm),
+					sizeof(struct mtk_cipher_reqctx));
+
+	memset(ctx, 0, sizeof(*ctx));
+
+	ctx->mtk = tmpl->mtk;
+
+	ctx->sa_in = kzalloc(sizeof(struct saRecord_s), GFP_KERNEL);
+	if (!ctx->sa_in)
+		return -ENOMEM;
+
+	ctx->sa_base_in = dma_map_single(ctx->mtk->dev, ctx->sa_in,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	ctx->sa_out = kzalloc(sizeof(struct saRecord_s), GFP_KERNEL);
+	if (!ctx->sa_out)
+		return -ENOMEM;
+
+	ctx->sa_base_out = dma_map_single(ctx->mtk->dev, ctx->sa_out,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+	return 0;
+}
+
+static void mtk_skcipher_cra_exit(struct crypto_tfm *tfm)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_out,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+	kfree(ctx->sa_in);
+	kfree(ctx->sa_out);
+}
+
+static int mtk_skcipher_setkey(struct crypto_skcipher *ctfm, const u8 *key,
+				 unsigned int len)
+{
+	struct crypto_tfm *tfm = crypto_skcipher_tfm(ctfm);
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct mtk_alg_template *tmpl = container_of(tfm->__crt_alg,
+				struct mtk_alg_template, alg.skcipher.base);
+	u32 flags = tmpl->flags;
+	struct saRecord_s *saRecord = ctx->sa_out;
+	u32 nonce = 0;
+	unsigned int keylen = len;
+	int sa_size = sizeof(struct saRecord_s);
+	int err = -EINVAL;
+
+	if (!key || !keylen)
+		return err;
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+	if (IS_RFC3686(flags)) {
+		if (len < CTR_RFC3686_NONCE_SIZE)
+			return err;
+
+		keylen = len - CTR_RFC3686_NONCE_SIZE;
+		memcpy(&nonce, key + keylen, CTR_RFC3686_NONCE_SIZE);
+	}
+#endif
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+	if (flags & MTK_ALG_DES) {
+		ctx->blksize = DES_BLOCK_SIZE;
+		err = verify_skcipher_des_key(ctfm, key);
+	}
+	if (flags & MTK_ALG_3DES) {
+		ctx->blksize = DES3_EDE_BLOCK_SIZE;
+		err = verify_skcipher_des3_key(ctfm, key);
+	}
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+	if (flags & MTK_ALG_AES) {
+		struct crypto_aes_ctx aes;
+
+		ctx->blksize = AES_BLOCK_SIZE;
+		err = aes_expandkey(&aes, key, keylen);
+	}
+#endif
+	if (err)
+		return err;
+
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in, sa_size,
+								DMA_TO_DEVICE);
+
+	dma_unmap_single(ctx->mtk->dev, ctx->sa_base_out, sa_size,
+								DMA_TO_DEVICE);
+
+	mtk_set_saRecord(saRecord, keylen, flags);
+
+	memcpy(saRecord->saKey, key, keylen);
+	ctx->saNonce = nonce;
+	saRecord->saNonce = nonce;
+	saRecord->saCmd0.bits.direction = 0;
+
+	memcpy(ctx->sa_in, saRecord, sa_size);
+	ctx->sa_in->saCmd0.bits.direction = 1;
+
+	ctx->sa_base_out = dma_map_single(ctx->mtk->dev, ctx->sa_out, sa_size,
+								DMA_TO_DEVICE);
+
+	ctx->sa_base_in = dma_map_single(ctx->mtk->dev, ctx->sa_in, sa_size,
+								DMA_TO_DEVICE);
+	return err;
+}
+
+static int mtk_skcipher_crypt(struct skcipher_request *req)
+{
+	struct mtk_cipher_reqctx *rctx = skcipher_request_ctx(req);
+	struct crypto_async_request *async = &req->base;
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct crypto_skcipher *skcipher = crypto_skcipher_reqtfm(req);
+
+	if (!req->cryptlen)
+		return 0;
+
+	rctx->assoclen = 0;
+	rctx->textsize = req->cryptlen;
+	rctx->authsize = 0;
+	rctx->sg_src = req->src;
+	rctx->sg_dst = req->dst;
+	rctx->ivsize = crypto_skcipher_ivsize(skcipher);
+	rctx->blksize = ctx->blksize;
+	rctx->flags |= MTK_DESC_SKCIPHER;
+	if (!IS_ECB(rctx->flags))
+		rctx->flags |= MTK_DESC_DMA_IV;
+
+	return mtk_skcipher_send_req(async);
+}
+
+static int mtk_skcipher_encrypt(struct skcipher_request *req)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct mtk_cipher_reqctx *rctx = skcipher_request_ctx(req);
+	struct mtk_alg_template *tmpl = container_of(req->base.tfm->__crt_alg,
+				struct mtk_alg_template, alg.skcipher.base);
+
+	rctx->flags = tmpl->flags;
+	rctx->flags |= MTK_ENCRYPT;
+	rctx->saRecord_base = ctx->sa_base_out;
+
+	return mtk_skcipher_crypt(req);
+}
+
+static int mtk_skcipher_decrypt(struct skcipher_request *req)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(req->base.tfm);
+	struct mtk_cipher_reqctx *rctx = skcipher_request_ctx(req);
+	struct mtk_alg_template *tmpl = container_of(req->base.tfm->__crt_alg,
+				struct mtk_alg_template, alg.skcipher.base);
+
+	rctx->flags = tmpl->flags;
+	rctx->flags |= MTK_DECRYPT;
+	rctx->saRecord_base = ctx->sa_base_in;
+
+	return mtk_skcipher_crypt(req);
+}
+
+/* Available algorithms in this module */
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+struct mtk_alg_template mtk_alg_ecb_aes = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_ECB | MTK_ALG_AES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = AES_MIN_KEY_SIZE,
+		.max_keysize = AES_MAX_KEY_SIZE,
+		.ivsize	= 0,
+		.base = {
+			.cra_name = "ecb(aes)",
+			.cra_driver_name = "ecb(aes-eip93)",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_NEED_FALLBACK |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0xf,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_cbc_aes = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_CBC | MTK_ALG_AES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = AES_MIN_KEY_SIZE,
+		.max_keysize = AES_MAX_KEY_SIZE,
+		.ivsize	= AES_BLOCK_SIZE,
+		.base = {
+			.cra_name = "cbc(aes)",
+			.cra_driver_name = "cbc(aes-eip93)",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_NEED_FALLBACK |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = AES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0xf,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_ctr_aes = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_CTR | MTK_ALG_AES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = AES_MIN_KEY_SIZE,
+		.max_keysize = AES_MAX_KEY_SIZE,
+		.ivsize	= AES_BLOCK_SIZE,
+		.base = {
+			.cra_name = "ctr(aes)",
+			.cra_driver_name = "ctr(aes-eip93)",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+				     CRYPTO_ALG_NEED_FALLBACK |
+				     CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = 1,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0xf,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_rfc3686_aes = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_CTR | MTK_MODE_RFC3686 | MTK_ALG_AES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+		.max_keysize = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+		.ivsize	= CTR_RFC3686_IV_SIZE,
+		.base = {
+			.cra_name = "rfc3686(ctr(aes))",
+			.cra_driver_name = "rfc3686(ctr(aes-eip93))",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_NEED_FALLBACK |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = 1,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0xf,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+struct mtk_alg_template mtk_alg_ecb_des = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_ECB | MTK_ALG_DES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = DES_KEY_SIZE,
+		.max_keysize = DES_KEY_SIZE,
+		.ivsize	= 0,
+		.base = {
+			.cra_name = "ecb(des)",
+			.cra_driver_name = "ebc(des-eip93)",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_cbc_des = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_CBC | MTK_ALG_DES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = DES_KEY_SIZE,
+		.max_keysize = DES_KEY_SIZE,
+		.ivsize	= DES_BLOCK_SIZE,
+		.base = {
+			.cra_name = "cbc(des)",
+			.cra_driver_name = "cbc(des-eip93)",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_ecb_des3_ede = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_ECB | MTK_ALG_3DES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = DES3_EDE_KEY_SIZE,
+		.max_keysize = DES3_EDE_KEY_SIZE,
+		.ivsize	= 0,
+		.base = {
+			.cra_name = "ecb(des3_ede)",
+			.cra_driver_name = "ecb(des3_ede-eip93)",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_cbc_des3_ede = {
+	.type = MTK_ALG_TYPE_SKCIPHER,
+	.flags = MTK_MODE_CBC | MTK_ALG_3DES,
+	.alg.skcipher = {
+		.setkey = mtk_skcipher_setkey,
+		.encrypt = mtk_skcipher_encrypt,
+		.decrypt = mtk_skcipher_decrypt,
+		.min_keysize = DES3_EDE_KEY_SIZE,
+		.max_keysize = DES3_EDE_KEY_SIZE,
+		.ivsize	= DES3_EDE_BLOCK_SIZE,
+		.base = {
+			.cra_name = "cbc(des3_ede)",
+			.cra_driver_name = "cbc(des3_ede-eip93)",
+			.cra_priority = MTK_CRA_PRIORITY,
+			.cra_flags = CRYPTO_ALG_ASYNC |
+					CRYPTO_ALG_KERN_DRIVER_ONLY,
+			.cra_blocksize = DES3_EDE_BLOCK_SIZE,
+			.cra_ctxsize = sizeof(struct mtk_crypto_ctx),
+			.cra_alignmask = 0,
+			.cra_init = mtk_skcipher_cra_init,
+			.cra_exit = mtk_skcipher_cra_exit,
+			.cra_module = THIS_MODULE,
+		},
+	},
+};
+#endif
diff --git a/package/kernel/mtk-eip93/src/eip93-cipher.h b/package/kernel/mtk-eip93/src/eip93-cipher.h
new file mode 100644
index 0000000..d2f780f
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-cipher.h
@@ -0,0 +1,63 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+#ifndef _EIP93_CIPHER_H_
+#define _EIP93_CIPHER_H_
+
+#include "eip93-main.h"
+
+struct mtk_crypto_ctx {
+	struct mtk_device	*mtk;
+	struct saRecord_s	*sa_in;
+	dma_addr_t		sa_base_in;
+	struct saRecord_s	*sa_out;
+	dma_addr_t		sa_base_out;
+	u32			saNonce;
+	u32			blksize;
+	/* AEAD specific */
+	u32			authsize;
+	u32			assoclen_in;
+	u32			assoclen_out;
+	bool			in_first;
+	bool			out_first;
+	struct crypto_shash	*shash;
+};
+
+struct mtk_cipher_reqctx {
+	u32				flags;
+	u32				blksize;
+	u32				ivsize;
+	u32				textsize;
+	u32				assoclen;
+	u32				authsize;
+	dma_addr_t			saRecord_base;
+	struct saState_s		*saState;
+	dma_addr_t			saState_base;
+	u32				saState_idx;
+	struct eip93_descriptor_s	*cdesc;
+	struct scatterlist		*sg_src;
+	struct scatterlist		*sg_dst;
+	int				src_nents;
+	int				dst_nents;
+	struct saState_s		*saState_ctr;
+	dma_addr_t			saState_base_ctr;
+	u32				saState_ctr_idx;
+};
+
+int check_valid_request(struct mtk_cipher_reqctx *rctx);
+
+void mtk_unmap_dma(struct mtk_device *mtk, struct mtk_cipher_reqctx *rctx,
+			struct scatterlist *reqsrc, struct scatterlist *reqdst);
+
+void mtk_skcipher_handle_result(struct crypto_async_request *async, int err);
+
+int mtk_send_req(struct crypto_async_request *async,
+			const u8 *reqiv, struct mtk_cipher_reqctx *rctx);
+
+void mtk_handle_result(struct mtk_device *mtk, struct mtk_cipher_reqctx *rctx,
+			u8 *reqiv);
+
+#endif /* _EIP93_CIPHER_H_ */
diff --git a/package/kernel/mtk-eip93/src/eip93-common.c b/package/kernel/mtk-eip93/src/eip93-common.c
new file mode 100644
index 0000000..768e545
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-common.c
@@ -0,0 +1,750 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+
+#include <crypto/aes.h>
+#include <crypto/ctr.h>
+#include <crypto/hmac.h>
+#include <crypto/sha.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+
+#include "eip93-cipher.h"
+#include "eip93-common.h"
+#include "eip93-main.h"
+#include "eip93-regs.h"
+
+inline void *mtk_ring_next_wptr(struct mtk_device *mtk,
+						struct mtk_desc_ring *ring)
+{
+	void *ptr = ring->write;
+
+	if ((ring->write == ring->read - ring->offset) ||
+		(ring->read == ring->base && ring->write == ring->base_end))
+		return ERR_PTR(-ENOMEM);
+
+	if (ring->write == ring->base_end)
+		ring->write = ring->base;
+	else
+		ring->write += ring->offset;
+
+	return ptr;
+}
+
+inline void *mtk_ring_next_rptr(struct mtk_device *mtk,
+						struct mtk_desc_ring *ring)
+{
+	void *ptr = ring->read;
+
+	if (ring->write == ring->read)
+		return ERR_PTR(-ENOENT);
+
+	if (ring->read == ring->base_end)
+		ring->read = ring->base;
+	else
+		ring->read += ring->offset;
+
+	return ptr;
+}
+
+inline int mtk_put_descriptor(struct mtk_device *mtk,
+					struct eip93_descriptor_s *desc)
+{
+	struct eip93_descriptor_s *cdesc;
+	struct eip93_descriptor_s *rdesc;
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&mtk->ring->write_lock, irqflags);
+
+	rdesc = mtk_ring_next_wptr(mtk, &mtk->ring->rdr);
+
+	if (IS_ERR(rdesc)) {
+		spin_unlock_irqrestore(&mtk->ring->write_lock, irqflags);
+		return -ENOENT;
+	}
+
+	cdesc = mtk_ring_next_wptr(mtk, &mtk->ring->cdr);
+
+	if (IS_ERR(cdesc)) {
+		spin_unlock_irqrestore(&mtk->ring->write_lock, irqflags);
+		return -ENOENT;
+	}
+
+	memset(rdesc, 0, sizeof(struct eip93_descriptor_s));
+
+	memcpy(cdesc, desc, sizeof(struct eip93_descriptor_s));
+
+	atomic_dec(&mtk->ring->free);
+	spin_unlock_irqrestore(&mtk->ring->write_lock, irqflags);
+
+	return 0;
+}
+
+inline void *mtk_get_descriptor(struct mtk_device *mtk)
+{
+	struct eip93_descriptor_s *cdesc;
+	void *ptr;
+	unsigned long irqflags;
+
+	spin_lock_irqsave(&mtk->ring->read_lock, irqflags);
+
+	cdesc = mtk_ring_next_rptr(mtk, &mtk->ring->cdr);
+
+	if (IS_ERR(cdesc)) {
+		spin_unlock_irqrestore(&mtk->ring->read_lock, irqflags);
+		return ERR_PTR(-ENOENT);
+	}
+
+	memset(cdesc, 0, sizeof(struct eip93_descriptor_s));
+
+	ptr = mtk_ring_next_rptr(mtk, &mtk->ring->rdr);
+	if (IS_ERR(ptr)) {
+		spin_unlock_irqrestore(&mtk->ring->read_lock, irqflags);
+		return ERR_PTR(-ENOENT);
+	}
+
+	atomic_inc(&mtk->ring->free);
+	spin_unlock_irqrestore(&mtk->ring->read_lock, irqflags);
+	return ptr;
+}
+
+inline int mtk_get_free_saState(struct mtk_device *mtk)
+{
+	struct mtk_state_pool *saState_pool;
+	int i;
+
+	for (i = 0; i < MTK_RING_SIZE; i++) {
+		saState_pool = &mtk->ring->saState_pool[i];
+		if (saState_pool->in_use == false) {
+			saState_pool->in_use = true;
+			return i;
+		}
+
+	}
+
+	return -ENOENT;
+}
+
+static inline void mtk_free_sg_copy(const int len, struct scatterlist **sg)
+{
+	if (!*sg || !len)
+		return;
+
+	free_pages((unsigned long)sg_virt(*sg), get_order(len));
+	kfree(*sg);
+	*sg = NULL;
+}
+
+static inline int mtk_make_sg_copy(struct scatterlist *src,
+			struct scatterlist **dst,
+			const uint32_t len, const bool copy)
+{
+	void *pages;
+
+	*dst = kmalloc(sizeof(**dst), GFP_KERNEL);
+	if (!*dst)
+		return -ENOMEM;
+
+	pages = (void *)__get_free_pages(GFP_KERNEL | GFP_DMA,
+					get_order(len));
+
+	if (!pages) {
+		kfree(*dst);
+		*dst = NULL;
+		return -ENOMEM;
+	}
+
+	sg_init_table(*dst, 1);
+	sg_set_buf(*dst, pages, len);
+
+	/* copy only as requested */
+	if (copy)
+		sg_copy_to_buffer(src, sg_nents(src), pages, len);
+
+	return 0;
+}
+
+static inline bool mtk_is_sg_aligned(struct scatterlist *sg, u32 len,
+						const int blksize)
+{
+	int nents;
+
+	for (nents = 0; sg; sg = sg_next(sg), ++nents) {
+		if (!IS_ALIGNED(sg->offset, 4))
+			return false;
+
+		if (len <= sg->length) {
+			if (!IS_ALIGNED(len, blksize))
+				return false;
+
+			return true;
+		}
+
+		if (!IS_ALIGNED(sg->length, blksize))
+			return false;
+
+		len -= sg->length;
+	}
+	return false;
+}
+
+int check_valid_request(struct mtk_cipher_reqctx *rctx)
+{
+	struct scatterlist *src = rctx->sg_src;
+	struct scatterlist *dst = rctx->sg_dst;
+	uint32_t src_nents, dst_nents;
+	u32 textsize = rctx->textsize;
+	u32 authsize = rctx->authsize;
+	u32 blksize = rctx->blksize;
+	u32 totlen_src = rctx->assoclen + rctx->textsize;
+	u32 totlen_dst = rctx->assoclen + rctx->textsize;
+	u32 copy_len;
+	bool src_align, dst_align;
+	int err = -EINVAL;
+
+	if (!IS_CTR(rctx->flags)) {
+		if (!IS_ALIGNED(textsize, blksize))
+			return err;
+	}
+
+	if (authsize) {
+		if (IS_ENCRYPT(rctx->flags))
+			totlen_dst += authsize;
+		else
+			totlen_src += authsize;
+	}
+
+	src_nents = sg_nents_for_len(src, totlen_src);
+	dst_nents = sg_nents_for_len(dst, totlen_dst);
+
+	if (src == dst) {
+		src_nents = max(src_nents, dst_nents);
+		dst_nents = src_nents;
+		if (unlikely((totlen_src || totlen_dst) && (src_nents <= 0)))
+			return err;
+
+	} else {
+		if (unlikely(totlen_src && (src_nents <= 0)))
+			return err;
+
+		if (unlikely(totlen_dst && (dst_nents <= 0)))
+			return err;
+	}
+
+	if (authsize) {
+		if (dst_nents == 1 && src_nents == 1) {
+			src_align = mtk_is_sg_aligned(src, totlen_src, blksize);
+			if (src ==  dst)
+				dst_align = src_align;
+			else
+				dst_align = mtk_is_sg_aligned(dst,
+						totlen_dst, blksize);
+		} else {
+			src_align = false;
+			dst_align = false;
+		}
+	} else {
+		src_align = mtk_is_sg_aligned(src, totlen_src, blksize);
+		if (src == dst)
+			dst_align = src_align;
+		else
+			dst_align = mtk_is_sg_aligned(dst, totlen_dst, blksize);
+	}
+
+	copy_len = max(totlen_src, totlen_dst);
+	if (!src_align) {
+		err = mtk_make_sg_copy(src, &rctx->sg_src, copy_len, true);
+		if (err)
+			return err;
+	}
+
+	if (!dst_align) {
+		err = mtk_make_sg_copy(dst, &rctx->sg_dst, copy_len, false);
+		if (err)
+			return err;
+	}
+
+	rctx->src_nents = sg_nents_for_len(rctx->sg_src, totlen_src);
+	rctx->dst_nents = sg_nents_for_len(rctx->sg_dst, totlen_dst);
+
+	return 0;
+}
+/*
+ * Set saRecord function:
+ * Even saRecord is set to "0", keep " = 0" for readability.
+ */
+void mtk_set_saRecord(struct saRecord_s *saRecord, const unsigned int keylen,
+				const unsigned long flags)
+{
+	saRecord->saCmd0.bits.ivSource = 2;
+	if (IS_ECB(flags))
+		saRecord->saCmd0.bits.saveIv = 0;
+	else
+		saRecord->saCmd0.bits.saveIv = 1;
+
+	saRecord->saCmd0.bits.opGroup = 0;
+	saRecord->saCmd0.bits.opCode = 0;
+
+	switch ((flags & MTK_ALG_MASK)) {
+	case MTK_ALG_AES:
+		saRecord->saCmd0.bits.cipher = 3;
+		saRecord->saCmd1.bits.aesKeyLen = keylen >> 3;
+		break;
+	case MTK_ALG_3DES:
+		saRecord->saCmd0.bits.cipher = 1;
+		break;
+	case MTK_ALG_DES:
+		saRecord->saCmd0.bits.cipher = 0;
+		break;
+	default:
+		saRecord->saCmd0.bits.cipher = 15;
+	}
+
+	switch ((flags & MTK_HASH_MASK)) {
+	case MTK_HASH_SHA256:
+		saRecord->saCmd0.bits.hash = 3;
+		break;
+	case MTK_HASH_SHA224:
+		saRecord->saCmd0.bits.hash = 2;
+		break;
+	case MTK_HASH_SHA1:
+		saRecord->saCmd0.bits.hash = 1;
+		break;
+	case MTK_HASH_MD5:
+		saRecord->saCmd0.bits.hash = 0;
+		break;
+	default:
+		saRecord->saCmd0.bits.hash = 15;
+	}
+
+	saRecord->saCmd0.bits.hdrProc = 0;
+	saRecord->saCmd0.bits.padType = 3;
+	saRecord->saCmd0.bits.extPad = 0;
+	saRecord->saCmd0.bits.scPad = 0;
+
+	switch ((flags & MTK_MODE_MASK)) {
+	case MTK_MODE_CBC:
+		saRecord->saCmd1.bits.cipherMode = 1;
+		break;
+	case MTK_MODE_CTR:
+		saRecord->saCmd1.bits.cipherMode = 2;
+		break;
+	case MTK_MODE_ECB:
+		saRecord->saCmd1.bits.cipherMode = 0;
+		break;
+	}
+
+	saRecord->saCmd1.bits.byteOffset = 0;
+	saRecord->saCmd1.bits.hashCryptOffset = 0;
+	saRecord->saCmd0.bits.digestLength = 0;
+	saRecord->saCmd1.bits.copyPayload = 0;
+
+	if (IS_HMAC(flags)) {
+		saRecord->saCmd1.bits.hmac = 1;
+		saRecord->saCmd1.bits.copyDigest = 1;
+		saRecord->saCmd1.bits.copyHeader = 1;
+	} else {
+		saRecord->saCmd1.bits.hmac = 0;
+		saRecord->saCmd1.bits.copyDigest = 0;
+		saRecord->saCmd1.bits.copyHeader = 0;
+	}
+
+	/* Default for now, might be used for ESP offload */
+	saRecord->saCmd1.bits.seqNumCheck = 0;
+	saRecord->saSpi = 0x0;
+	saRecord->saSeqNumMask[0] = 0xFFFFFFFF;
+	saRecord->saSeqNumMask[1] = 0x0;
+}
+EXPORT_SYMBOL_GPL(mtk_set_saRecord);
+/*
+ * Poor mans Scatter/gather function:
+ * Create a Descriptor for every segment to avoid copying buffers.
+ * For performance better to wait for hardware to perform multiple DMA
+ *
+ */
+static inline int mtk_scatter_combine(struct mtk_device *mtk,
+			struct mtk_cipher_reqctx *rctx,
+			u32 datalen, u32 split, int offsetin)
+{
+	struct eip93_descriptor_s *cdesc = rctx->cdesc;
+	struct scatterlist *sgsrc = rctx->sg_src;
+	struct scatterlist *sgdst = rctx->sg_dst;
+	unsigned int remainin = sg_dma_len(sgsrc);
+	unsigned int remainout = sg_dma_len(sgdst);
+	dma_addr_t saddr = sg_dma_address(sgsrc);
+	dma_addr_t daddr = sg_dma_address(sgdst);
+	dma_addr_t stateAddr;
+	u32 srcAddr, dstAddr, len, n;
+	bool nextin = false;
+	bool nextout = false;
+	int offsetout = 0;
+	int ndesc_cdr = 0, err;
+
+	if (IS_ECB(rctx->flags))
+		rctx->saState_base = 0;
+
+	if (split < datalen) {
+		stateAddr = rctx->saState_base_ctr;
+		n = split;
+	} else {
+		stateAddr = rctx->saState_base;
+		n = datalen;
+	}
+
+	do {
+		if (nextin) {
+			sgsrc = sg_next(sgsrc);
+			remainin = sg_dma_len(sgsrc);
+			if (remainin == 0)
+				continue;
+
+			saddr = sg_dma_address(sgsrc);
+			offsetin = 0;
+			nextin = false;
+		}
+
+		if (nextout) {
+			sgdst = sg_next(sgdst);
+			remainout = sg_dma_len(sgdst);
+			if (remainout == 0)
+				continue;
+
+			daddr = sg_dma_address(sgdst);
+			offsetout = 0;
+			nextout = false;
+		}
+		srcAddr = saddr + offsetin;
+		dstAddr = daddr + offsetout;
+
+		if (remainin == remainout) {
+			len = remainin;
+			if (len > n) {
+				len = n;
+				remainin -= n;
+				remainout -= n;
+				offsetin += n;
+				offsetout += n;
+			} else {
+				nextin = true;
+				nextout = true;
+			}
+		} else if (remainin < remainout) {
+			len = remainin;
+			if (len > n) {
+				len = n;
+				remainin -= n;
+				remainout -= n;
+				offsetin += n;
+				offsetout += n;
+			} else {
+				offsetout += len;
+				remainout -= len;
+				nextin = true;
+			}
+		} else {
+			len = remainout;
+			if (len > n) {
+				len = n;
+				remainin -= n;
+				remainout -= n;
+				offsetin += n;
+				offsetout += n;
+			} else {
+				offsetin += len;
+				remainin -= len;
+				nextout = true;
+			}
+		}
+		n -= len;
+
+		cdesc->srcAddr = srcAddr;
+		cdesc->dstAddr = dstAddr;
+		cdesc->stateAddr = stateAddr;
+		cdesc->peLength.bits.peReady = 0;
+		cdesc->peLength.bits.byPass = 0;
+		cdesc->peLength.bits.length = len;
+		cdesc->peLength.bits.hostReady = 1;
+
+		if (n == 0) {
+			n = datalen - split;
+			split = datalen;
+			stateAddr = rctx->saState_base;
+		}
+
+		if (n == 0)
+			cdesc->userId |= MTK_DESC_LAST | MTK_DESC_FINISH;
+
+		/* Loop - Delay - No need to rollback
+		 * Maybe refine by slowing down at MTK_RING_BUSY
+		 */
+again:
+		err = mtk_put_descriptor(mtk, cdesc);
+		if (err) {
+			udelay(500);
+			goto again;
+		}
+		/* Writing new descriptor count starts DMA action */
+		writel(1, mtk->base + EIP93_REG_PE_CD_COUNT);
+
+		ndesc_cdr++;
+	} while (n);
+
+	return -EINPROGRESS;
+}
+
+int mtk_send_req(struct crypto_async_request *async,
+			const u8 *reqiv, struct mtk_cipher_reqctx *rctx)
+{
+	struct mtk_crypto_ctx *ctx = crypto_tfm_ctx(async->tfm);
+	struct mtk_device *mtk = ctx->mtk;
+	struct scatterlist *src = rctx->sg_src;
+	struct scatterlist *dst = rctx->sg_dst;
+	struct saState_s *saState;
+	struct mtk_state_pool *saState_pool;
+	struct eip93_descriptor_s cdesc;
+	unsigned long flags = rctx->flags;
+	int idx;
+	int offsetin = 0, err = -ENOMEM;
+	u32 datalen = rctx->assoclen + rctx->textsize;
+	u32 split = datalen;
+	u32 start, end, ctr, blocks;
+	u32 iv[AES_BLOCK_SIZE / sizeof(u32)];
+
+	rctx->saState_ctr = NULL;
+	rctx->saState = NULL;
+
+	if (IS_ECB(flags))
+		goto skip_iv;
+
+	memcpy(iv, reqiv, rctx->ivsize);
+
+	if (!IS_ALIGNED((u32)reqiv, rctx->ivsize) || IS_RFC3686(flags)) {
+		rctx->flags &= ~MTK_DESC_DMA_IV;
+		flags = rctx->flags;
+	}
+
+	if (IS_DMA_IV(flags)) {
+		rctx->saState = (void *)reqiv;
+	} else  {
+		idx = mtk_get_free_saState(mtk);
+		if (idx < 0)
+			goto send_err;
+		saState_pool = &mtk->ring->saState_pool[idx];
+		rctx->saState_idx = idx;
+		rctx->saState = saState_pool->base;
+		rctx->saState_base = saState_pool->base_dma;
+		memcpy(rctx->saState->stateIv, iv, rctx->ivsize);
+	}
+
+	saState = rctx->saState;
+
+	if (IS_RFC3686(flags)) {
+		saState->stateIv[0] = ctx->saNonce;
+		saState->stateIv[1] = iv[0];
+		saState->stateIv[2] = iv[1];
+		saState->stateIv[3] = htonl(1);
+	} else if (!IS_HMAC(flags) && IS_CTR(flags)) {
+		/* Compute data length. */
+		blocks = DIV_ROUND_UP(rctx->textsize, AES_BLOCK_SIZE);
+		ctr = ntohl(iv[3]);
+		/* Check 32bit counter overflow. */
+		start = ctr;
+		end = start + blocks - 1;
+		if (end < start) {
+			split = AES_BLOCK_SIZE * -start;
+			/*
+			 * Increment the counter manually to cope with
+			 * the hardware counter overflow.
+			 */
+			iv[3] = 0xffffffff;
+			crypto_inc((u8 *)iv, AES_BLOCK_SIZE);
+			idx = mtk_get_free_saState(mtk);
+			if (idx < 0)
+				goto free_state;
+			saState_pool = &mtk->ring->saState_pool[idx];
+			rctx->saState_ctr_idx = idx;
+			rctx->saState_ctr = saState_pool->base;
+			rctx->saState_base_ctr = saState_pool->base_dma;
+
+			memcpy(rctx->saState_ctr->stateIv, reqiv, rctx->ivsize);
+			memcpy(saState->stateIv, iv, rctx->ivsize);
+		}
+	}
+
+	if (IS_DMA_IV(flags)) {
+		rctx->saState_base = dma_map_single(mtk->dev, (void *)reqiv,
+						rctx->ivsize, DMA_TO_DEVICE);
+		if (dma_mapping_error(mtk->dev, rctx->saState_base))
+			goto free_state;
+	}
+skip_iv:
+	cdesc.peCrtlStat.bits.hostReady = 1;
+	cdesc.peCrtlStat.bits.prngMode = 0;
+	cdesc.peCrtlStat.bits.hashFinal = 0;
+	cdesc.peCrtlStat.bits.padCrtlStat = 0;
+	cdesc.peCrtlStat.bits.peReady = 0;
+	cdesc.saAddr = rctx->saRecord_base;
+	cdesc.arc4Addr = (uintptr_t)async;
+	cdesc.userId = (flags & (MTK_DESC_AEAD | MTK_DESC_SKCIPHER));
+	rctx->cdesc = &cdesc;
+
+	/* map DMA_BIDIRECTIONAL to invalidate cache on destination
+	 * implies __dma_cache_wback_inv
+	 */
+	dma_map_sg(mtk->dev, dst, rctx->dst_nents, DMA_BIDIRECTIONAL);
+	if (src != dst)
+		dma_map_sg(mtk->dev, src, rctx->src_nents, DMA_TO_DEVICE);
+
+	err = mtk_scatter_combine(mtk, rctx, datalen, split, offsetin);
+
+	return err;
+
+free_state:
+	if (rctx->saState) {
+		saState_pool = &mtk->ring->saState_pool[rctx->saState_idx];
+		saState_pool->in_use = false;
+	}
+
+	if (rctx->saState_ctr) {
+		saState_pool = &mtk->ring->saState_pool[rctx->saState_ctr_idx];
+		saState_pool->in_use = false;
+	}
+send_err:
+	return err;
+}
+
+void mtk_unmap_dma(struct mtk_device *mtk, struct mtk_cipher_reqctx *rctx,
+			struct scatterlist *reqsrc, struct scatterlist *reqdst)
+{
+	u32 len = rctx->assoclen + rctx->textsize;
+	u32 authsize = rctx->authsize;
+	u32 flags = rctx->flags;
+	u32 *otag;
+	int i;
+
+	if (rctx->sg_src == rctx->sg_dst) {
+		dma_unmap_sg(mtk->dev, rctx->sg_dst, rctx->dst_nents,
+							DMA_BIDIRECTIONAL);
+		goto process_tag;
+	}
+
+	dma_unmap_sg(mtk->dev, rctx->sg_src, rctx->src_nents,
+							DMA_TO_DEVICE);
+
+	if (rctx->sg_src != reqsrc)
+		mtk_free_sg_copy(len +  rctx->authsize, &rctx->sg_src);
+
+	dma_unmap_sg(mtk->dev, rctx->sg_dst, rctx->dst_nents,
+							DMA_BIDIRECTIONAL);
+
+	/* SHA tags need conversion from net-to-host */
+process_tag:
+	if (IS_DECRYPT(flags))
+		authsize = 0;
+
+	if (authsize) {
+		if (!IS_HASH_MD5(flags)) {
+			otag = sg_virt(rctx->sg_dst) + len;
+			for (i = 0; i < (authsize / 4); i++)
+				otag[i] = ntohl(otag[i]);
+		}
+	}
+
+	if (rctx->sg_dst != reqdst) {
+		sg_copy_from_buffer(reqdst, sg_nents(reqdst),
+				sg_virt(rctx->sg_dst), len + authsize);
+		mtk_free_sg_copy(len + rctx->authsize, &rctx->sg_dst);
+	}
+}
+
+void mtk_handle_result(struct mtk_device *mtk, struct mtk_cipher_reqctx *rctx,
+			u8 *reqiv)
+{
+	struct mtk_state_pool *saState_pool;
+
+	if (IS_DMA_IV(rctx->flags))
+		dma_unmap_single(mtk->dev, rctx->saState_base, rctx->ivsize,
+						DMA_TO_DEVICE);
+
+	if (!IS_ECB(rctx->flags))
+		memcpy(reqiv, rctx->saState->stateIv, rctx->ivsize);
+
+	if ((rctx->saState) && !(IS_DMA_IV(rctx->flags))) {
+		saState_pool = &mtk->ring->saState_pool[rctx->saState_idx];
+		saState_pool->in_use = false;
+	}
+
+	if (rctx->saState_ctr) {
+		saState_pool = &mtk->ring->saState_pool[rctx->saState_ctr_idx];
+		saState_pool->in_use = false;
+	}
+}
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HMAC)
+/* basically this is set hmac - key */
+int mtk_authenc_setkey(struct crypto_shash *cshash, struct saRecord_s *sa,
+			const u8 *authkey, unsigned int authkeylen)
+{
+	int bs = crypto_shash_blocksize(cshash);
+	int ds = crypto_shash_digestsize(cshash);
+	int ss = crypto_shash_statesize(cshash);
+	u8 *ipad, *opad;
+	unsigned int i, err;
+
+	SHASH_DESC_ON_STACK(shash, cshash);
+
+	shash->tfm = cshash;
+
+	/* auth key
+	 *
+	 * EIP93 can only authenticate with hash of the key
+	 * do software shash until EIP93 hash function complete.
+	 */
+	ipad = kcalloc(2, SHA256_BLOCK_SIZE + ss, GFP_KERNEL);
+	if (!ipad)
+		return -ENOMEM;
+
+	opad = ipad + SHA256_BLOCK_SIZE + ss;
+
+	if (authkeylen > bs) {
+		err = crypto_shash_digest(shash, authkey,
+					authkeylen, ipad);
+		if (err)
+			return err;
+
+		authkeylen = ds;
+	} else
+		memcpy(ipad, authkey, authkeylen);
+
+	memset(ipad + authkeylen, 0, bs - authkeylen);
+	memcpy(opad, ipad, bs);
+
+	for (i = 0; i < bs; i++) {
+		ipad[i] ^= HMAC_IPAD_VALUE;
+		opad[i] ^= HMAC_OPAD_VALUE;
+	}
+
+	err = crypto_shash_init(shash) ?:
+				 crypto_shash_update(shash, ipad, bs) ?:
+				 crypto_shash_export(shash, ipad) ?:
+				 crypto_shash_init(shash) ?:
+				 crypto_shash_update(shash, opad, bs) ?:
+				 crypto_shash_export(shash, opad);
+
+	if (err)
+		return err;
+
+	/* add auth key */
+	memcpy(&sa->saIDigest, ipad, SHA256_DIGEST_SIZE);
+	memcpy(&sa->saODigest, opad, SHA256_DIGEST_SIZE);
+
+	kfree(ipad);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mtk_authenc_setkey);
+#endif
diff --git a/package/kernel/mtk-eip93/src/eip93-common.h b/package/kernel/mtk-eip93/src/eip93-common.h
new file mode 100644
index 0000000..e57f75c
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-common.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#ifndef _EIP93_COMMON_H_
+#define _EIP93_COMMON_H_
+
+#include "eip93-cipher.h"
+
+inline void *mtk_ring_next_wptr(struct mtk_device *mtk,
+						struct mtk_desc_ring *ring);
+
+inline void *mtk_ring_next_rptr(struct mtk_device *mtk,
+						struct mtk_desc_ring *ring);
+
+inline int mtk_put_descriptor(struct mtk_device *mtk,
+					struct eip93_descriptor_s *desc);
+
+inline void *mtk_get_descriptor(struct mtk_device *mtk);
+
+inline int mtk_get_free_saState(struct mtk_device *mtk);
+
+void mtk_set_saRecord(struct saRecord_s *saRecord, const unsigned int keylen,
+				const unsigned long flags);
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HMAC)
+int mtk_authenc_setkey(struct crypto_shash *cshash, struct saRecord_s *sa,
+			const u8 *authkey, unsigned int authkeylen);
+#endif
+
+#endif /* _EIP93_COMMON_H_ */
diff --git a/package/kernel/mtk-eip93/src/eip93-des.h b/package/kernel/mtk-eip93/src/eip93-des.h
new file mode 100644
index 0000000..9af79f2
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-des.h
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+#ifndef _EIP93_DES_H_
+#define _EIP93_DES_H_
+
+extern struct mtk_alg_template mtk_alg_ecb_des;
+extern struct mtk_alg_template mtk_alg_cbc_des;
+extern struct mtk_alg_template mtk_alg_ecb_des3_ede;
+extern struct mtk_alg_template mtk_alg_cbc_des3_ede;
+
+#endif /* _EIP93_DES_H_ */
diff --git a/package/kernel/mtk-eip93/src/eip93-hash.c b/package/kernel/mtk-eip93/src/eip93-hash.c
new file mode 100644
index 0000000..f6d85bc
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-hash.c
@@ -0,0 +1,659 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#include <linux/device.h>
+#include <linux/dmapool.h>
+#include <linux/interrupt.h>
+#include <crypto/internal/hash.h>
+
+#include "eip93-main.h"
+#include "eip93-regs.h"
+#include "eip93-common.h"
+#include "eip93-hash.h"
+
+int mtk_ahash_handle_result(struct mtk_device *mtk,
+				  struct crypto_async_request *async,
+				  int err)
+{
+	struct ahash_request *areq = ahash_request_cast(async);
+	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	int cache_len;
+
+
+	if (rctx->nents) {
+		dma_unmap_sg(mtk->dev, areq->src, rctx->nents, DMA_TO_DEVICE);
+		rctx->nents = 0;
+	}
+
+	if (rctx->result_dma) {
+		dma_unmap_sg(mtk->dev, areq->src, rctx->nents, DMA_FROM_DEVICE);
+		rctx->result_dma = 0;
+	}
+
+
+	// done by hardware
+//	if (sreq->finish) {
+//		memcpy(areq->result, rctx-sreq->state,
+//				crypto_ahash_digestsize(ahash));
+//	}
+
+	cache_len = rctx->len - rctx->processed;
+	if (cache_len)
+		memcpy(rctx->cache, rctx->cache_next, cache_len);
+
+	if (complete)
+		async->complete(async, err);
+
+	return 0;
+}
+
+int mtk_ahash_send_req(struct mtk_device *mtk,
+			struct crypto_async_request *async)
+{
+	struct ahash_request *areq = ahash_request_cast(async);
+	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	struct mtk_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+	struct eip93_descriptor *cdesc, *first_cdesc = NULL;
+	struct scatterlist *sg;
+	bool last = (rctx->flags & MTK_DESC_LAST);
+	bool finish = (rctx->flags & MTK_DESC_FINISH);
+	int i, queued, len, cache_len, extra, n_cdesc = 0, ret = 0;
+
+	queued = len = rctx->len - rctx->processed;
+	if (queued <= SHA256_BLOCK_SIZE)
+		cache_len = queued;
+	else
+		cache_len = queued - areq->nbytes;
+
+	if (!finish && !last) {
+		/* If this is not the last request and the queued data does not
+		 * fit into full cache blocks, cache it for the next send call.
+		 */
+		extra = queued & (SHA256_BLOCK_SIZE - 1);
+
+		/* If this is not the last request and the queued data
+		 * is a multiple of a block, cache the last one for now.
+		 */
+		if (!extra)
+			extra = SHA256_BLOCK_SIZE;
+
+		sg_pcopy_to_buffer(areq->src, sg_nents(areq->src),
+				   req->cache_next, extra,
+				   areq->nbytes - extra);
+		queued -= extra;
+		len -= extra;
+
+		if (!queued) {
+			return 0;
+		}
+	}
+
+	/* Add a command descriptor for the cached data, if any */
+	if (cache_len) {
+		rctx->cache_dma = dma_map_single(mtk->dev, rctx->cache,
+						cache_len, DMA_TO_DEVICE);
+		if (dma_mapping_error(mtk->dev, rctx->cache_dma))
+			return -EINVAL;
+
+		rctx->cache_sz = cache_len;
+		first_cdesc = safexcel_add_cdesc(priv, ring, 1,
+						 (cache_len == len),
+						 req->cache_dma, cache_len, len,
+						 ctx->base.ctxr_dma);
+		if (IS_ERR(first_cdesc)) {
+			ret = PTR_ERR(first_cdesc);
+			goto unmap_cache;
+		}
+		n_cdesc++;
+
+		queued -= cache_len;
+		if (!queued)
+			goto send_command;
+	}
+
+		/* Skip descriptor generation for zero-length requests */
+		if (!areq->nbytes)
+			goto send_command;
+
+	/* Now handle the current ahash request buffer(s) */
+	req->nents = dma_map_sg(mtk->dev, areq->src,
+				sg_nents_for_len(areq->src, areq->nbytes),
+				DMA_TO_DEVICE);
+	if (!req->nents) {
+		ret = -ENOMEM;
+		goto cdesc_rollback;
+	}
+
+	for_each_sg(areq->src, sg, req->nents, i) {
+		int sglen = sg_dma_len(sg);
+
+		/* Do not overflow the request */
+		if (queued - sglen < 0)
+			sglen = queued;
+
+		cdesc = mtk_add_cdesc(mtk, sg_dma_address(sg), Result.base,
+						saRecord.base, saState.base, sglen, 0);
+		if (IS_ERR(cdesc)) {
+			ret = PTR_ERR(cdesc);
+			goto cdesc_rollback;
+		}
+		rdesc = mtk_add_rdesc(mtk);
+
+		n_cdesc++;
+
+		if (n_cdesc == 1)
+			first_cdesc = cdesc;
+
+		queued -= sglen;
+		if (!queued)
+			break;
+	}
+
+send_command:
+	req->processed += len;
+	request->req = &areq->base;
+
+	return 0;
+
+unmap_result:
+
+unmap_sg:
+
+cdesc_rollback:
+	for (i = 0; i < n_cdesc; i++)
+		mtk_ring_rollback_wptr(priv, &priv->ring[ring].cdr);
+unmap_cache:
+	if (req->bcache_dma) {
+		dma_unmap_single(priv->dev, ctx->base.cache_dma,
+				 ctx->base.cache_sz, DMA_TO_DEVICE);
+		req->cache_sz = 0;
+	}
+
+	return ret;
+}
+
+static int mtk_ahash_enqueue(struct ahash_request *areq)
+{
+	struct mtk_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+	struct mtk_ahash_reqctx *req = ahash_request_ctx(areq);
+	struct mtk_device *mtk = ctx->mtk;
+	int ret;
+
+	spin_lock(&mtk->ring->queue_lock);
+	ret = crypto_enqueue_request(&mtk->ring->queue, base);
+	spin_unlock(&mtk->ring->queue_lock);
+
+	queue_work(mtk->ring->dequeue, &mtk->ring->dequeue_data.work);
+
+	return ret;
+}
+
+static int mtk_ahash_cache(struct ahash_request *areq)
+{
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+	int queued, cache_len;
+
+	cache_len = rctx->len - areq->nbytes - rctx->processed;
+	queued = rctx->len - rctx->processed;
+
+	/*
+	 * In case there isn't enough bytes to proceed (less than a
+	 * block size), cache the data until we have enough.
+	 */
+	if (cache_len + areq->nbytes <= crypto_ahash_blocksize(ahash)) {
+		sg_pcopy_to_buffer(areq->src, sg_nents(areq->src),
+				   req->cache + cache_len,
+				   areq->nbytes, 0);
+		return areq->nbytes;
+	}
+
+	/* We could'nt cache all the data */
+	return -E2BIG;
+}
+
+static int mtk_ahash_update(struct ahash_request *areq)
+{
+	struct mtk_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+	struct saRecord_s *saRecord = ctx->sa_in;
+	bool last = (rctx->flags & MTK_DESC_LAST);
+	bool finish = (rctx->flags & MTK_DESC_FINISH);
+	int ret;
+
+	/* If the request is 0 length, do nothing */
+	if (!areq->nbytes)
+		return 0;
+
+	/* Add request to the cache if it fits */
+	ret = mtk_ahash_cache(areq);
+
+	/* Update total request length */
+	rctx->len += areq->nbytes;
+
+	/* If not all data could fit into the cache, go process the excess.
+	 * Also go process immediately for an HMAC IV precompute, which
+	 * will never be finished at all, but needs to be processed anyway.
+	 */
+	if ((ret && !finish) || last)
+		return mtk_ahash_enqueue(areq);
+
+	return 0;
+}
+
+static int mtk_ahash_final(struct ahash_request *areq)
+{
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	struct mtk_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+
+	rctx->flags |= (MTK_DESC_LAST | MTK_DESC_FINISH);
+
+	/* If we have an overall 0 length request */
+	if (!(rctx->len + areq->nbytes)) {
+		if (IS_HASH_SHA1(req->flags))
+			memcpy(areq->result, sha1_zero_message_hash,
+				SHA1_DIGEST_SIZE);
+		else if (IS_HASH_SHA224(req->flags))
+			memcpy(areq->result, sha224_zero_message_hash,
+				SHA224_DIGEST_SIZE);
+		else if (IS_HASH_SHA256(req->flags))
+			memcpy(areq->result, sha256_zero_message_hash,
+				SHA256_DIGEST_SIZE);
+		else if (IS_HASH_MD5(req->flags))
+       			memcpy(areq->result, md5_zero_message_hash,
+				MD5_DIGEST_SIZE);
+		return 0;
+	}
+
+	return mtk_ahash_enqueue(areq);
+}
+
+static int mtk_ahash_finup(struct ahash_request *areq)
+{
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+
+	rctx->flags |= (MTK_DESC_LAST | MTK_DESC_FINISH);
+
+	mtk_ahash_update(areq);
+
+	return mtk_ahash_final(areq);
+}
+
+static int mtk_ahash_export(struct ahash_request *areq, void *out)
+{
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	struct mtk_ahash_export_state *export = out;
+	struct saRecord_s *saRecord = rctx->saRecord;
+
+	export->len = rctx->len;
+	export->processed = rctx->processed;
+	export->flags = rctx->flags;
+	export->stateByteCnt[0] = saRecord->stateByteCnt[0];
+	export->stateByteCnt[1] = saRecord->stateByteCnt[1];
+	memcpy(export->saIDigest, saRecord->saIDigest, SHA256_DIGEST_SIZE);
+	memcpy(export->cache, req->cache, SHA256_BLOCK_SIZE);
+
+	return 0;
+}
+
+static int mtk_ahash_import(struct ahash_request *areq, const void *in)
+{
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	const struct mtk_ahash_export_state *export = in;
+	struct saRecord_s *saRecord = rctx->saRecord;
+	int ret;
+
+	ret = crypto_ahash_init(areq);
+	if (ret)
+		return ret;
+
+	rctx->len = export->len;
+	rctx->processed = export->processed;
+	rctx->flags = export->flags;
+	saRecord->stateByteCnt[0] = export->stateByteCnt[0];
+	saRecord->stateByteCnt[1] = export->stateByteCnt[1];
+	memcpy(saRecord->saIDigest, export->saIDigest, SHA256_DIGEST_SIZE);
+	memcpy(req->cache, export->cache, SHA256_BLOCK_SIZE);
+
+	return 0;
+}
+
+static int mtk_hmac_setkey(struct crypto_ahash *ctfm, const u8 *key,
+			  u32 keylen)
+{
+	struct crypto_tfm *tfm = crypto_ahash_tfm(ctfm);
+	struct mtk_ahash_ctx *ctx = crypto_ahash_ctx(ctfm);
+	struct saRecord_s *saRecord = ctx->sa_in;
+	int err;
+
+	/* authentication key */
+	err = mtk_authenc_setkey(ctx->shash, saRecord, key, keylen);
+
+	saRecord->saCmd0.bits.direction = 1;
+	saRecord->saCmd1.bits.copyHeader = 0;
+	saRecord->saCmd1.bits.copyDigest = 0;
+
+	return err;
+}
+
+static int mtk_ahash_cra_init(struct crypto_tfm *tfm)
+{
+	struct mtk_ahash_ctx *ctx = crypto_tfm_ctx(tfm);
+	struct mtk_alg_template *tmpl = container_of(tfm->__crt_alg,
+				struct mtk_alg_template, alg.ahash.halg.base);
+	struct mtk_device *mtk = tmpl->mtk;
+	u32 flags = tmpl->flags;
+	char *alg_base;
+
+	crypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),
+				 sizeof(struct mtk_ahash_reqctx));
+
+	ctx->mtk = tmpl->mtk;
+
+	ctx->sa_in = kzalloc(sizeof(struct saRecord_s), GFP_KERNEL);
+	if (!ctx->sa_in)
+		return -ENOMEM;
+
+	ctx->sa_base_in = NULL;
+
+	/* for HMAC need software fallback */
+	if (IS_HASH_MD5(flags)) {
+		alg_base = "md5";
+		ctx->init_state = { SHA1_H3, SHA1_H2, SHA1_H1, SHA1_H0 };
+	}
+	if (IS_HASH_SHA1(flags)) {
+		alg_base = "sha1";
+		ctx->init_state = { SHA1_H4, SHA1_H3, SHA1_H2, SHA1_H1,
+				SHA1_H0 };
+	}
+	if (IS_HASH_SHA224(flags)) {
+		alg_base = "sha224";
+		ctx->init_state = { SHA224_H7, SHA224_H6, SHA224_H5, SHA224_H4,
+				SHA224_H3, SHA224_H2, SHA224_H1, SHA224_H0 };
+	}
+	if (IS_HASH_SHA256(flags)) {
+		alg_base = "sha256";
+		ctx->init_state = { SHA256_H7, SHA256_H6, SHA256_H5, SHA256_H4,
+				SHA256_H3, SHA256_H2, SHA256_H1, SHA256_H0 };
+	}
+
+	if (IS_HMAC(flags)) {
+		ctx->shash = crypto_alloc_shash(alg_base, 0,
+			CRYPTO_ALG_NEED_FALLBACK);
+
+		if (IS_ERR(ctx->shash)) {
+			dev_err(ctx->mtk->dev, "base driver %s not loaded.\n",
+				alg_base);
+				return PTR_ERR(ctx->shash);
+		}
+	}
+
+	return 0;
+}
+
+static int mtk_ahash_init(struct ahash_request *areq)
+{
+	struct mtk_ahash_ctx *ctx = crypto_ahash_ctx(crypto_ahash_reqtfm(areq));
+	struct mtk_ahash_reqctx *rctx = ahash_request_ctx(areq);
+	struct mtk_alg_template *tmpl = container_of(tfm->__crt_alg,
+				struct mtk_alg_template, alg.ahash.halg.base);
+	struct crypto_ahash *ahash = crypto_ahash_reqtfm(areq);
+	struct saRecord_s *saRecord = ctx->sa_in;
+	struct saState_s *saState;
+	struct mtk_state_pool *saState_pool;
+	u32 flags = tmpl->flags;
+	int idx;
+
+	if (ctx->sa_base_in)
+		dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	mtk_set_saRecord(saRecord, 0, flags);
+	saRecord->saCmd0.bits.saveHash = 1;
+	saRecord->saCmd1.bits.copyDigest = 0;
+	saRecord->saCmd1.bits.copyHeader = 0;
+	saRecord->saCmd0.bits.hashSource = 2;
+	saRecord->saCmd0.bits.digestLength = crypto_ahash_digestsize(ahash) / 4;
+
+	ctx->sa_base_in = dma_map_single(ctx->mtk->dev, ctx->sa_in,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	rctx->saRecord = saRecord;
+	rctx->saRecord_base = ctx->sa_base_in;
+
+	if (!rctx->saState_base) {
+		idx = mtk_get_free_saState(mtk);
+		if (idx < 0)
+			return -ENOMEM;
+
+		saState_pool = &mtk->ring->saState_pool[idx];
+		rctx->saState_idx = idx;
+		rctx->saState = saState_pool->base;
+		rctx->saState_base = saState_pool->base_dma;
+	}
+	saState = rctx->saState;
+	saState->stateByteCnt = 0x40;
+
+	if (IS_HMAC(flags))
+		memcpy(saState->saIDigest,saRecord->saIDigest,
+							SHA256_DIGEST_SIZE);
+	} else {
+		saState->saIDigest = ctx->init_state;
+	}
+
+	return 0;
+}
+
+static int mtk_ahash_digest(struct ahash_request *areq)
+{
+	int ret = mtk_ahash_init(areq);
+
+	if (ret)
+		return ret;
+
+	return mtk_ahash_finup(areq);
+}
+
+static void mtk_ahash_cra_exit(struct crypto_tfm *tfm)
+{
+	struct mtk_ahash_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	if (ctx->sa_base_in)
+		dma_unmap_single(ctx->mtk->dev, ctx->sa_base_in,
+			sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	if (ctx->shash)
+		crypto_free_shash(ctx->shash);
+
+	kfree(ctx->sa_in);
+}
+
+struct mtk_alg_template mtk_alg_sha1 = {
+	.type = MTK_ALG_TYPE_AHASH,
+	.flags = MTK_HASH_SHA1,
+	.alg.ahash = {
+		.init = mtk_ahash_init,
+		.update = mtk_ahash_update,
+		.final = mtk_ahash_final,
+		.finup = mtk_ahash_finup,
+		.digest = mtk_ahash_digest,
+		.export = mtk_ahash_export,
+		.import = mtk_ahash_import,
+		.halg = {
+			.digestsize = SHA1_DIGEST_SIZE,
+			.statesize = sizeof(struct mtk_ahash_export_state),
+			.base = {
+				.cra_name = "sha1",
+				.cra_driver_name = "sha1-eip93",
+				.cra_priority = 300,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA1_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct mtk_ahash_ctx),
+				.cra_init = mtk_ahash_cra_init,
+				.cra_exit = mtk_ahash_cra_exit,
+				.cra_module = THIS_MODULE,
+			},
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_sha224 = {
+	.type = MTK_ALG_TYPE_AHASH,
+	.flags = MTK_HASH_SHA224,
+	.alg.ahash = {
+		.init = mtk_ahash_init,
+		.update = mtk_ahash_update,
+		.final = mtk_ahash_final,
+		.finup = mtk_ahash_finup,
+		.digest= mtk_ahash_digest,
+		.export = mtk_ahash_export,
+		.import = mtk_ahash_import,
+		.halg = {
+			.digestsize = SHA224_DIGEST_SIZE,
+			.statesize = sizeof(struct mtk_ahash_export_state),
+			.base = {
+				.cra_name = "sha224",
+				.cra_driver_name = "sha224-eip93",
+				.cra_priority = 300,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct mtk_ahash_ctx),
+				.cra_init = mtk_ahash_cra_init,
+				.cra_exit = mtk_ahash_cra_exit,
+				.cra_module = THIS_MODULE,
+			},
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_sha256 = {
+	.type = MTK_ALG_TYPE_AHASH,
+	.flags = MTK_HASH_SHA256,
+	.alg.ahash = {
+		.init = mtk_ahash_init,
+		.update = mtk_ahash_update,
+		.final = mtk_ahash_final,
+		.finup = mtk_ahash_finup,
+		.digest= mtk_ahash_digest,
+		.export = mtk_ahash_export,
+		.import = mtk_ahash_import,
+		.halg = {
+			.digestsize = SHA256_DIGEST_SIZE,
+			.statesize = sizeof(struct mtk_ahash_export_state),
+			.base = {
+				.cra_name = "sha256",
+				.cra_driver_name = "sha256-eip93",
+				.cra_priority = 300,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA256_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct mtk_ahash_ctx),
+				.cra_init = mtk_ahash_cra_init,
+				.cra_exit = mtk_ahash_cra_exit,
+				.cra_module = THIS_MODULE,
+			},
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_hmac_sha1 = {
+	.type = MTK_ALG_TYPE_AHASH,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA1,
+	.alg.ahash = {
+		.init = mtk_ahash_init,
+		.update = mtk_ahash_update,
+		.final = mtk_ahash_final,
+		.finup = mtk_ahash_finup,
+		.digest= mtk_ahash_digest,
+		.setkey = mtk_hmac_setkey,
+		.export = mtk_ahash_export,
+		.import = mtk_ahash_import,
+		.halg = {
+			.digestsize = SHA1_DIGEST_SIZE,
+			.statesize = sizeof(struct mtk_ahash_export_state),
+			.base = {
+				.cra_name = "hmac(sha1)",
+				.cra_driver_name = "hmac(sha1-eip93)",
+				.cra_priority = 300,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA1_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct mtk_ahash_ctx),
+				.cra_init = mtk_ahash_cra_init,
+				.cra_exit = mtk_ahash_cra_exit,
+				.cra_module = THIS_MODULE,
+			},
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_hmac_sha224 = {
+	.type = MTK_ALG_TYPE_AHASH,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA224,
+	.alg.ahash = {
+		.init = mtk_ahash_init,
+		.update = mtk_ahash_update,
+		.final = mtk_ahash_final,
+		.finup = mtk_ahash_finup,
+		.digest= mtk_ahash_digest,
+		.setkey = mtk_hmac_setkey,
+		.export = mtk_ahash_export,
+		.import = mtk_ahash_import,
+		.halg = {
+			.digestsize = SHA224_DIGEST_SIZE,
+			.statesize = sizeof(struct mtk_ahash_export_state),
+			.base = {
+				.cra_name = "hmac(sha224)",
+				.cra_driver_name = "hmac(sha224-eip93)",
+				.cra_priority = 300,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA224_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct mtk_ahash_ctx),
+				.cra_init = mtk_ahash_cra_init,
+				.cra_exit = mtk_ahash_cra_exit,
+				.cra_module = THIS_MODULE,
+			},
+		},
+	},
+};
+
+struct mtk_alg_template mtk_alg_hmac_sha256 = {
+	.type = MTK_ALG_TYPE_AHASH,
+	.flags = MTK_HASH_HMAC | MTK_HASH_SHA256,
+	.alg.ahash = {
+		.init = mtk_ahash_init,
+		.update = mtk_ahash_update,
+		.final = mtk_ahash_final,
+		.finup = mtk_ahash_finup,
+		.digest= mtk_ahash_digest,
+		.setkey = mtk_hmac_setkey,
+		.export = mtk_ahash_export,
+		.import = mtk_ahash_import,
+		.halg = {
+			.digestsize = SHA1_DIGEST_SIZE,
+			.statesize = sizeof(struct mtk_ahash_export_state),
+			.base = {
+				.cra_name = "hmac(sha256)",
+				.cra_driver_name = "hmac(sha256-eip93)",
+				.cra_priority = 300,
+				.cra_flags = CRYPTO_ALG_ASYNC |
+						CRYPTO_ALG_KERN_DRIVER_ONLY,
+				.cra_blocksize = SHA1_BLOCK_SIZE,
+				.cra_ctxsize = sizeof(struct mtk_ahash_ctx),
+				.cra_init = mtk_ahash_cra_init,
+				.cra_exit = mtk_ahash_cra_exit,
+				.cra_module = THIS_MODULE,
+			},
+		},
+	},
+};
diff --git a/package/kernel/mtk-eip93/src/eip93-hash.h b/package/kernel/mtk-eip93/src/eip93-hash.h
new file mode 100644
index 0000000..e543005
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-hash.h
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#ifndef _SHA_H_
+#define _SHA_H_
+
+#include <crypto/sha.h>
+
+#include "eip93-main.h"
+
+extern struct mtk_alg_template mtk_alg_sha1;
+extern struct mtk_alg_template mtk_alg_sha224;
+extern struct mtk_alg_template mtk_alg_sha256;
+extern struct mtk_alg_template mtk_alg_hmac_sha1;
+extern struct mtk_alg_template mtk_alg_hmac_sha224;
+extern struct mtk_alg_template mtk_alg_hmac_sha256;
+
+struct mtk_ahash_ctx {
+	struct mtk_device	*mtk;
+	struct saRecord_s	*sa_in;
+	dma_addr_t		sa_base_in;
+	u32			init_state[SHA256_DIGEST_SIZE / sizeof(u32)];
+	struct crypto_shash	*shash;
+};
+
+struct mtk_ahash_reqctx {
+	struct mtk_device	*mtk;
+	struct saState_s	*saState;
+	dma_addr_t		saState_base;
+	u32			saState_idx;
+	struct saRecord_s	*saRecord;
+	dma_addr_t		saRecord_base;
+	u32			flags;
+
+	int		nents;
+	dma_addr_t	result_dma;
+
+	u64		len;
+	u64		processed;
+
+	u8		cache[SHA256_BLOCK_SIZE] __aligned(sizeof(u32));
+	dma_addr_t	cache_dma;
+	unsigned int	cache_sz;
+
+	u8		cache_next[SHA256_BLOCK_SIZE] __aligned(sizeof(u32));
+};
+
+struct mtk_ahash_export_state {
+	u64		len;
+	u64		processed;
+	u32		flags;
+
+	u32		saIDigest[8];
+	u32		stateByteCnt[2];
+	u8		cache[SHA256_BLOCK_SIZE];
+};
+
+int mtk_ahash_handle_result(struct mtk_device *mtk,
+				  struct crypto_async_request *async,
+				  int err);
+
+int mtk_ahash_send_req(struct mtk_device *mtk,
+				struct crypto_async_request *async);
+#endif /* _SHA_H_ */
diff --git a/package/kernel/mtk-eip93/src/eip93-ipsec.c b/package/kernel/mtk-eip93/src/eip93-ipsec.c
new file mode 100644
index 0000000..9abf1fb
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-ipsec.c
@@ -0,0 +1,980 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <net/protocol.h>
+#include <crypto/aead.h>
+#include <crypto/authenc.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <net/ip.h>
+#include <net/xfrm.h>
+#include <net/esp.h>
+#include <linux/scatterlist.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <net/udp.h>
+
+#include <crypto/ctr.h>
+#include <linux/netdevice.h>
+#include <net/esp.h>
+#include <net/xfrm.h>
+
+#include "eip93-common.h"
+#include "eip93-main.h"
+#include "eip93-ipsec.h"
+#include "eip93-regs.h"
+
+static int mtk_xfrm_add_state(struct xfrm_state *x);
+static void mtk_xfrm_del_state(struct xfrm_state *x);
+static void mtk_xfrm_free_state(struct xfrm_state *x);
+static bool mtk_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x);
+static void mtk_advance_esn_state(struct xfrm_state *x);
+
+static const struct xfrmdev_ops mtk_xfrmdev_ops = {
+	.xdo_dev_state_add      = mtk_xfrm_add_state,
+	.xdo_dev_state_delete   = mtk_xfrm_del_state,
+	.xdo_dev_state_free     = mtk_xfrm_free_state,
+	.xdo_dev_offload_ok     = mtk_ipsec_offload_ok,
+	.xdo_dev_state_advance_esn = mtk_advance_esn_state,
+};
+
+int mtk_add_xfrmops(struct net_device *netdev)
+{
+	if (netdev->features & NETIF_F_HW_ESP)
+		return NOTIFY_DONE;
+
+	if(netdev->irq != 24) { // Workaround for gmac1
+		if (netdev->dev.type == NULL)
+			return NOTIFY_DONE;
+
+		if (strcmp(netdev->dev.type->name, "dsa"))  {
+			if (strcmp(netdev->dev.type->name, "bridge"))
+				return NOTIFY_DONE;
+		}
+	}
+
+	/* enable ESP HW offload */
+	netdev->xfrmdev_ops = &mtk_xfrmdev_ops;
+	netdev->features |= NETIF_F_HW_ESP;
+	netdev->hw_enc_features |= NETIF_F_HW_ESP;
+	/* enable ESP GSO */
+	netdev->features |= NETIF_F_GSO_ESP;
+	netdev->hw_enc_features |= NETIF_F_GSO_ESP;
+
+	netdev_change_features(netdev);
+	netdev_info(netdev, "ESP HW offload added.\n");
+	return NOTIFY_DONE;
+}
+
+int mtk_del_xfrmops(struct net_device *netdev)
+{
+	if (netdev->features & NETIF_F_HW_ESP) {
+		netdev->xfrmdev_ops = NULL;
+		netdev->hw_enc_features &= ~NETIF_F_HW_ESP;
+		netdev->features &= ~NETIF_F_HW_ESP;
+		netdev_change_features(netdev);
+		netdev_info(netdev, "ESP HW offload removed.\n");
+	}
+
+	return NOTIFY_DONE;
+}
+
+/*
+ * mtk_validate_state
+ * return 0 in case doesn't validate or "flags" which
+ * can never be "0"
+ */
+u32 mtk_validate_state(struct xfrm_state *x)
+{
+ 	struct net_device *netdev = x->xso.dev;
+ 	u32 flags = 0;
+
+	if (x->id.proto != IPPROTO_ESP) {
+ 		netdev_info(netdev, "Only ESP XFRM state may be offloaded\n");
+ 		return 0;
+ 	}
+	/* TODO: add ipv6 support */
+	if (x->props.family != AF_INET) {
+//		&& x->props.family != AF_INET6) {
+		netdev_info(netdev, "Only IPv4 xfrm states may be offloaded\n");
+		return 0;
+	}
+	if (x->aead) {
+		netdev_info(netdev, "Cannot offload xfrm states with aead\n");
+		return 0;
+	}
+ 	if (x->props.aalgo == SADB_AALG_NONE) {
+ 		netdev_info(netdev, "Cannot offload without authentication\n");
+ 		return 0;
+ 	}
+ 	if (x->props.calgo != SADB_X_CALG_NONE) {
+ 		netdev_info(netdev, "Cannot offload compressed xfrm states\n");
+ 		return 0;
+ 	}
+ 	/* TODO: support ESN */
+ 	if (x->props.flags & XFRM_STATE_ESN) {
+ 		netdev_info(netdev, "Cannot offload ESN xfrm states\n");
+ 		return 0;
+ 	}
+ 	/* TODO: add transport mode */
+ 	if (x->props.mode != XFRM_MODE_TUNNEL
+			&& x->props.mode != XFRM_MODE_TRANSPORT) {
+ 		netdev_info(netdev, "only offload Tunnel & Transport Mode\n");
+ 		return 0;
+ 	}
+ 	if (x->encap) {
+ 		netdev_info(netdev, "Encapsulated xfrm can not be offloaded\n");
+ 		return 0;
+ 	}
+ 	if (x->tfcpad) {
+ 		netdev_info(netdev, "No tfc padding supported\n");
+ 		return 0;
+ 	}
+
+     	switch (x->props.ealgo) {
+ 	case SADB_EALG_DESCBC:
+ 		flags |= MTK_ALG_DES | MTK_MODE_CBC;
+ 		break;
+ 	case SADB_EALG_3DESCBC:
+ 		flags |= MTK_ALG_3DES | MTK_MODE_CBC;
+ 		break;
+ 	case SADB_X_EALG_AESCBC:
+ 		flags |= MTK_ALG_AES | MTK_MODE_CBC;
+ 		break;
+ 	case SADB_X_EALG_AESCTR: // CTR is ONLY in RFC3686 for ESP
+ 		flags |= MTK_ALG_AES | MTK_MODE_CTR | MTK_MODE_RFC3686;
+ 	case SADB_EALG_NULL:
+ 		break;
+ 	default:
+ 		netdev_info(netdev, "Cannot offload encryption: %s\n",
+							x->ealg->alg_name);
+ 		return 0;
+ 	}
+
+ 	switch (x->props.aalgo) {
+ 	case SADB_AALG_SHA1HMAC:
+ 		flags |= MTK_HASH_HMAC | MTK_HASH_SHA1;
+ 		break;
+ 	case SADB_X_AALG_SHA2_256HMAC:
+ 		flags |= MTK_HASH_HMAC | MTK_HASH_SHA256;
+ 		break;
+ 	case SADB_AALG_MD5HMAC:
+ 		flags |= MTK_HASH_HMAC | MTK_HASH_MD5;
+ 		break;
+ 	default:
+ 		netdev_info(netdev, "Cannot offload authentication: %s\n",
+							x->aalg->alg_name);
+ 		return 0;
+	}
+ /*
+ 	if (x->aead->alg_icv_len != 128) {
+ 		netdev_info(netdev, "Cannot offload xfrm states with AEAD ICV length other than 128bit\n");
+ 		return -EINVAL;
+ 	}
+ */
+
+ /*
+ 	TODO check key_len
+ 	// split for RFC3686 with nonce vs others !!
+ 	if ((x->aead->alg_key_len != 128 + 32) &&
+ 	    (x->aead->alg_key_len != 256 + 32)) {
+ 		netdev_info(netdev, "Cannot offload xfrm states with AEAD key length other than 128/256 bit\n");
+ 		return -EINVAL;
+ 	}
+ */
+	return flags;
+}
+
+static int mtk_create_sa(struct mtk_device *mtk, struct ipsec_sa_entry *ipsec,
+			struct xfrm_state *x, u32 flags)
+{
+	struct saRecord_s *saRecord;
+	char *alg_base;
+	const u8 *enckey = x->ealg->alg_key;
+	unsigned int enckeylen = (x->ealg->alg_key_len >>3);
+	const u8 *authkey = x->aalg->alg_key;
+	unsigned int authkeylen = (x->aalg->alg_key_len >>3);
+	unsigned int trunc_len = (x->aalg->alg_trunc_len >>3);
+	u32 nonce = 0;
+	int err;
+
+	if (IS_HASH_MD5(flags))
+		alg_base = "md5";
+	if (IS_HASH_SHA1(flags))
+		alg_base = "sha1";
+	if (IS_HASH_SHA256(flags))
+		alg_base = "sha256";
+
+	ipsec->shash = crypto_alloc_shash(alg_base, 0, CRYPTO_ALG_NEED_FALLBACK);
+
+	if (IS_ERR(ipsec->shash)) {
+	 	dev_err(mtk->dev, "base driver %s could not be loaded.\n",
+			 alg_base);
+	return PTR_ERR(ipsec->shash);
+	}
+
+	ipsec->sa = kzalloc(sizeof(struct saRecord_s), GFP_KERNEL);
+	if (!ipsec->sa)
+		return -ENOMEM;
+
+	ipsec->sa_base = dma_map_single(mtk->dev, ipsec->sa,
+				sizeof(struct saRecord_s), DMA_TO_DEVICE);
+
+	saRecord = ipsec->sa;
+
+	if (IS_RFC3686(flags)) {
+		if (enckeylen < CTR_RFC3686_NONCE_SIZE)
+			dev_err(mtk->dev, "rfc 3686 bad key\n");
+
+		enckeylen -= CTR_RFC3686_NONCE_SIZE;
+		memcpy(&nonce, enckey + enckeylen,
+						CTR_RFC3686_NONCE_SIZE);
+	}
+
+	/* Encryption key */
+	mtk_set_saRecord(saRecord, enckeylen, flags);
+
+	memcpy(saRecord->saKey, enckey, enckeylen);
+	saRecord->saNonce = nonce;
+
+	/* authentication key */
+	err = mtk_authenc_setkey(ipsec->shash,  saRecord, authkey, authkeylen);
+	if (err)
+		dev_err(mtk->dev, "Set Key failed: %d\n", err);
+
+	saRecord->saCmd0.bits.opGroup = 1;
+	saRecord->saCmd0.bits.opCode = 0;
+	saRecord->saCmd1.bits.byteOffset = 0;
+	saRecord->saCmd1.bits.hashCryptOffset = 0;
+	saRecord->saCmd0.bits.digestLength = (trunc_len >> 2);
+	saRecord->saCmd1.bits.hmac = 1;
+	saRecord->saCmd0.bits.padType = 0; // IPSec padding
+	saRecord->saCmd0.bits.extPad = 0;
+	saRecord->saCmd0.bits.scPad = 1; // Allow Stream Cipher padding
+	saRecord->saCmd1.bits.copyPad = 0;
+	saRecord->saCmd0.bits.hdrProc = 1;
+	saRecord->saCmd1.bits.seqNumCheck = 1;
+	saRecord->saSpi = ntohl(x->id.spi);
+	saRecord->saSeqNum[0] = 0;
+	saRecord->saSeqNum[1] = 0;
+
+	if (x->xso.flags & XFRM_OFFLOAD_INBOUND) {
+		saRecord->saCmd0.bits.direction = 1;
+		saRecord->saCmd1.bits.copyHeader = 1;
+		saRecord->saCmd1.bits.copyDigest = 0;
+		saRecord->saCmd0.bits.ivSource = 1;
+		flags |= MTK_DECRYPT;
+		dev_dbg(mtk->dev, "Inbound SA created. SPI: %08x\n",
+							ntohl(x->id.spi));
+	} else {
+		saRecord->saCmd0.bits.direction = 0;
+		saRecord->saCmd1.bits.copyHeader = 0;
+		saRecord->saCmd1.bits.copyDigest = 1;
+		saRecord->saCmd0.bits.ivSource = 3;
+		flags |= MTK_ENCRYPT;
+		dev_dbg(mtk->dev, "Outbound SA created. SPI: %08x\n",
+							ntohl(x->id.spi));
+	}
+
+	ipsec->cdesc.peCrtlStat.bits.hostReady = 1;
+	ipsec->cdesc.peCrtlStat.bits.prngMode = 0;
+	ipsec->cdesc.peCrtlStat.bits.hashFinal = 1;
+	ipsec->cdesc.peCrtlStat.bits.padCrtlStat = 2; // Pad align 4 as esp4.c
+	ipsec->cdesc.peCrtlStat.bits.peReady = 0;
+	ipsec->cdesc.saAddr = ipsec->sa_base;
+	ipsec->cdesc.stateAddr = 0;
+	ipsec->cdesc.arc4Addr = 0;
+	ipsec->cdesc.userId = flags |
+			MTK_DESC_IPSEC | MTK_DESC_LAST | MTK_DESC_FINISH;
+
+	return 0;
+}
+
+ /*
+ * mtk_xfrm_add_state
+ */
+static int mtk_xfrm_add_state(struct xfrm_state *x)
+{
+	struct crypto_rng *rng;
+	struct rng_alg *alg;
+	struct mtk_alg_template *tmpl;
+	struct mtk_device *mtk;
+	struct ipsec_sa_entry *ipsec;
+	u32 flags = 0;
+	int err;
+
+	rng = crypto_alloc_rng("eip93-prng", 0, 0);
+	if (IS_ERR(rng))
+		return -EOPNOTSUPP;
+
+	alg = crypto_rng_alg(rng);
+	tmpl = container_of(alg, struct mtk_alg_template, alg.rng);
+	mtk = tmpl->mtk;
+	crypto_free_rng(rng);
+
+	flags = mtk_validate_state(x);
+
+	if (!flags)
+		return -EOPNOTSUPP;
+
+	ipsec = kmalloc(sizeof(struct ipsec_sa_entry), GFP_KERNEL);
+
+	/* TODO: changed to ipsec pointer
+	 * TODO: add key checks
+	 */
+
+	err = mtk_create_sa(mtk, ipsec, x, flags);
+	if (err) {
+		dev_err(mtk->dev, "error creating sa\n");
+		return err;
+	}
+	ipsec->mtk = mtk;
+
+	x->xso.offload_handle = (unsigned long)ipsec;
+	try_module_get(THIS_MODULE);
+
+	return 0;
+}
+
+static void mtk_xfrm_del_state(struct xfrm_state *x)
+{
+	// do nothing.
+
+	return;
+}
+
+static void mtk_xfrm_free_state(struct xfrm_state *x)
+{
+	struct mtk_device *mtk;
+	struct ipsec_sa_entry *ipsec;
+
+	ipsec = (struct ipsec_sa_entry *)x->xso.offload_handle;
+	mtk = ipsec->mtk;
+
+	dma_unmap_single(mtk->dev, ipsec->sa_base, sizeof(struct saRecord_s),
+								DMA_TO_DEVICE);
+	kfree(ipsec->sa);
+	kfree(ipsec);
+
+	module_put(THIS_MODULE);
+
+	return;
+}
+
+static void mtk_advance_esn_state(struct xfrm_state *x)
+{
+	return;
+}
+
+/**
+ * mtk_ipsec_offload_ok - can this packet use the xfrm hw offload
+ * @skb: current data packet
+ * @xs: pointer to transformer state struct
+ **/
+static bool mtk_ipsec_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
+{
+	if (x->props.family == AF_INET) {
+		/* Offload with IPv4 options is not supported yet */
+		if (ip_hdr(skb)->ihl != 5)
+			return false;
+	} else {
+		/* Offload with IPv6 extension headers is not support yet */
+		if (ipv6_ext_hdr(ipv6_hdr(skb)->nexthdr))
+			return false;
+	}
+
+	return true;
+}
+
+void mtk_ipsec_rx_done(unsigned long data)
+{
+	struct mtk_device *mtk = (struct mtk_device *)data;
+	struct mtk_ipsec_cb *mtk_ipsec_cb;
+	struct sk_buff *skb;
+	dma_addr_t dstAddr;
+	u8 nexthdr;
+	int err, len;
+//	int handled = 0;
+	struct ipsec_sa_entry *ipsec;
+	struct xfrm_state *x;
+	struct xfrm_offload *xo;
+	__wsum csumdiff;
+
+	while ((skb = skb_dequeue(&mtk->ring->rx_queue))) {
+		mtk_ipsec_cb = (struct mtk_ipsec_cb *)MTK_IPSEC_CB(skb)->cb;
+		nexthdr = mtk_ipsec_cb->nexthdr;
+		err = mtk_ipsec_cb->err;
+		len = mtk_ipsec_cb->len;
+		dstAddr = mtk_ipsec_cb->dstAddr;
+		MTK_IPSEC_CB(skb)->cb = mtk_ipsec_cb->org_cb;
+		kfree(mtk_ipsec_cb);
+
+		x = xfrm_input_state(skb);
+		ipsec = (struct ipsec_sa_entry *)x->xso.offload_handle;
+
+		xo = xfrm_offload(skb);
+		xo->flags |= CRYPTO_DONE;
+		xo->status = CRYPTO_SUCCESS;
+		if (err ==  1)
+			xo->status = CRYPTO_TUNNEL_ESP_AUTH_FAILED;
+
+		dma_unmap_single(mtk->dev, dstAddr, skb->len, DMA_BIDIRECTIONAL);
+		xo->proto = nexthdr;
+		xo->flags |=  XFRM_ESP_NO_TRAILER;
+		if (skb->ip_summed == CHECKSUM_COMPLETE) {
+			csumdiff = skb_checksum(skb, len, skb->len - len, 0);
+			skb->csum = csum_block_sub(skb->csum, csumdiff, len);
+		}
+		pskb_trim(skb, len);
+		// for inbound continue XFRM (-2 is GRO)
+		xfrm_input(skb, IPPROTO_ESP, x->id.spi, -2);
+//		handled++;
+	}
+//	dev_info(ipsec->mtk->dev, "rx done: %d\n", handled);
+}
+
+void mtk_ipsec_tx_done(unsigned long data)
+{
+	struct mtk_device *mtk = (struct mtk_device *)data;
+	struct mtk_ipsec_cb *mtk_ipsec_cb;
+	struct sk_buff *skb;
+	dma_addr_t dAddr;
+	u8 nexthdr;
+	int err, len;
+//	int handled = 0;
+	struct ipsec_sa_entry *ipsec;
+	struct xfrm_state *x;
+	struct xfrm_offload *xo;
+
+	while ((skb = skb_dequeue(&mtk->ring->tx_queue))) {
+		mtk_ipsec_cb = (struct mtk_ipsec_cb *)MTK_IPSEC_CB(skb)->cb;
+		nexthdr = mtk_ipsec_cb->nexthdr;
+		err = mtk_ipsec_cb->err;
+		len = mtk_ipsec_cb->len;
+		dAddr = mtk_ipsec_cb->dstAddr;
+		MTK_IPSEC_CB(skb)->cb = mtk_ipsec_cb->org_cb;
+		kfree(mtk_ipsec_cb);
+
+		x = xfrm_input_state(skb);
+		ipsec = (struct ipsec_sa_entry *)x->xso.offload_handle;
+
+		xo = xfrm_offload(skb);
+		xo->flags |= CRYPTO_DONE;
+		xo->status = CRYPTO_SUCCESS;
+
+		dma_unmap_single(mtk->dev, dAddr, len + 20, DMA_BIDIRECTIONAL);
+
+		skb_put(skb, len - (skb->len - 20));
+		ip_hdr(skb)->tot_len = htons(skb->len);
+		ip_send_check(ip_hdr(skb));
+
+/*
+		if (xo && (xo->flags & XFRM_DEV_RESUME)) {
+			if (err) {
+				XFRM_INC_STATS(xs_net(x),
+					LINUX_MIB_XFRMOUTSTATEPROTOERROR);
+				kfree_skb(skb);
+				return;
+			}
+*/
+			skb_push(skb, skb->data - skb_mac_header(skb));
+			secpath_reset(skb);
+			xfrm_dev_resume(skb);
+//			handled++;
+//		}
+	}
+//	dev_info(ipsec->mtk->dev, "tx done: %d\n", handled);
+}
+
+int mtk_ipsec_offload(struct xfrm_state *x, struct sk_buff *skb)
+{
+	struct mtk_device *mtk;
+	struct mtk_ipsec_cb *mtk_ipsec_cb;
+	struct xfrm_offload *xo;
+	struct eip93_descriptor_s cdesc;
+	struct eip93_descriptor_s desc;
+	struct ipsec_sa_entry *ipsec;
+	struct crypto_aead *aead;
+	dma_addr_t saddr;
+	struct esp_info esp;
+	int err, assoclen, alen, blksize, ivsize;
+	int diff;
+
+	ipsec = (struct ipsec_sa_entry *)x->xso.offload_handle;
+	desc = ipsec->cdesc;
+	mtk = ipsec->mtk;
+
+	mtk_ipsec_cb = kmalloc(sizeof(struct mtk_ipsec_cb), GFP_KERNEL);
+	mtk_ipsec_cb->org_cb = MTK_IPSEC_CB(skb)->cb;
+	MTK_IPSEC_CB(skb)->cb = (u32)mtk_ipsec_cb;
+
+	xo = xfrm_offload(skb);
+
+	if (x->xso.flags & XFRM_OFFLOAD_INBOUND) {
+		if (unlikely(atomic_read(&mtk->ring->free) <= MTK_RING_BUSY)) {
+			dev_info(mtk->dev, "RCV packet drop\n");
+			xfrm_input(skb, -ENOSPC, x->id.spi, -1);
+			return -ENOSPC;
+		}
+		saddr = dma_map_single(mtk->dev, (void *)skb->data, skb->len,
+							DMA_BIDIRECTIONAL);
+		cdesc.peCrtlStat.word = desc.peCrtlStat.word;
+		cdesc.srcAddr = saddr;
+		cdesc.dstAddr = saddr;
+		cdesc.peLength.bits.length = skb->len;
+	} else {
+		if (unlikely(atomic_read(&mtk->ring->free) <= MTK_RING_BUSY)) {
+			dev_info(mtk->dev, "XMIT packet drop\n");
+			return -ENOSPC;
+		}
+
+		aead = x->data;
+		alen = crypto_aead_authsize(aead);
+
+		esp.esph = ip_esp_hdr(skb);
+		assoclen = sizeof(struct ip_esp_hdr);
+		ivsize = crypto_aead_ivsize(aead);
+
+		esp.tfclen = 0;
+		/* XXX: Add support for tfc padding here. */
+
+		blksize = ALIGN(crypto_aead_blocksize(aead), 4);
+		esp.clen = ALIGN(skb->len + 2 + esp.tfclen, blksize);
+		esp.plen = esp.clen - skb->len - esp.tfclen;
+		esp.tailen = esp.tfclen + esp.plen + alen;
+
+		diff = (u32)esp.esph - (u32)skb->data;
+		if (diff != 20)
+			printk("diff %d\n", diff);
+		esp.clen = skb->len - assoclen - ivsize - 20;
+
+		saddr = dma_map_single(mtk->dev, (void *)skb->data,
+			skb->len + esp.tailen, DMA_BIDIRECTIONAL);
+		cdesc.peCrtlStat.bits.hostReady = 1;
+		cdesc.peCrtlStat.bits.prngMode = 0;
+		cdesc.peCrtlStat.bits.padValue = xo->proto;
+		cdesc.peCrtlStat.bits.padCrtlStat = 2; // Pad align 4 as esp4.c
+		cdesc.peCrtlStat.bits.hashFinal = 1;
+		cdesc.peCrtlStat.bits.peReady = 0;
+		cdesc.srcAddr = (u32)esp.esph + assoclen + ivsize;
+		cdesc.dstAddr = (u32)esp.esph;
+		cdesc.peLength.bits.length = esp.clen;
+	}
+
+	cdesc.saAddr = desc.saAddr;
+	cdesc.stateAddr = desc.stateAddr;
+	cdesc.arc4Addr = (uintptr_t)skb;
+	cdesc.userId = desc.userId;
+	cdesc.peLength.bits.peReady = 0;
+	cdesc.peLength.bits.byPass = 0;
+	cdesc.peLength.bits.hostReady = 1;
+again:
+	err = mtk_put_descriptor(mtk, &cdesc);
+	/* Should not happen 32 descriptors margin */
+	if (err) {
+		udelay(1000);
+		goto again;
+	}
+
+	writel(1, mtk->base + EIP93_REG_PE_CD_COUNT);
+
+	return -EINPROGRESS;
+}
+
+static struct sk_buff *mtk_esp4_gro_receive(struct list_head *head,
+					struct sk_buff *skb)
+{
+	int offset = skb_gro_offset(skb);
+	struct xfrm_offload *xo;
+	struct xfrm_state *x;
+	__be32 seq;
+	__be32 spi;
+	int err;
+
+	if (!pskb_pull(skb, offset))
+		return NULL;
+
+	if ((err = xfrm_parse_spi(skb, IPPROTO_ESP, &spi, &seq)) != 0)
+		goto out;
+
+	xo = xfrm_offload(skb);
+	if (!xo || !(xo->flags & CRYPTO_DONE)) {
+		struct sec_path *sp = secpath_set(skb);
+
+		if (!sp)
+			goto out;
+
+		if (sp->len == XFRM_MAX_DEPTH)
+			goto out_reset;
+
+		x = xfrm_state_lookup(dev_net(skb->dev), skb->mark,
+				      (xfrm_address_t *)&ip_hdr(skb)->daddr,
+				      spi, IPPROTO_ESP, AF_INET);
+		if (!x)
+			goto out_reset;
+
+		skb->mark = xfrm_smark_get(skb->mark, x);
+
+		sp->xvec[sp->len++] = x;
+		sp->olen++;
+
+		xo = xfrm_offload(skb);
+		if (!xo)
+			goto out_reset;
+	}
+
+	xo->flags |= XFRM_GRO;
+
+	XFRM_TUNNEL_SKB_CB(skb)->tunnel.ip4 = NULL;
+	XFRM_SPI_SKB_CB(skb)->family = AF_INET;
+	XFRM_SPI_SKB_CB(skb)->daddroff = offsetof(struct iphdr, daddr);
+	XFRM_SPI_SKB_CB(skb)->seq = seq;
+
+	/* We don't need to handle errors from xfrm_input, it does all
+	 * the error handling and frees the resources on error. */
+	if (xo && x->xso.offload_handle)
+		err = mtk_ipsec_offload(x, skb);
+	else
+		xfrm_input(skb, IPPROTO_ESP, spi, -2);
+
+	return ERR_PTR(-EINPROGRESS);
+out_reset:
+	secpath_reset(skb);
+out:
+	skb_push(skb, offset);
+	NAPI_GRO_CB(skb)->same_flow = 0;
+	NAPI_GRO_CB(skb)->flush = 1;
+
+	return NULL;
+}
+
+
+static struct sk_buff *xfrm4_tunnel_gso_segment(struct xfrm_state *x,
+						struct sk_buff *skb,
+						netdev_features_t features)
+{
+	__skb_push(skb, skb->mac_len);
+	return skb_mac_gso_segment(skb, features);
+}
+
+static struct sk_buff *xfrm4_transport_gso_segment(struct xfrm_state *x,
+						   struct sk_buff *skb,
+						   netdev_features_t features)
+{
+	const struct net_offload *ops;
+	struct sk_buff *segs = ERR_PTR(-EINVAL);
+	struct xfrm_offload *xo = xfrm_offload(skb);
+
+	skb->transport_header += x->props.header_len;
+	ops = rcu_dereference(inet_offloads[xo->proto]);
+	if (likely(ops && ops->callbacks.gso_segment))
+		segs = ops->callbacks.gso_segment(skb, features);
+
+	return segs;
+}
+
+static struct sk_buff *xfrm4_beet_gso_segment(struct xfrm_state *x,
+					      struct sk_buff *skb,
+					      netdev_features_t features)
+{
+	struct xfrm_offload *xo = xfrm_offload(skb);
+	struct sk_buff *segs = ERR_PTR(-EINVAL);
+	const struct net_offload *ops;
+	u8 proto = xo->proto;
+
+	skb->transport_header += x->props.header_len;
+
+	if (x->sel.family != AF_INET6) {
+		if (proto == IPPROTO_BEETPH) {
+			struct ip_beet_phdr *ph =
+				(struct ip_beet_phdr *)skb->data;
+
+			skb->transport_header += ph->hdrlen * 8;
+			proto = ph->nexthdr;
+		} else {
+			skb->transport_header -= IPV4_BEET_PHMAXLEN;
+		}
+	} else {
+		__be16 frag;
+
+		skb->transport_header +=
+			ipv6_skip_exthdr(skb, 0, &proto, &frag);
+		if (proto == IPPROTO_TCP)
+			skb_shinfo(skb)->gso_type |= SKB_GSO_TCPV4;
+	}
+
+	__skb_pull(skb, skb_transport_offset(skb));
+	ops = rcu_dereference(inet_offloads[proto]);
+	if (likely(ops && ops->callbacks.gso_segment))
+		segs = ops->callbacks.gso_segment(skb, features);
+
+	return segs;
+}
+
+static struct sk_buff *xfrm4_outer_mode_gso_segment(struct xfrm_state *x,
+						    struct sk_buff *skb,
+						    netdev_features_t features)
+{
+	switch (x->outer_mode.encap) {
+	case XFRM_MODE_TUNNEL:
+		return xfrm4_tunnel_gso_segment(x, skb, features);
+	case XFRM_MODE_TRANSPORT:
+		return xfrm4_transport_gso_segment(x, skb, features);
+	case XFRM_MODE_BEET:
+		return xfrm4_beet_gso_segment(x, skb, features);
+	}
+
+	return ERR_PTR(-EOPNOTSUPP);
+}
+
+static struct sk_buff *mtk_esp4_gso_segment(struct sk_buff *skb,
+				        netdev_features_t features)
+{
+	struct xfrm_state *x;
+	struct ip_esp_hdr *esph;
+	struct crypto_aead *aead;
+	netdev_features_t esp_features = features;
+	struct xfrm_offload *xo = xfrm_offload(skb);
+	struct sec_path *sp;
+
+	printk("esp-gso-segment\n");
+
+	if (!xo)
+		return ERR_PTR(-EINVAL);
+
+	if (!(skb_shinfo(skb)->gso_type & SKB_GSO_ESP))
+		return ERR_PTR(-EINVAL);
+
+	sp = skb_sec_path(skb);
+	x = sp->xvec[sp->len - 1];
+	aead = x->data;
+	esph = ip_esp_hdr(skb);
+
+	if (esph->spi != x->id.spi)
+		return ERR_PTR(-EINVAL);
+
+	if (!pskb_may_pull(skb, sizeof(*esph) + crypto_aead_ivsize(aead)))
+		return ERR_PTR(-EINVAL);
+
+	__skb_pull(skb, sizeof(*esph) + crypto_aead_ivsize(aead));
+
+	skb->encap_hdr_csum = 1;
+
+	if ((!(skb->dev->gso_partial_features & NETIF_F_HW_ESP) &&
+	     !(features & NETIF_F_HW_ESP)) || x->xso.dev != skb->dev)
+		esp_features = features & ~(NETIF_F_SG | NETIF_F_CSUM_MASK |
+					    NETIF_F_SCTP_CRC);
+	else if (!(features & NETIF_F_HW_ESP_TX_CSUM) &&
+		 !(skb->dev->gso_partial_features & NETIF_F_HW_ESP_TX_CSUM))
+		esp_features = features & ~(NETIF_F_CSUM_MASK |
+					    NETIF_F_SCTP_CRC);
+
+	xo->flags |= XFRM_GSO_SEGMENT;
+
+	return xfrm4_outer_mode_gso_segment(x, skb, esp_features);
+}
+
+static int mtk_esp_input_tail(struct xfrm_state *x, struct sk_buff *skb)
+{
+	struct crypto_aead *aead = x->data;
+	struct xfrm_offload *xo = xfrm_offload(skb);
+
+	if (!pskb_may_pull(skb, sizeof(struct ip_esp_hdr) + crypto_aead_ivsize(aead)))
+		return -EINVAL;
+
+	if (!(xo->flags & CRYPTO_DONE))
+		skb->ip_summed = CHECKSUM_NONE;
+
+	return esp_input_done2(skb, 0);
+}
+
+static int mtk_esp_xmit(struct xfrm_state *x, struct sk_buff *skb,
+			netdev_features_t features)
+{
+	int err;
+	int org_len;
+	int alen;
+	int blksize;
+	struct ip_esp_hdr *esph;
+	struct crypto_aead *aead;
+	struct esp_info esp;
+	struct xfrm_offload *xo = xfrm_offload(skb);
+	bool hw_offload = true;
+	__u32 seq;
+
+	esp.inplace = true;
+
+	if (!xo)
+		return -EINVAL;
+
+	if ((!(features & NETIF_F_HW_ESP) &&
+	     !(skb->dev->gso_partial_features & NETIF_F_HW_ESP)) ||
+	    x->xso.dev != skb->dev) {
+		xo->flags |= CRYPTO_FALLBACK;
+		hw_offload = false;
+	}
+
+	esp.proto = xo->proto;
+
+	/* skb is pure payload to encrypt */
+
+	aead = x->data;
+	alen = crypto_aead_authsize(aead);
+
+	esp.tfclen = 0;
+	/* XXX: Add support for tfc padding here. */
+
+	blksize = ALIGN(crypto_aead_blocksize(aead), 4);
+	esp.clen = ALIGN(skb->len + 2 + esp.tfclen, blksize);
+	esp.plen = esp.clen - skb->len - esp.tfclen;
+	esp.tailen = esp.tfclen + esp.plen + alen;
+
+	esp.esph = ip_esp_hdr(skb);
+
+	if ((!hw_offload) || (esp.tailen > skb_tailroom(skb))) {
+		org_len = skb->len;
+		esp.nfrags = esp_output_head(x, skb, &esp);
+		if (esp.nfrags < 0)
+			return esp.nfrags;
+
+		err = skb_linearize(skb);
+		if (err)
+			return err;
+
+		if (hw_offload)
+			skb_put(skb, org_len - skb->len);
+	}
+
+	seq = xo->seq.low;
+
+	esph = esp.esph;
+	esph->spi = x->id.spi;
+
+	skb_push(skb, -skb_network_offset(skb));
+
+	if (xo->flags & XFRM_GSO_SEGMENT) {
+		esph->seq_no = htonl(seq);
+
+		if (!skb_is_gso(skb)) {
+			printk("!skb_is_gso\n");
+			xo->seq.low++;
+		} else {
+			printk("Gso segs: %d\n", skb_shinfo(skb)->gso_segs);
+			xo->seq.low += skb_shinfo(skb)->gso_segs;
+		}
+	}
+
+	esp.seqno = cpu_to_be64(seq + ((u64)xo->seq.hi << 32));
+
+	ip_hdr(skb)->tot_len = htons(skb->len);
+	ip_send_check(ip_hdr(skb));
+
+	if (hw_offload) {
+		if (!skb_ext_add(skb, SKB_EXT_SEC_PATH))
+			return -ENOMEM;
+
+		xo = xfrm_offload(skb);
+		if (!xo)
+			return -EINVAL;
+
+		xo->flags |= XFRM_XMIT;
+		err = mtk_ipsec_offload(x, skb);
+
+		return err;
+	}
+
+	err = esp_output_tail(x, skb, &esp);
+	if (err)
+		return err;
+
+	secpath_reset(skb);
+
+	return 0;
+}
+
+static void mtk_esp4_gso_encap(struct xfrm_state *x, struct sk_buff *skb)
+{
+	struct ip_esp_hdr *esph;
+	struct iphdr *iph = ip_hdr(skb);
+	struct xfrm_offload *xo = xfrm_offload(skb);
+	int proto = iph->protocol;
+
+	skb_push(skb, -skb_network_offset(skb));
+	esph = ip_esp_hdr(skb);
+	*skb_mac_header(skb) = IPPROTO_ESP;
+
+	esph->spi = x->id.spi;
+	esph->seq_no = htonl(XFRM_SKB_CB(skb)->seq.output.low);
+
+	xo->proto = proto;
+}
+
+static int ipsec_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+
+	switch (event) {
+	case NETDEV_REGISTER:
+		return mtk_add_xfrmops(dev);
+
+	case NETDEV_FEAT_CHANGE:
+		return mtk_add_xfrmops(dev);
+
+	case NETDEV_DOWN:
+	case NETDEV_UNREGISTER:
+		return mtk_del_xfrmops(dev);
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block ipsec_dev_notifier = {
+	.notifier_call	= ipsec_dev_event,
+};
+
+static const struct net_offload mtk_esp4_offload = {
+	.callbacks = {
+		.gro_receive = mtk_esp4_gro_receive,
+		.gso_segment = mtk_esp4_gso_segment,
+	},
+};
+
+static struct xfrm_type_offload mtk_esp_offload = {
+	.description	= "EIP93 ESP OFFLOAD",
+	.owner		= THIS_MODULE,
+	.proto	     	= IPPROTO_ESP,
+	.input_tail	= mtk_esp_input_tail,
+	.xmit		= mtk_esp_xmit,
+	.encap		= mtk_esp4_gso_encap,
+};
+
+//static int __init mtk_offload_register(void)
+int mtk_offload_register(void)
+{
+	xfrm_register_type_offload(&mtk_esp_offload, AF_INET);
+
+	inet_add_offload(&mtk_esp4_offload, IPPROTO_ESP);
+
+	return register_netdevice_notifier(&ipsec_dev_notifier);
+}
+
+//static
+void mtk_offload_deregister(void)
+{
+	xfrm_unregister_type_offload(&mtk_esp_offload, AF_INET);
+
+	inet_del_offload(&mtk_esp4_offload, IPPROTO_ESP);
+}
+
+//module_init(mtk_offload_register);
+//module_exit(mtk_offload_deregister);
+//MODULE_AUTHOR("Richard van Schagen <vschagen@icloud.com>");
+//MODULE_ALIAS("platform:" KBUILD_MODNAME);
+//MODULE_DESCRIPTION("Mediatek EIP-93 ESP Offload");
+//MODULE_LICENSE("GPL v2");
diff --git a/package/kernel/mtk-eip93/src/eip93-ipsec.h b/package/kernel/mtk-eip93/src/eip93-ipsec.h
new file mode 100644
index 0000000..9bf0327
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-ipsec.h
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#include <linux/skbuff.h>
+#include <net/xfrm.h>
+
+#include "eip93-main.h"
+#include "eip93-regs.h"
+
+#define MTK_IPSEC_CB(__skb) ((struct mtk_ipsec_results *)&((__skb)->cb[0]))
+
+struct ipsec_sa_entry {
+	struct mtk_device		*mtk;
+	struct saRecord_s		*sa;
+	dma_addr_t			sa_base;
+	struct crypto_shash		*shash;
+	u32				blksize;
+	struct eip93_descriptor_s	cdesc;
+};
+
+struct mtk_ipsec_results {
+	u32		cb;
+};
+
+struct mtk_ipsec_cb {
+	u32		org_cb;
+	dma_addr_t	dstAddr;
+	int 		err;
+	int		len;
+	u8		nexthdr;
+};
+
+int mtk_offload_register(void);
+
+void mtk_offload_deregister(void);
+
+int mtk_ipsec_offload(struct xfrm_state *x, struct sk_buff *skb);
+
+void mtk_ipsec_rx_done(unsigned long data);
+
+void mtk_ipsec_tx_done(unsigned long data);
diff --git a/package/kernel/mtk-eip93/src/eip93-main.c b/package/kernel/mtk-eip93/src/eip93-main.c
new file mode 100644
index 0000000..78e0663
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-main.c
@@ -0,0 +1,692 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#include <linux/atomic.h>
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+
+#include "eip93-main.h"
+#include "eip93-regs.h"
+#include "eip93-common.h"
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_SKCIPHER)
+#include "eip93-cipher.h"
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+#include "eip93-aes.h"
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+#include "eip93-des.h"
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AEAD)
+#include "eip93-aead.h"
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_PRNG)
+#include "eip93-prng.h"
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HASH)
+#include "eip93-hash.h"
+#include <crypto/sha.h>
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_IPSEC)
+#include "eip93-ipsec.h"
+#endif
+
+static struct mtk_alg_template *mtk_algs[] = {
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+	&mtk_alg_ecb_des,
+	&mtk_alg_cbc_des,
+	&mtk_alg_ecb_des3_ede,
+	&mtk_alg_cbc_des3_ede,
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+	&mtk_alg_ecb_aes,
+	&mtk_alg_cbc_aes,
+	&mtk_alg_ctr_aes,
+	&mtk_alg_rfc3686_aes,
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AEAD)
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+	&mtk_alg_authenc_hmac_md5_cbc_des,
+	&mtk_alg_authenc_hmac_sha1_cbc_des,
+	&mtk_alg_authenc_hmac_sha224_cbc_des,
+	&mtk_alg_authenc_hmac_sha256_cbc_des,
+	&mtk_alg_authenc_hmac_md5_cbc_des3_ede,
+	&mtk_alg_authenc_hmac_sha1_cbc_des3_ede,
+	&mtk_alg_authenc_hmac_sha224_cbc_des3_ede,
+	&mtk_alg_authenc_hmac_sha256_cbc_des3_ede,
+#endif
+	&mtk_alg_authenc_hmac_md5_cbc_aes,
+	&mtk_alg_authenc_hmac_sha1_cbc_aes,
+	&mtk_alg_authenc_hmac_sha224_cbc_aes,
+	&mtk_alg_authenc_hmac_sha256_cbc_aes,
+	&mtk_alg_authenc_hmac_md5_rfc3686_aes,
+	&mtk_alg_authenc_hmac_sha1_rfc3686_aes,
+	&mtk_alg_authenc_hmac_sha224_rfc3686_aes,
+	&mtk_alg_authenc_hmac_sha256_rfc3686_aes,
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_PRNG)
+	&mtk_alg_prng,
+//	&mtk_alg_cprng,
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HASH)
+//	&mtk_alg_sha1,
+//	&mtk_alg_sha224,
+//	&mtk_alg_sha256,
+//	&mtk_alg_hmac_sha1,
+//	&mtk_alg_hmac_sha224,
+//	&mtk_alg_hmac_sha256,
+#endif
+};
+
+inline void mtk_irq_disable(struct mtk_device *mtk, u32 mask)
+{
+	__raw_writel(mask, mtk->base + EIP93_REG_MASK_DISABLE);
+}
+
+inline void mtk_irq_enable(struct mtk_device *mtk, u32 mask)
+{
+	__raw_writel(mask, mtk->base + EIP93_REG_MASK_ENABLE);
+}
+
+inline void mtk_irq_clear(struct mtk_device *mtk, u32 mask)
+{
+	__raw_writel(mask, mtk->base + EIP93_REG_INT_CLR);
+}
+
+static void mtk_unregister_algs(unsigned int i)
+{
+	unsigned int j;
+
+	for (j = 0; j < i; j++) {
+		switch (mtk_algs[j]->type) {
+		case MTK_ALG_TYPE_SKCIPHER:
+			crypto_unregister_skcipher(&mtk_algs[j]->alg.skcipher);
+			break;
+		case MTK_ALG_TYPE_AEAD:
+			crypto_unregister_aead(&mtk_algs[j]->alg.aead);
+			break;
+		case MTK_ALG_TYPE_AHASH:
+			crypto_unregister_ahash(&mtk_algs[j]->alg.ahash);
+			break;
+		case MTK_ALG_TYPE_PRNG:
+			crypto_unregister_rng(&mtk_algs[j]->alg.rng);
+		}
+	}
+}
+
+static int mtk_register_algs(struct mtk_device *mtk)
+{
+	int err = 0;
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(mtk_algs); i++) {
+		mtk_algs[i]->mtk = mtk;
+
+		switch (mtk_algs[i]->type) {
+		case MTK_ALG_TYPE_SKCIPHER:
+			err = crypto_register_skcipher(&mtk_algs[i]->alg.skcipher);
+			break;
+		case MTK_ALG_TYPE_AEAD:
+			err = crypto_register_aead(&mtk_algs[i]->alg.aead);
+			break;
+		case MTK_ALG_TYPE_AHASH:
+			err = crypto_register_ahash(&mtk_algs[i]->alg.ahash);
+			break;
+		case MTK_ALG_TYPE_PRNG:
+			err = crypto_register_rng(&mtk_algs[i]->alg.rng);
+		}
+		if (err)
+			goto fail;
+	}
+
+	return 0;
+
+fail:
+	mtk_unregister_algs(i);
+
+	return err;
+}
+
+void mtk_handle_result_polling(struct mtk_device *mtk)
+{
+	struct crypto_async_request *async = NULL;
+	struct eip93_descriptor_s *rdesc;
+	int handled, ready, timeout = 5000;
+	int err = 0;
+	union peCrtlStat_w done1;
+	union peLength_w done2;
+	bool last_entry;
+	u32 flags;
+
+	spin_lock(&mtk->ring->lock);
+
+get_more:
+	handled = 0;
+
+	ready = readl(mtk->base + EIP93_REG_PE_RD_COUNT) & GENMASK(10, 0);
+
+	if (!ready) {
+		if (atomic_read(&mtk->ring->free) < (MTK_RING_SIZE - 1)) {
+			if (timeout--)
+				goto get_more;
+		}
+		dev_err(mtk->dev, "Poll time-out\n");
+		timeout = 5000;
+		goto get_more;
+	}
+
+	last_entry = false;
+
+	while (ready) {
+		rdesc = mtk_get_descriptor(mtk);
+		if (IS_ERR(rdesc)) {
+			dev_err(mtk->dev, "Ndesc: %d nreq: %d\n",
+				handled, ready);
+			err = -EIO;
+			break;
+		}
+		/* make sure DMA is finished writing */
+		do {
+			done1.word = READ_ONCE(rdesc->peCrtlStat.word);
+			done2.word = READ_ONCE(rdesc->peLength.word);
+		} while ((!done1.bits.peReady) || (!done2.bits.peReady));
+
+		err = rdesc->peCrtlStat.bits.errStatus;
+		if (err)
+			dev_err(mtk->dev, "Err: %02x\n", err);
+
+		flags = rdesc->userId;
+		async = (struct crypto_async_request *)rdesc->arc4Addr;
+
+		writel(1, mtk->base + EIP93_REG_PE_RD_COUNT);
+		mtk_irq_clear(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+
+		handled++;
+		ready--;
+
+		if (flags & MTK_DESC_LAST) {
+			last_entry = true;
+			break;
+		}
+	}
+
+	if (!last_entry) {
+		timeout = 5000;
+		goto get_more;
+	}
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_PRNG)
+	if (flags & MTK_DESC_PRNG) {
+		spin_unlock(&mtk->ring->lock);
+		mtk_prng_done(mtk, err);
+		return;
+	}
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_SKCIPHER)
+	if (flags & MTK_DESC_SKCIPHER) {
+		spin_unlock(&mtk->ring->lock);
+		mtk_skcipher_handle_result(async, err);
+		return;
+	}
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AEAD)
+	if (flags & MTK_DESC_AEAD) {
+		spin_unlock(&mtk->ring->lock);
+		mtk_aead_handle_result(async, err);
+		return;
+	}
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HASH)
+	if (flags & MTK_DESC_AHASH) {
+		spin_unlock(&mtk->ring->lock);
+		mtk_ahash_handle_result(async, err);
+		return;
+	}
+#endif
+	dev_err(mtk->dev, "Poll fall-thru\n");
+	goto get_more;
+}
+
+static void mtk_handle_result_descriptor(struct mtk_device *mtk)
+{
+	struct crypto_async_request *async = NULL;
+	struct eip93_descriptor_s *rdesc;
+	int handled, ready;
+	int err = 0;
+	union peCrtlStat_w done1;
+	union peLength_w done2;
+	bool last_entry;
+	u32 flags;
+
+
+	handled = 0;
+get_more:
+	ready = readl(mtk->base + EIP93_REG_PE_RD_COUNT) & GENMASK(10, 0);
+
+	if (!ready) {
+//		dev_info(mtk->dev, "Handled: %d\n", handled);
+		mtk_irq_clear(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+		mtk_irq_enable(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+		return;
+	}
+
+	last_entry = false;
+
+	while (ready) {
+		rdesc = mtk_get_descriptor(mtk);
+		if (IS_ERR(rdesc)) {
+			dev_err(mtk->dev, "Ndesc: %d nreq: %d\n",
+				handled, ready);
+			err = -EIO;
+			break;
+		}
+		/* make sure DMA is finished writing */
+		do {
+			done1.word = READ_ONCE(rdesc->peCrtlStat.word);
+			done2.word = READ_ONCE(rdesc->peLength.word);
+		} while ((!done1.bits.peReady) || (!done2.bits.peReady));
+
+		err = rdesc->peCrtlStat.bits.errStatus;
+		if (err)
+			dev_err(mtk->dev, "Err: %02x\n", err);
+
+		flags = rdesc->userId;
+		async = (struct crypto_async_request *)rdesc->arc4Addr;
+
+		writel(1, mtk->base + EIP93_REG_PE_RD_COUNT);
+		mtk_irq_clear(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+
+		handled++;
+		ready--;
+
+		if (flags & MTK_DESC_LAST) {
+			last_entry = true;
+			break;
+		}
+	}
+
+	if (!last_entry)
+		goto get_more;
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_PRNG)
+	if (flags & MTK_DESC_PRNG)
+		mtk_prng_done(mtk, err);
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_SKCIPHER)
+	if (flags & MTK_DESC_SKCIPHER)
+		mtk_skcipher_handle_result(async, err);
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AEAD)
+	if (flags & MTK_DESC_AEAD)
+		mtk_aead_handle_result(async, err);
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HASH)
+	if (flags & MTK_DESC_AHASH)
+		mtk_ahash_handle_result(async, err);
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_IPSEC)
+	if (flags & MTK_DESC_IPSEC) {
+		struct mtk_ipsec_cb *mtk_ipsec_cb;
+		struct sk_buff *skb;
+
+		skb = (struct sk_buff *)rdesc->arc4Addr;
+		mtk_ipsec_cb = (struct mtk_ipsec_cb *)MTK_IPSEC_CB(skb)->cb;
+		mtk_ipsec_cb->dstAddr = (u32)rdesc->dstAddr;
+		mtk_ipsec_cb->len = rdesc->peLength.bits.length;
+		mtk_ipsec_cb->err = err;
+		mtk_ipsec_cb->nexthdr = rdesc->peCrtlStat.bits.padValue;
+		if (IS_DECRYPT(flags)) {
+			__skb_queue_tail(&mtk->ring->rx_queue, skb);
+			tasklet_hi_schedule(&mtk->ring->rx_task);
+		} else {
+			__skb_queue_tail(&mtk->ring->tx_queue, skb);
+			tasklet_hi_schedule(&mtk->ring->tx_task);
+		}
+	}
+#endif
+	goto get_more;
+
+	/* set a Budget similar to NAPI */
+	if (handled < 64)
+		goto get_more;
+
+	mtk_irq_clear(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+	mtk_irq_enable(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+}
+
+static void mtk_done_task(unsigned long data)
+{
+	struct mtk_device *mtk = (struct mtk_device *)data;
+
+	mtk_handle_result_descriptor(mtk);
+}
+#ifndef CONFIG_CRYPTO_DEV_EIP93_POLL
+static irqreturn_t mtk_irq_handler(int irq, void *dev_id)
+{
+	struct mtk_device *mtk = (struct mtk_device *)dev_id;
+	u32 irq_status;
+
+	irq++;
+
+	irq_status = readl(mtk->base + EIP93_REG_INT_MASK_STAT);
+
+	if (irq_status & EIP93_INT_PE_RDRTHRESH_REQ) {
+		mtk_irq_disable(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+		tasklet_hi_schedule(&mtk->ring->done_task);
+		return IRQ_HANDLED;
+	}
+
+/* TODO: error handler; for now just clear ALL */
+	mtk_irq_clear(mtk, irq_status);
+	if (irq_status)
+		mtk_irq_disable(mtk, irq_status);
+
+	return IRQ_NONE;
+}
+#endif
+static void mtk_initialize(struct mtk_device *mtk)
+{
+	union peConfig_w peConfig;
+	union peEndianCfg_w peEndianCfg;
+	union peIntCfg_w peIntCfg;
+	union peClockCfg_w peClockCfg;
+	union peBufThresh_w peBufThresh;
+	union peRingThresh_w peRingThresh;
+
+	/* Reset Engine and setup Mode */
+	peConfig.word = 0;
+	peConfig.bits.resetPE = 1;
+	peConfig.bits.resetRing = 1;
+	peConfig.bits.peMode = 3;
+	peConfig.bits.enCDRupdate = 1;
+
+	writel(peConfig.word, mtk->base + EIP93_REG_PE_CONFIG);
+
+	udelay(10);
+
+	peConfig.bits.resetPE = 0;
+	peConfig.bits.resetRing = 0;
+
+	writel(peConfig.word, mtk->base + EIP93_REG_PE_CONFIG);
+
+	/* Initialize the BYTE_ORDER_CFG register */
+	peEndianCfg.word = 0;
+	writel(peEndianCfg.word, mtk->base + EIP93_REG_PE_ENDIAN_CONFIG);
+
+	/* Initialize the INT_CFG register */
+	peIntCfg.word = 0;
+	writel(peIntCfg.word, mtk->base + EIP93_REG_INT_CFG);
+
+	/* Config Clocks */
+	peClockCfg.word = 0;
+	peClockCfg.bits.enPEclk = 1;
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_DES)
+	peClockCfg.bits.enDESclk = 1;
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_AES)
+	peClockCfg.bits.enAESclk = 1;
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HMAC)
+	peClockCfg.bits.enHASHclk = 1;
+#endif
+	writel(peClockCfg.word, mtk->base + EIP93_REG_PE_CLOCK_CTRL);
+
+	/* Config DMA thresholds */
+	peBufThresh.word = 0;
+	peBufThresh.bits.inputBuffer  = 128;
+	peBufThresh.bits.outputBuffer = 128;
+
+	writel(peBufThresh.word, mtk->base + EIP93_REG_PE_BUF_THRESH);
+
+	/* Clear/ack all interrupts before disable all */
+	mtk_irq_clear(mtk, 0xFFFFFFFF);
+	mtk_irq_disable(mtk, 0xFFFFFFFF);
+
+	/* Config Ring Threshold */
+	peRingThresh.word = 0;
+	peRingThresh.bits.CDRThresh = MTK_RING_SIZE - MTK_RING_BUSY;
+	peRingThresh.bits.RDRThresh = 0;
+	peRingThresh.bits.RDTimeout = 5;
+	peRingThresh.bits.enTimeout = 1;
+
+	writel(peRingThresh.word, mtk->base + EIP93_REG_PE_RING_THRESH);
+}
+
+static void mtk_desc_free(struct mtk_device *mtk)
+{
+	writel(0, mtk->base + EIP93_REG_PE_RING_CONFIG);
+	writel(0, mtk->base + EIP93_REG_PE_CDR_BASE);
+	writel(0, mtk->base + EIP93_REG_PE_RDR_BASE);
+}
+
+static int mtk_set_ring(struct mtk_device *mtk, struct mtk_desc_ring *ring,
+			int Offset)
+{
+	ring->offset = Offset;
+	ring->base = dmam_alloc_coherent(mtk->dev, Offset * MTK_RING_SIZE,
+					&ring->base_dma, GFP_KERNEL);
+	if (!ring->base)
+		return -ENOMEM;
+
+	ring->write = ring->base;
+	ring->base_end = ring->base + Offset * (MTK_RING_SIZE - 1);
+	ring->read  = ring->base;
+
+	return 0;
+}
+
+static int mtk_desc_init(struct mtk_device *mtk)
+{
+	struct mtk_desc_ring *cdr = &mtk->ring->cdr;
+	struct mtk_desc_ring *rdr = &mtk->ring->rdr;
+	struct mtk_state_pool *saState_pool;
+	union peRingCfg_w peRingCfg;
+	int RingOffset,i, err;
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HASH)
+	struct mtk_desc_ring *hash_buf = &mtk->ring->hash_buf;
+#endif
+
+	RingOffset = sizeof(struct eip93_descriptor_s);
+
+	err = mtk_set_ring(mtk, cdr, RingOffset);
+	if (err)
+		return err;
+
+	err = mtk_set_ring(mtk, rdr, RingOffset);
+	if (err)
+		return err;
+
+	writel((u32)cdr->base_dma, mtk->base + EIP93_REG_PE_CDR_BASE);
+	writel((u32)rdr->base_dma, mtk->base + EIP93_REG_PE_RDR_BASE);
+
+	peRingCfg.word = 0;
+	peRingCfg.bits.ringSize = MTK_RING_SIZE - 1;
+	peRingCfg.bits.ringOffset = RingOffset / sizeof(u32);
+
+	writel(peRingCfg.word, mtk->base + EIP93_REG_PE_RING_CONFIG);
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_HASH)
+	err = mtk_set_ring(mtk, hash_buf, RingOffset);
+	if (err)
+		return err;
+#endif
+	atomic_set(&mtk->ring->free, MTK_RING_SIZE - 1);
+	/* Create State record DMA pool */
+	mtk->ring->saState = dmam_alloc_coherent(mtk->dev,
+				RingOffset * MTK_RING_SIZE,
+				&mtk->ring->saState_dma, GFP_KERNEL);
+	if (!mtk->ring->saState)
+		return -ENOMEM;
+
+	mtk->ring->saState_pool = devm_kcalloc(mtk->dev, 1,
+				sizeof(struct mtk_state_pool) * MTK_RING_SIZE,
+				GFP_KERNEL);
+	RingOffset = sizeof(struct saState_s);
+
+	for (i = 0; i < MTK_RING_SIZE; i++) {
+		saState_pool = &mtk->ring->saState_pool[i];
+		saState_pool->base = mtk->ring->saState + (i * RingOffset);
+		saState_pool->base_dma = mtk->ring->saState_dma +
+							(i * RingOffset);
+		saState_pool->in_use = false;
+	}
+
+	return 0;
+}
+
+static void mtk_cleanup(struct mtk_device *mtk)
+{
+	tasklet_kill(&mtk->ring->done_task);
+
+	/* Clear/ack all interrupts before disable all */
+	mtk_irq_clear(mtk, 0xFFFFFFFF);
+	mtk_irq_disable(mtk, 0xFFFFFFFF);
+
+	writel(0, mtk->base + EIP93_REG_PE_CLOCK_CTRL);
+
+	mtk_desc_free(mtk);
+}
+
+static int mtk_crypto_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mtk_device *mtk;
+	struct resource *res;
+	int err;
+	u32 regval;
+
+	mtk = devm_kzalloc(dev, sizeof(*mtk), GFP_KERNEL);
+	if (!mtk)
+		return -ENOMEM;
+
+	mtk->dev = dev;
+	platform_set_drvdata(pdev, mtk);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	mtk->base = devm_ioremap_resource(&pdev->dev, res);
+
+	if (IS_ERR(mtk->base))
+		return PTR_ERR(mtk->base);
+
+#ifndef CONFIG_CRYPTO_DEV_EIP93_POLL
+	mtk->irq = platform_get_irq(pdev, 0);
+
+	if (mtk->irq < 0) {
+		dev_dbg(mtk->dev, "Cannot get IRQ resource\n");
+		return mtk->irq;
+	}
+	dev_dbg(mtk->dev, "Assigning IRQ: %d", mtk->irq);
+
+	err = devm_request_threaded_irq(mtk->dev, mtk->irq, mtk_irq_handler,
+					NULL, IRQF_ONESHOT,
+					dev_name(mtk->dev), mtk);
+#endif
+
+	mtk->ring = devm_kcalloc(mtk->dev, 1, sizeof(*mtk->ring), GFP_KERNEL);
+
+	if (!mtk->ring)
+		return -ENOMEM;
+
+	err = mtk_desc_init(mtk);
+	if (err)
+		return err;
+
+	tasklet_init(&mtk->ring->done_task, mtk_done_task, (unsigned long)mtk);
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_IPSEC)
+	__skb_queue_head_init(&mtk->ring->rx_queue);
+	__skb_queue_head_init(&mtk->ring->tx_queue);
+
+	tasklet_init(&mtk->ring->rx_task, mtk_ipsec_rx_done,
+							(unsigned long)mtk);
+	tasklet_init(&mtk->ring->tx_task, mtk_ipsec_tx_done,
+							(unsigned long)mtk);
+#endif
+	spin_lock_init(&mtk->ring->lock);
+	spin_lock_init(&mtk->ring->read_lock);
+	spin_lock_init(&mtk->ring->write_lock);
+
+	mtk_initialize(mtk);
+
+#ifndef CONFIG_CRYPTO_DEV_EIP93_POLL
+	/* Init. finished, enable RDR interupt */
+	mtk_irq_enable(mtk, EIP93_INT_PE_RDRTHRESH_REQ);
+#endif
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_PRNG)
+	mtk->prng = devm_kcalloc(mtk->dev, 1, sizeof(*mtk->prng), GFP_KERNEL);
+
+	if (!mtk->prng)
+		return -ENOMEM;
+
+	err = mtk_prng_init(mtk, true);
+#endif
+
+	err = mtk_register_algs(mtk);
+	if (err) {
+		mtk_cleanup(mtk);
+		return err;
+	}
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_IPSEC)
+	err = mtk_offload_register();
+#endif
+
+	regval = readl(mtk->base + EIP93_REG_PE_REVISION);
+
+	dev_info(mtk->dev, "EIP93 Crypto Engine Initialized.");
+	dev_info(mtk->dev, "HW Id: %d Compl: %d HW: %d.%d patch %d\n",
+		(regval & 0xff), ((regval >> 8) & 0x0f),
+		((regval >> 24) & 0x0f), ((regval >> 20) & 0x0f),
+		((regval >> 16) & 0x0f));
+
+	return 0;
+}
+
+static int mtk_crypto_remove(struct platform_device *pdev)
+{
+	struct mtk_device *mtk = platform_get_drvdata(pdev);
+
+	mtk_unregister_algs(ARRAY_SIZE(mtk_algs));
+
+#if IS_ENABLED(CONFIG_CRYPTO_DEV_EIP93_IPSEC)
+	mtk_offload_deregister();
+	tasklet_kill(&mtk->ring->rx_task);
+	tasklet_kill(&mtk->ring->tx_task);
+#endif
+	mtk_cleanup(mtk);
+	dev_info(mtk->dev, "EIP93 removed.\n");
+
+	return 0;
+}
+
+#if defined(CONFIG_OF)
+static const struct of_device_id mtk_crypto_of_match[] = {
+	{ .compatible = "mediatek,mtk-eip93", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, mtk_crypto_of_match);
+#endif
+
+static struct platform_driver mtk_crypto_driver = {
+	.probe = mtk_crypto_probe,
+	.remove = mtk_crypto_remove,
+	.driver = {
+		.name = "mtk-eip93",
+		.of_match_table = mtk_crypto_of_match,
+	},
+};
+module_platform_driver(mtk_crypto_driver);
+
+MODULE_AUTHOR("Richard van Schagen <vschagen@icloud.com>");
+MODULE_ALIAS("platform:" KBUILD_MODNAME);
+MODULE_DESCRIPTION("Mediatek EIP-93 crypto engine driver");
+MODULE_LICENSE("GPL v2");
diff --git a/package/kernel/mtk-eip93/src/eip93-main.h b/package/kernel/mtk-eip93/src/eip93-main.h
new file mode 100644
index 0000000..0b26fc0
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-main.h
@@ -0,0 +1,173 @@
+/* SPDX-License-Identifier: GPL-2.0
+ *
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+#ifndef _EIP93_MAIN_H_
+#define _EIP93_MAIN_H_
+
+#include <crypto/internal/aead.h>
+#include <crypto/internal/hash.h>
+#include <crypto/internal/rng.h>
+#include <crypto/internal/skcipher.h>
+#include <linux/device.h>
+#include <linux/skbuff.h>
+
+#define MTK_RING_SIZE			512
+#define MTK_RING_BUSY			32
+#define MTK_CRA_PRIORITY		1500
+
+/* cipher algorithms */
+#define MTK_ALG_DES			BIT(0)
+#define MTK_ALG_3DES			BIT(1)
+#define MTK_ALG_AES			BIT(2)
+#define MTK_ALG_MASK			GENMASK(2, 0)
+/* hash and hmac algorithms */
+#define MTK_HASH_MD5			BIT(3)
+#define MTK_HASH_SHA1			BIT(4)
+#define MTK_HASH_SHA224			BIT(5)
+#define MTK_HASH_SHA256			BIT(6)
+#define MTK_HASH_HMAC			BIT(7)
+#define MTK_HASH_MASK			GENMASK(6, 3)
+/* cipher modes */
+#define MTK_MODE_CBC			BIT(8)
+#define MTK_MODE_ECB			BIT(9)
+#define MTK_MODE_CTR			BIT(10)
+#define MTK_MODE_RFC3686		BIT(11)
+#define MTK_MODE_MASK			GENMASK(10, 8)
+
+/* cipher encryption/decryption operations */
+#define MTK_ENCRYPT			BIT(12)
+#define MTK_DECRYPT			BIT(13)
+
+#define MTK_BUSY			BIT(14)
+
+/* descriptor flags */
+#define MTK_DESC_ASYNC			BIT(31)
+#define MTK_DESC_SKCIPHER		BIT(30)
+#define MTK_DESC_AEAD			BIT(29)
+#define MTK_DESC_AHASH			BIT(28)
+#define MTK_DESC_PRNG			BIT(27)
+#define MTK_DESC_FAKE_HMAC		BIT(26)
+#define MTK_DESC_LAST			BIT(25)
+#define MTK_DESC_FINISH			BIT(24)
+#define MTK_DESC_IPSEC			BIT(23)
+#define MTK_DESC_DMA_IV			BIT(22)
+#define MTK_DESC_HASH_CACHE		BIT(21)
+
+#define IS_DES(flags)			(flags & MTK_ALG_DES)
+#define IS_3DES(flags)			(flags & MTK_ALG_3DES)
+#define IS_AES(flags)			(flags & MTK_ALG_AES)
+
+#define IS_HASH_MD5(flags)		(flags & MTK_HASH_MD5)
+#define IS_HASH_SHA1(flags)		(flags & MTK_HASH_SHA1)
+#define IS_HASH_SHA224(flags)		(flags & MTK_HASH_SHA224)
+#define IS_HASH_SHA256(flags)		(flags & MTK_HASH_SHA256)
+#define IS_HMAC(flags)			(flags & MTK_HASH_HMAC)
+
+#define IS_CBC(mode)			(mode & MTK_MODE_CBC)
+#define IS_ECB(mode)			(mode & MTK_MODE_ECB)
+#define IS_CTR(mode)			(mode & MTK_MODE_CTR)
+#define IS_RFC3686(mode)		(mode & MTK_MODE_RFC3686)
+
+#define IS_BUSY(flags)			(flags & MTK_BUSY)
+#define IS_DMA_IV(flags)		(flags & MTK_DESC_DMA_IV)
+
+#define IS_ENCRYPT(dir)			(dir & MTK_ENCRYPT)
+#define IS_DECRYPT(dir)			(dir & MTK_DECRYPT)
+
+#define IS_CIPHER(flags)		(flags & (MTK_ALG_DES || \
+						MTK_ALG_3DES ||  \
+						MTK_ALG_AES))
+
+#define IS_HASH(flags)			(flags & (MTK_HASH_MD5 ||  \
+						MTK_HASH_SHA1 ||   \
+						MTK_HASH_SHA224 || \
+						MTK_HASH_SHA256))
+
+/**
+ * struct mtk_device - crypto engine device structure
+ */
+struct mtk_device {
+	void __iomem		*base;
+	struct device		*dev;
+	struct clk		*clk;
+	int			irq;
+	struct mtk_ring		*ring;
+	struct mtk_state_pool	*saState_pool;
+	struct mtk_prng_device	*prng;
+};
+
+struct mtk_prng_device {
+	struct saRecord_s	*PRNGSaRecord;
+	dma_addr_t		PRNGSaRecord_dma;
+	void			*PRNGBuffer[2];
+	dma_addr_t		PRNGBuffer_dma[2];
+	uint32_t		cur_buf;
+	struct completion	Filled;
+	atomic_t		State;
+};
+
+struct mtk_desc_ring {
+	void			*base;
+	void			*base_end;
+	dma_addr_t		base_dma;
+	/* write and read pointers */
+	void			*read;
+	void			*write;
+	/* descriptor element offset */
+	uint32_t		offset;
+};
+
+struct mtk_state_pool {
+	void			*base;
+	dma_addr_t		base_dma;
+	bool			in_use;
+};
+
+struct mtk_ring {
+	spinlock_t			lock;
+
+	struct tasklet_struct		rx_task;
+	struct tasklet_struct		tx_task;
+	struct tasklet_struct		done_task;
+	/* command/result rings */
+	struct mtk_desc_ring		cdr;
+	struct mtk_desc_ring		rdr;
+	spinlock_t			write_lock;
+	spinlock_t			read_lock;
+	atomic_t			free;
+	/* saState */
+	struct mtk_state_pool		*saState_pool;
+	void				*saState;
+	dma_addr_t			saState_dma;
+	/* queue */
+	struct sk_buff_head		rx_queue;
+	struct sk_buff_head		tx_queue;
+	/* Hash buffers */
+	struct mtk_desc_ring		hash_buf;
+};
+
+enum mtk_alg_type {
+	MTK_ALG_TYPE_AEAD,
+	MTK_ALG_TYPE_AHASH,
+	MTK_ALG_TYPE_SKCIPHER,
+	MTK_ALG_TYPE_PRNG,
+};
+
+struct mtk_alg_template {
+	struct mtk_device	*mtk;
+	enum mtk_alg_type	type;
+	u32			flags;
+	union {
+		struct aead_alg		aead;
+		struct ahash_alg	ahash;
+		struct skcipher_alg	skcipher;
+		struct rng_alg		rng;
+	} alg;
+};
+
+void mtk_handle_result_polling(struct mtk_device *mtk);
+
+#endif /* _EIP93_MAIN_H_ */
diff --git a/package/kernel/mtk-eip93/src/eip93-prng.c b/package/kernel/mtk-eip93/src/eip93-prng.c
new file mode 100644
index 0000000..aa1e884
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-prng.c
@@ -0,0 +1,358 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+
+#include <linux/dma-mapping.h>
+
+#include "eip93-common.h"
+#include "eip93-main.h"
+#include "eip93-regs.h"
+#include "eip93-prng.h"
+
+static int mtk_prng_push_job(struct mtk_device *mtk, bool reset)
+{
+	struct mtk_prng_device *prng = mtk->prng;
+	struct eip93_descriptor_s cdesc;
+	int cur = prng->cur_buf;
+	int len, mode, err;
+
+	if (reset) {
+		len = 0;
+		mode = 1;
+	} else {
+		len = 4080;
+		mode = 2;
+	}
+
+	init_completion(&prng->Filled);
+	atomic_set(&prng->State, BUF_EMPTY);
+
+	memset(&cdesc, 0, sizeof(struct eip93_descriptor_s));
+	cdesc.peCrtlStat.bits.hostReady = 1;
+	cdesc.peCrtlStat.bits.prngMode = mode;
+	cdesc.peCrtlStat.bits.hashFinal = 0;
+	cdesc.peCrtlStat.bits.padCrtlStat = 0;
+	cdesc.peCrtlStat.bits.peReady = 0;
+	cdesc.srcAddr = 0;
+	cdesc.dstAddr = prng->PRNGBuffer_dma[cur];
+	cdesc.saAddr = prng->PRNGSaRecord_dma;
+	cdesc.stateAddr = 0;
+	cdesc.arc4Addr = 0;
+	cdesc.userId = MTK_DESC_PRNG | MTK_DESC_LAST | MTK_DESC_FINISH;
+	cdesc.peLength.bits.byPass = 0;
+	cdesc.peLength.bits.length = 4080;
+	cdesc.peLength.bits.hostReady = 1;
+
+	err = mtk_put_descriptor(mtk, &cdesc);
+	/* TODO error handling */
+	if (err)
+		dev_err(mtk->dev, "PRNG: No Descriptor space");
+
+	writel(1, mtk->base + EIP93_REG_PE_CD_COUNT);
+
+	wait_for_completion(&prng->Filled);
+
+//	if (atomic_read(&prng->State) == PRNG_NEED_RESET)
+//		return false;
+
+	return true;
+}
+
+/*----------------------------------------------------------------------------
+ * mtk_prng_init
+ *
+ * This function initializes the PE PRNG for the ARM mode.
+ *
+ * Return Value
+ *      true: PRNG is initialized
+ *     false: PRNG initialization failed
+ */
+bool mtk_prng_init(struct mtk_device *mtk, bool fLongSA)
+{
+	struct mtk_prng_device *prng = mtk->prng;
+	int i, ret;
+	struct saRecord_s *saRecord;
+	const uint32_t PRNGKey[]  = {0xe0fc631d, 0xcbb9fb9a,
+					0x869285cb, 0xcbb9fb9a};
+	const uint32_t PRNGSeed[]  = {0x758bac03, 0xf20ab39e,
+					0xa569f104, 0x95dfaea6};
+	const uint32_t PRNGDateTime[] = {0, 0, 0, 0};
+
+	if (!mtk)
+		return -ENODEV;
+
+	prng->cur_buf = 0;
+	/* TODO: check to kzalloc and create free after remove */
+	prng->PRNGBuffer[0] = devm_kzalloc(mtk->dev, 4080, GFP_KERNEL);
+	prng->PRNGBuffer_dma[0] = (u32)dma_map_single(mtk->dev,
+				(void *)prng->PRNGBuffer[0],
+				4080, DMA_FROM_DEVICE);
+
+	prng->PRNGBuffer[1] = devm_kzalloc(mtk->dev, 4080, GFP_KERNEL);
+	prng->PRNGBuffer_dma[1] = (u32)dma_map_single(mtk->dev,
+				(void *)prng->PRNGBuffer[1],
+				4080, DMA_FROM_DEVICE);
+
+	prng->PRNGSaRecord = dmam_alloc_coherent(mtk->dev,
+				sizeof(struct saRecord_s),
+				&prng->PRNGSaRecord_dma, GFP_KERNEL);
+
+	if (!prng->PRNGSaRecord) {
+		dev_err(mtk->dev, "PRNG dma_alloc for saRecord failed\n");
+		return -ENOMEM;
+	}
+
+	saRecord = &prng->PRNGSaRecord[0];
+
+	saRecord->saCmd0.word = 0x00001307;
+	saRecord->saCmd1.word = 0x02000000;
+
+	for (i = 0; i < 4; i++) {
+		saRecord->saKey[i] = PRNGKey[i];
+		saRecord->saIDigest[i] = PRNGSeed[i];
+		saRecord->saODigest[i] = PRNGDateTime[i];
+	}
+
+	return mtk_prng_push_job(mtk, true);
+}
+
+void mtk_prng_done(struct mtk_device *mtk, u32 err)
+{
+	struct mtk_prng_device *prng = mtk->prng;
+	int cur = prng->cur_buf;
+
+	if (err) {
+		dev_err(mtk->dev, "PRNG error: %d\n", err);
+		atomic_set(&prng->State, PRNG_NEED_RESET);
+	}
+
+	/* Buffer refilled, invalidate cache */
+	dma_unmap_single(mtk->dev, prng->PRNGBuffer_dma[cur],
+							4080, DMA_FROM_DEVICE);
+
+	complete(&prng->Filled);
+}
+
+static int get_prng_bytes(char *buf, size_t nbytes, struct mtk_prng_ctx *ctx,
+				int do_cont_test)
+{
+	int err;
+
+	spin_lock(&ctx->prng_lock);
+
+	err = -EINVAL;
+	if (ctx->flags & PRNG_NEED_RESET)
+		goto done;
+
+done:
+	spin_unlock(&ctx->prng_lock);
+	return err;
+}
+
+static int mtk_prng_generate(struct crypto_rng *tfm, const u8 *src,
+			   unsigned int slen, u8 *dst, unsigned int dlen)
+{
+	struct mtk_prng_ctx *prng = crypto_rng_ctx(tfm);
+
+	return get_prng_bytes(dst, dlen, prng, 1);
+}
+
+static int mtk_prng_seed(struct crypto_rng *tfm, const u8 *seed,
+		       unsigned int slen)
+{
+	struct rng_alg *alg = crypto_rng_alg(tfm);
+	struct mtk_alg_template *tmpl = container_of(alg,
+				struct mtk_alg_template, alg.rng);
+	struct mtk_device *mtk = tmpl->mtk;
+
+	return 0;
+}
+
+static bool mtk_prng_fill_buffer(struct mtk_device *mtk)
+{
+	struct mtk_prng_device *prng = mtk->prng;
+	int cur = prng->cur_buf;
+	int ret;
+
+	if (!mtk)
+		return -ENODEV;
+
+	/* add logic for 2 buffers and swap */
+	prng->PRNGBuffer_dma[cur] = (u32)dma_map_single(mtk->dev,
+					(void *)prng->PRNGBuffer[cur],
+					4080, DMA_FROM_DEVICE);
+
+	ret = mtk_prng_push_job(mtk, false);
+
+	return ret;
+}
+
+static int reset_prng_context(struct mtk_prng_ctx *ctx,
+				const unsigned char *key,
+				const unsigned char *V,
+				const unsigned char *DT)
+{
+	spin_lock_bh(&ctx->prng_lock);
+	ctx->flags |= PRNG_NEED_RESET;
+
+	if (key)
+		memcpy(ctx->PRNGKey, key, DEFAULT_PRNG_KSZ);
+	else
+		memcpy(ctx->PRNGKey, DEFAULT_PRNG_KEY, DEFAULT_PRNG_KSZ);
+
+
+	if (V)
+		memcpy(ctx->PRNGSeed, V, DEFAULT_BLK_SZ);
+	else
+		memcpy(ctx->PRNGSeed, DEFAULT_V_SEED, DEFAULT_BLK_SZ);
+
+	if (DT)
+		memcpy(ctx->PRNGDateTime, DT, DEFAULT_BLK_SZ);
+	else
+		memset(ctx->PRNGDateTime, 0, DEFAULT_BLK_SZ);
+
+	memset(ctx->rand_data, 0, DEFAULT_BLK_SZ);
+	memset(ctx->last_rand_data, 0, DEFAULT_BLK_SZ);
+
+	ctx->rand_data_valid = DEFAULT_BLK_SZ;
+
+	ctx->flags &= ~PRNG_NEED_RESET;
+	spin_unlock_bh(&ctx->prng_lock);
+
+	return 0;
+}
+
+/*
+ *  This is the cprng_registered reset method the seed value is
+ *  interpreted as the tuple { V KEY DT}
+ *  V and KEY are required during reset, and DT is optional, detected
+ *  as being present by testing the length of the seed
+ */
+static int cprng_reset(struct crypto_rng *tfm,
+		       const u8 *seed, unsigned int slen)
+{
+	struct mtk_prng_ctx *prng = crypto_rng_ctx(tfm);
+	const u8 *key = seed + DEFAULT_BLK_SZ;
+	const u8 *dt = NULL;
+
+	if (slen < DEFAULT_PRNG_KSZ + DEFAULT_BLK_SZ)
+		return -EINVAL;
+
+	if (slen >= (2 * DEFAULT_BLK_SZ + DEFAULT_PRNG_KSZ))
+		dt = key + DEFAULT_PRNG_KSZ;
+
+	reset_prng_context(prng, key, seed, dt);
+
+	if (prng->flags & PRNG_NEED_RESET)
+		return -EINVAL;
+	return 0;
+}
+
+
+static void free_prng_context(struct mtk_prng_ctx *ctx)
+{
+	crypto_free_cipher(ctx->tfm);
+}
+
+static int cprng_init(struct crypto_tfm *tfm)
+{
+	struct mtk_prng_ctx *ctx = crypto_tfm_ctx(tfm);
+
+	spin_lock_init(&ctx->prng_lock);
+
+	if (reset_prng_context(ctx, NULL, NULL, NULL) < 0)
+		return -EINVAL;
+
+	/*
+	 * after allocation, we should always force the user to reset
+	 * so they don't inadvertently use the insecure default values
+	 * without specifying them intentially
+	 */
+	ctx->flags |= PRNG_NEED_RESET;
+	return 0;
+}
+
+static void cprng_exit(struct crypto_tfm *tfm)
+{
+	free_prng_context(crypto_tfm_ctx(tfm));
+}
+
+struct mtk_alg_template mtk_alg_prng = {
+	.type = MTK_ALG_TYPE_PRNG,
+	.flags = 0,
+	.alg.rng = {
+		.generate = mtk_prng_generate,
+		.seed = mtk_prng_seed,
+		.seedsize = 0,
+		.base = {
+			.cra_name = "stdrng",
+			.cra_driver_name = "eip93-prng",
+			.cra_priority = 200,
+			.cra_ctxsize = sizeof(struct mtk_prng_ctx),
+			.cra_module = THIS_MODULE,
+			.cra_init = cprng_init,
+			.cra_exit = cprng_exit,
+		},
+	},
+};
+
+//#if IS_ENABLED(CONFIG_CRYPTO_FIPS
+static int fips_cprng_get_random(struct crypto_rng *tfm,
+				 const u8 *src, unsigned int slen,
+				 u8 *rdata, unsigned int dlen)
+{
+	struct mtk_prng_ctx *prng = crypto_rng_ctx(tfm);
+
+	return get_prng_bytes(rdata, dlen, prng, 1);
+}
+
+static int fips_cprng_reset(struct crypto_rng *tfm,
+			    const u8 *seed, unsigned int slen)
+{
+	struct mtk_prng_ctx *prng = crypto_rng_ctx(tfm);
+	u8 rdata[DEFAULT_BLK_SZ];
+	const u8 *key = seed + DEFAULT_BLK_SZ;
+	int rc;
+
+	if (slen < DEFAULT_PRNG_KSZ + DEFAULT_BLK_SZ)
+		return -EINVAL;
+
+	/* fips strictly requires seed != key */
+	if (!memcmp(seed, key, DEFAULT_PRNG_KSZ))
+		return -EINVAL;
+
+	rc = cprng_reset(tfm, seed, slen);
+
+	if (!rc)
+		goto out;
+
+	/* this primes our continuity test */
+	rc = get_prng_bytes(rdata, DEFAULT_BLK_SZ, prng, 0);
+	prng->rand_data_valid = DEFAULT_BLK_SZ;
+
+out:
+	return rc;
+}
+
+struct mtk_alg_template mtk_alg_cprng = {
+	.type = MTK_ALG_TYPE_PRNG,
+	.flags = 0,
+	.alg.rng = {
+		.generate = fips_cprng_get_random,
+		.seed = fips_cprng_reset,
+		.seedsize = DEFAULT_PRNG_KSZ + 2 * DEFAULT_BLK_SZ,
+		.base = {
+			.cra_name = "fips(ansi_cprng)",
+			.cra_driver_name = "eip93-fips_ansi_cprng",
+			.cra_priority = 300,
+			.cra_ctxsize = sizeof(struct mtk_prng_ctx),
+			.cra_module = THIS_MODULE,
+			.cra_init = cprng_init,
+			.cra_exit = cprng_exit,
+		},
+	},
+};
+//#endif
diff --git a/package/kernel/mtk-eip93/src/eip93-prng.h b/package/kernel/mtk-eip93/src/eip93-prng.h
new file mode 100644
index 0000000..064bed1
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-prng.h
@@ -0,0 +1,34 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+#define DEFAULT_PRNG_KEY "0123456789abcdef"
+#define DEFAULT_PRNG_KSZ 16
+#define DEFAULT_BLK_SZ 16
+#define DEFAULT_V_SEED "zaybxcwdveuftgsh"
+
+#define BUF_NOT_EMPTY 0
+#define BUF_EMPTY 1
+#define BUF_PENDING 2
+#define PRNG_NEED_RESET 3
+
+extern struct mtk_alg_template mtk_alg_prng;
+extern struct mtk_alg_template mtk_alg_cprng;
+
+bool mtk_prng_init(struct mtk_device *mtk, bool fLongSA);
+
+void mtk_prng_done(struct mtk_device *mtk, u32 err);
+
+struct mtk_prng_ctx {
+	spinlock_t		prng_lock;
+	unsigned char		rand_data[DEFAULT_BLK_SZ];
+	unsigned char		last_rand_data[DEFAULT_BLK_SZ];
+	uint32_t		PRNGKey[4];
+	uint32_t		PRNGSeed[4];
+	uint32_t		PRNGDateTime[4];
+	struct crypto_cipher	*tfm;
+	uint32_t		rand_data_valid;
+	uint32_t		flags;
+};
diff --git a/package/kernel/mtk-eip93/src/eip93-regs.h b/package/kernel/mtk-eip93/src/eip93-regs.h
new file mode 100644
index 0000000..7e18d4c
--- /dev/null
+++ b/package/kernel/mtk-eip93/src/eip93-regs.h
@@ -0,0 +1,383 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2019 - 2021
+ *
+ * Richard van Schagen <vschagen@icloud.com>
+ */
+#ifndef REG_EIP93_H
+#define REG_EIP93_H
+
+#define EIP93_REG_WIDTH			4
+/*-----------------------------------------------------------------------------
+ * Register Map
+ */
+#define DESP_BASE			0x0000000
+#define EIP93_REG_PE_CTRL_STAT		((DESP_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_SOURCE_ADDR	((DESP_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_DEST_ADDR		((DESP_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_SA_ADDR		((DESP_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_ADDR		((DESP_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_USER_ID		((DESP_BASE)+(0x06 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_LENGTH		((DESP_BASE)+(0x07 * EIP93_REG_WIDTH))
+
+//PACKET ENGINE RING configuration registers
+#define PE_RNG_BASE			0x0000080
+
+#define EIP93_REG_PE_CDR_BASE		((PE_RNG_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RDR_BASE		((PE_RNG_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RING_CONFIG	((PE_RNG_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RING_THRESH	((PE_RNG_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_CD_COUNT		((PE_RNG_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RD_COUNT		((PE_RNG_BASE)+(0x05 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_RING_RW_PNTR	((PE_RNG_BASE)+(0x06 * EIP93_REG_WIDTH))
+
+//PACKET ENGINE  configuration registers
+#define PE_CFG_BASE			0x0000100
+#define EIP93_REG_PE_CONFIG		((PE_CFG_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_STATUS		((PE_CFG_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_BUF_THRESH		((PE_CFG_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_INBUF_COUNT	((PE_CFG_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_OUTBUF_COUNT	((PE_CFG_BASE)+(0x05 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_BUF_RW_PNTR	((PE_CFG_BASE)+(0x06 * EIP93_REG_WIDTH))
+
+//PACKET ENGINE endian config
+#define EN_CFG_BASE			0x00001CC
+#define EIP93_REG_PE_ENDIAN_CONFIG	((EN_CFG_BASE)+(0x00 * EIP93_REG_WIDTH))
+
+//EIP93 CLOCK control registers
+#define CLOCK_BASE			0x01E8
+#define EIP93_REG_PE_CLOCK_CTRL		((CLOCK_BASE)+(0x00 * EIP93_REG_WIDTH))
+
+//EIP93 Device Option and Revision Register
+#define REV_BASE			0x01F4
+#define EIP93_REG_PE_OPTION_1		((REV_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_OPTION_0		((REV_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PE_REVISION		((REV_BASE)+(0x02 * EIP93_REG_WIDTH))
+
+//EIP93 Interrupt Control Register
+#define INT_BASE			0x0200
+#define EIP93_REG_INT_UNMASK_STAT	((INT_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_MASK_STAT		((INT_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_CLR		((INT_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_MASK		((INT_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_INT_CFG		((INT_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_MASK_ENABLE		((INT_BASE)+(0X04 * EIP93_REG_WIDTH))
+#define EIP93_REG_MASK_DISABLE		((INT_BASE)+(0X05 * EIP93_REG_WIDTH))
+
+//EIP93 SA Record register
+#define SA_BASE				0x0400
+#define EIP93_REG_SA_CMD_0		((SA_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_SA_CMD_1		((SA_BASE)+(0x01 * EIP93_REG_WIDTH))
+
+//#define EIP93_REG_SA_READY		((SA_BASE)+(31 * EIP93_REG_WIDTH))
+
+//State save register
+#define STATE_BASE			0x0500
+#define EIP93_REG_STATE_IV_0		((STATE_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_STATE_IV_1		((STATE_BASE)+(0x01 * EIP93_REG_WIDTH))
+
+#define EIP93_PE_ARC4STATE_BASEADDR_REG	0x0700
+
+//RAM buffer start address
+#define EIP93_INPUT_BUFFER		0x0800
+#define EIP93_OUTPUT_BUFFER		0x0800
+
+//EIP93 PRNG Configuration Register
+#define PRNG_BASE			0x0300
+#define EIP93_REG_PRNG_STAT		((PRNG_BASE)+(0x00 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_CTRL		((PRNG_BASE)+(0x01 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_0		((PRNG_BASE)+(0x02 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_1		((PRNG_BASE)+(0x03 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_2		((PRNG_BASE)+(0x04 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_SEED_3		((PRNG_BASE)+(0x05 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_0		((PRNG_BASE)+(0x06 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_1		((PRNG_BASE)+(0x07 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_2		((PRNG_BASE)+(0x08 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_KEY_3		((PRNG_BASE)+(0x09 * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_0		((PRNG_BASE)+(0x0A * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_1		((PRNG_BASE)+(0x0B * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_2		((PRNG_BASE)+(0x0C * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_RES_3		((PRNG_BASE)+(0x0D * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_LFSR_0		((PRNG_BASE)+(0x0E * EIP93_REG_WIDTH))
+#define EIP93_REG_PRNG_LFSR_1		((PRNG_BASE)+(0x0F * EIP93_REG_WIDTH))
+
+/*-----------------------------------------------------------------------------
+ * Constants & masks
+ */
+
+#define EIP93_SUPPORTED_INTERRUPTS_MASK	0xffff7f00
+#define EIP93_PRNG_DT_TEXT_LOWERHALF	0xDEAD
+#define EIP93_PRNG_DT_TEXT_UPPERHALF	0xC0DE
+#define EIP93_10BITS_MASK		0X3FF
+#define EIP93_12BITS_MASK		0XFFF
+#define EIP93_4BITS_MASK		0X04
+#define EIP93_20BITS_MASK		0xFFFFF
+
+#define EIP93_MIN_DESC_DONE_COUNT	0
+#define EIP93_MAX_DESC_DONE_COUNT	15
+
+#define EIP93_MIN_DESC_PENDING_COUNT	0
+#define EIP93_MAX_DESC_PENDING_COUNT	1023
+
+#define EIP93_MIN_TIMEOUT_COUNT		0
+#define EIP93_MAX_TIMEOUT_COUNT		15
+
+#define EIP93_MIN_PE_INPUT_THRESHOLD	1
+#define EIP93_MAX_PE_INPUT_THRESHOLD	511
+
+#define EIP93_MIN_PE_OUTPUT_THRESHOLD	1
+#define EIP93_MAX_PE_OUTPUT_THRESHOLD	432
+
+#define EIP93_MIN_PE_RING_SIZE		1
+#define EIP93_MAX_PE_RING_SIZE		1023
+
+#define EIP93_MIN_PE_DESCRIPTOR_SIZE	7
+#define EIP93_MAX_PE_DESCRIPTOR_SIZE	15
+
+//3DES keys,seed,known data and its result
+#define EIP93_KEY_0			0x133b3454
+#define EIP93_KEY_1			0x5e5b890b
+#define EIP93_KEY_2			0x5eb30757
+#define EIP93_KEY_3			0x93ab15f7
+#define EIP93_SEED_0			0x62c4bf5e
+#define EIP93_SEED_1			0x972667c8
+#define EIP93_SEED_2			0x6345bf67
+#define EIP93_SEED_3			0xcb3482bf
+#define EIP93_LFSR_0			0xDEADC0DE
+#define EIP93_LFSR_1			0xBEEFF00D
+
+/*-----------------------------------------------------------------------------
+ * EIP93 device initialization specifics
+ */
+
+/*----------------------------------------------------------------------------
+ * Byte Order Reversal Mechanisms Supported in EIP93
+ * EIP93_BO_REVERSE_HALF_WORD : reverse the byte order within a half-word
+ * EIP93_BO_REVERSE_WORD :  reverse the byte order within a word
+ * EIP93_BO_REVERSE_DUAL_WORD : reverse the byte order within a dual-word
+ * EIP93_BO_REVERSE_QUAD_WORD : reverse the byte order within a quad-word
+ */
+enum EIP93_Byte_Order_Value_t {
+    EIP93_BO_REVERSE_HALF_WORD = 1,
+    EIP93_BO_REVERSE_WORD = 2,
+    EIP93_BO_REVERSE_DUAL_WORD = 4,
+    EIP93_BO_REVERSE_QUAD_WORD = 8,
+};
+
+/*----------------------------------------------------------------------------
+ * Byte Order Reversal Mechanisms Supported in EIP93 for Target Data
+ * EIP93_BO_REVERSE_HALF_WORD : reverse the byte order within a half-word
+ * EIP93_BO_REVERSE_WORD :  reverse the byte order within a word
+ */
+enum EIP93_Byte_Order_Value_TD_t {
+    EIP93_BO_REVERSE_HALF_WORD_TD = 1,
+    EIP93_BO_REVERSE_WORD_TD = 2,
+};
+
+// BYTE_ORDER_CFG register values
+#define EIP93_BYTE_ORDER_PD		EIP93_BO_REVERSE_WORD
+#define EIP93_BYTE_ORDER_SA		EIP93_BO_REVERSE_WORD
+#define EIP93_BYTE_ORDER_DATA		EIP93_BO_REVERSE_WORD
+#define EIP93_BYTE_ORDER_TD		EIP93_BO_REVERSE_WORD_TD
+
+// INT_CFG register values
+#define EIP93_INT_HOST_OUTPUT_TYPE	0	// 0 = Level
+#define EIP93_INT_PULSE_CLEAR		0	// 0 = Manual clear
+
+/*
+ * Interrupts of EIP93
+ */
+
+enum EIP93_InterruptSource_t {
+	EIP93_INT_PE_CDRTHRESH_REQ =	BIT(0),
+	EIP93_INT_PE_RDRTHRESH_REQ =	BIT(1),
+	EIP93_INT_PE_OPERATION_DONE =	BIT(9),
+	EIP93_INT_PE_INBUFTHRESH_REQ =	BIT(10),
+	EIP93_INT_PE_OUTBURTHRSH_REQ =	BIT(11),
+	EIP93_INT_PE_PRNG_IRQ =		BIT(12),
+	EIP93_INT_PE_ERR_REG =		BIT(13),
+	EIP93_INT_PE_RD_DONE_IRQ =	BIT(16),
+};
+
+
+union peConfig_w {
+	u32 word;
+	struct {
+		u32 resetPE		:1;
+		u32 resetRing		:1;
+		u32 reserved		:6;
+		u32 peMode		:2;
+		u32 enCDRupdate		:1;
+		u32 reserved2		:5;
+		u32 swapCDRD		:1;
+		u32 swapSA		:1;
+		u32 swapData		:1;
+		u32 reserved3		:13;
+	} bits;
+} __packed;
+
+union peEndianCfg_w {
+	u32 word;
+	struct {
+		u32 masterByteSwap	:8;
+		u32 reserved		:8;
+		u32 targetByteSwap	:8;
+		u32 reserved2		:8;
+	} bits;
+} __packed;
+
+union peIntCfg_w {
+	u32 word;
+	struct {
+		u32 PulseClear		:1;
+		u32 IntType		:1;
+		u32 reserved		:30;
+	} bits;
+} __packed;
+
+union peClockCfg_w {
+	u32 word;
+	struct {
+		u32 enPEclk		:1;
+		u32 enDESclk		:1;
+		u32 enAESclk		:1;
+		u32 reserved		:1;
+		u32 enHASHclk		:1;
+		u32 reserved2		:27;
+	} bits;
+} __packed;
+
+union peBufThresh_w {
+	u32 word;
+	struct {
+		u32 inputBuffer		:8;
+		u32 reserved		:8;
+		u32 outputBuffer	:8;
+		u32 reserved2		:8;
+	} bits;
+} __packed;
+
+union peRingThresh_w {
+	u32 word;
+	struct {
+		u32 CDRThresh		:10;
+		u32 reserved		:6;
+		u32 RDRThresh		:10;
+		u32 RDTimeout		:4;
+		u32 reserved2		:1;
+		u32 enTimeout		:1;
+	} bits;
+} __packed;
+
+union peRingCfg_w {
+	u32 word;
+	struct {
+		u32 ringSize		:10;
+		u32 reserved		:6;
+		u32 ringOffset		:8;
+		u32 reserved2		:8;
+	} bits;
+} __packed;
+
+union saCmd0 {
+	u32	word;
+	struct {
+		u32 opCode		:3;
+		u32 direction		:1;
+		u32 opGroup		:2;
+		u32 padType		:2;
+		u32 cipher		:4;
+		u32 hash		:4;
+		u32 reserved2		:1;
+		u32 scPad		:1;
+		u32 extPad		:1;
+		u32 hdrProc		:1;
+		u32 digestLength	:4;
+		u32 ivSource		:2;
+		u32 hashSource		:2;
+		u32 saveIv		:1;
+		u32 saveHash		:1;
+		u32 reserved1		:2;
+	} bits;
+} __packed;
+
+union saCmd1 {
+	u32	word;
+	struct {
+		u32 copyDigest		:1;
+		u32 copyHeader		:1;
+		u32 copyPayload		:1;
+		u32 copyPad		:1;
+		u32 reserved4		:4;
+		u32 cipherMode		:2;
+		u32 reserved3		:1;
+		u32 sslMac		:1;
+		u32 hmac		:1;
+		u32 byteOffset		:1;
+		u32 reserved2		:2;
+		u32 hashCryptOffset	:8;
+		u32 aesKeyLen		:3;
+		u32 reserved1		:1;
+		u32 aesDecKey		:1;
+		u32 seqNumCheck		:1;
+		u32 reserved0		:2;
+	} bits;
+} __packed;
+
+struct saRecord_s {
+	union saCmd0	saCmd0;
+	union saCmd1	saCmd1;
+	u32		saKey[8];
+	u32		saIDigest[8];
+	u32		saODigest[8];
+	u32		saSpi;
+	u32		saSeqNum[2];
+	u32		saSeqNumMask[2];
+	u32		saNonce;
+} __packed;
+
+struct saState_s {
+	u32		stateIv[4];
+	u32		stateByteCnt[2];
+	u32		stateIDigest[8];
+} __packed;
+
+union peCrtlStat_w {
+	u32 word;
+	struct {
+		u32 hostReady		:1;
+		u32 peReady		:1;
+		u32 reserved		:1;
+		u32 initArc4		:1;
+		u32 hashFinal		:1;
+		u32 haltMode		:1;
+		u32 prngMode		:2;
+		u32 padValue		:8;
+		u32 errStatus		:8;
+		u32 padCrtlStat		:8;
+	} bits;
+} __packed;
+
+union peLength_w {
+	u32 word;
+	struct {
+		u32 length		:20;
+		u32 reserved		:2;
+		u32 hostReady		:1;
+		u32 peReady		:1;
+		u32 byPass		:8;
+	} bits;
+} __packed;
+
+struct eip93_descriptor_s {
+	union peCrtlStat_w	peCrtlStat;
+	u32			srcAddr;
+	u32			dstAddr;
+	u32			saAddr;
+	u32			stateAddr;
+	u32			arc4Addr;
+	u32			userId;
+	union peLength_w	peLength;
+} __packed;
+
+#endif
diff --git a/package/rdloader/Makefile b/package/rdloader/Makefile
new file mode 100644
index 0000000..fc115b0
--- /dev/null
+++ b/package/rdloader/Makefile
@@ -0,0 +1,54 @@
+include $(TOPDIR)/rules.mk
+
+PKG_NAME := rdloader
+PKG_VERSION := 1.0.1
+PKG_RELEASE := 1
+
+PKG_BUILD_DEPENDS := util-linux e2fsprogs
+
+include $(INCLUDE_DIR)/package.mk
+include $(INCLUDE_DIR)/cmake.mk
+
+define Package/rdloader
+	SECTION:=base
+	CATEGORY:=Base system
+	TITLE:= Lightweight kmod loader for ramdisk enviroment
+	DEPENDS:= +libblkid +e2fsprogs
+endef
+
+define Package/rdloader/description
+	Lightweight kmod loader for ramdisk enviroment, support uuid-based rootfs mount
+endef
+
+define Build/Prepare
+	mkdir -p $(PKG_BUILD_DIR)
+	$(CP) ./src/* $(PKG_BUILD_DIR)/
+endef
+
+define Build/InstallDev
+	rm -fR $(STAGING_DIR)/rdloader
+	mkdir -p $(STAGING_DIR)/rdloader/{bin,lib,etc}
+
+	$(CP) $(PKG_BUILD_DIR)/rdloader $(STAGING_DIR)/rdloader/bin/
+	$(CP) $(STAGING_DIR_ROOT)/usr/sbin/e2fsck $(STAGING_DIR)/rdloader/bin/
+	$(CP) $(STAGING_DIR_ROOT)/etc/e2fsck.conf $(STAGING_DIR)/rdloader/etc/
+
+	( \
+		export \
+			READELF=$(TARGET_CROSS)readelf \
+			OBJCOPY=$(TARGET_CROSS)objcopy \
+			XARGS="$(XARGS)"; \
+		find $(STAGING_DIR)/rdloader/bin/ -type f -a -exec \
+		$(SCRIPT_DIR)/gen-rddependencies.sh {} \; ; \
+	) | while read FILE; do \
+		cp $(STAGING_DIR_ROOT)/lib/$$$$FILE $(STAGING_DIR)/rdloader/lib/ || \
+		cp $(STAGING_DIR_ROOT)/usr/lib/$$$$FILE $(STAGING_DIR)/rdloader/lib/ \
+		; \
+	done;
+endef
+
+TARGET_LDFLAGS += 
+
+CMAKE_OPTIONS += -DCMAKE_BUILD_TYPE=Release
+
+$(eval $(call BuildPackage,rdloader))
diff --git a/package/rdloader/src/CMakeLists.txt b/package/rdloader/src/CMakeLists.txt
new file mode 100644
index 0000000..9076772
--- /dev/null
+++ b/package/rdloader/src/CMakeLists.txt
@@ -0,0 +1,9 @@
+cmake_minimum_required(VERSION 3.15)
+set(CMAKE_C_STANDARD 99)
+project(rdloader C)
+
+add_executable(rdloader main.c insmod.c insmod.h mknod.c mknod.h mkdev_node.c mkdev_node.h blkid2.c blkid2.h cmdline.c cmdline.h switch_root.c switch_root.h)
+
+target_link_libraries(${PROJECT_NAME} blkid)
+
+install(TARGETS rdloader RUNTIME DESTINATION /usr/sbin)
diff --git a/package/rdloader/src/LICENSE b/package/rdloader/src/LICENSE
new file mode 100644
index 0000000..e72bfdd
--- /dev/null
+++ b/package/rdloader/src/LICENSE
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<https://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<https://www.gnu.org/licenses/why-not-lgpl.html>.
\ No newline at end of file
diff --git a/package/rdloader/src/blkid2.c b/package/rdloader/src/blkid2.c
new file mode 100644
index 0000000..91b79d6
--- /dev/null
+++ b/package/rdloader/src/blkid2.c
@@ -0,0 +1,40 @@
+//
+// Created by juno on 2022/1/11.
+//
+
+#include <stdio.h>
+#include <blkid/blkid.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include "blkid2.h"
+
+int get_blkid(const char *blkdev, char **uuid)
+{
+    blkid_probe pr;
+    int ret;
+    size_t len;
+    const char *data;
+    void *out;
+
+    pr = blkid_new_probe_from_filename(blkdev);
+    if (!pr)
+    {
+        fprintf(stderr, "Failed open %s:%s\n", blkdev, strerror(errno));
+        return -1;
+    }
+
+    blkid_do_probe(pr);
+    ret = blkid_probe_lookup_value(pr, "UUID", &data, &len);
+
+    if (ret == 0)
+    {
+        out = calloc(1, len + 1);
+        memcpy(out, data, len);
+        *uuid = out;
+    }
+
+    blkid_free_probe(pr);
+
+    return ret;
+}
diff --git a/package/rdloader/src/blkid2.h b/package/rdloader/src/blkid2.h
new file mode 100644
index 0000000..79e1636
--- /dev/null
+++ b/package/rdloader/src/blkid2.h
@@ -0,0 +1,10 @@
+//
+// Created by juno on 2022/1/11.
+//
+
+#ifndef INIT_BLKID2_H
+#define INIT_BLKID2_H
+
+int get_blkid(const char *blkdev, char **uuid);
+
+#endif //INIT_BLKID2_H
diff --git a/package/rdloader/src/cmdline.c b/package/rdloader/src/cmdline.c
new file mode 100644
index 0000000..858d6a8
--- /dev/null
+++ b/package/rdloader/src/cmdline.c
@@ -0,0 +1,204 @@
+//
+// Created by juno on 2022/1/11.
+//
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "cmdline.h"
+
+static void insert_fstype_tail(struct fstype **head, struct fstype *fs)
+{
+    struct fstype *curr = *head;
+    struct fstype *next = NULL;
+
+    if (!curr)
+    {
+        *head = fs;
+        return;
+    }
+
+    do
+    {
+        next = curr->next;
+        if (!next)
+        {
+            curr->next = fs;
+            break;
+        }
+        curr = next;
+    } while (curr);
+}
+
+static int parse_root(char *args, char **ret)
+{
+    char *root = NULL;
+
+    if (!args)
+        return -1;
+
+    root = strtok(args, "=");
+    root = strtok(NULL, "=");
+    if (!root)
+        return -1;
+
+    if (strcmp(root, "PARTUUID") == 0)
+    {
+        root = strtok(NULL, "=");
+        if (!root)
+            return -1;
+
+        asprintf(ret, "/dev/disk/by-partuuid/%s", root);
+    }
+    else if (strcmp(args, "UUID") == 0)
+    {
+        root = strtok(NULL, "=");
+        if (!root)
+            return -1;
+
+        asprintf(ret, "/dev/disk/by-uuid/%s", root);
+    }
+    else
+    {
+        *ret = strdup(root);
+    }
+
+    return 0;
+}
+
+struct fstype *parse_rootfs(char **fstype_list)
+{
+    struct fstype *ret = NULL;
+    char *list = *fstype_list;
+    struct fstype *default_fs = NULL;
+    struct fstype *fs = NULL;
+
+    if (list)
+    {
+        list = strtok(list, "=");
+
+        while ((list = strtok(NULL, ",")))
+        {
+            fs = calloc(1, sizeof(struct fstype));
+
+            if (!fs)
+                return NULL;
+
+            fs->name = strdup(list);
+            insert_fstype_tail(&ret, fs);
+        }
+    }
+
+    default_fs = calloc(1, sizeof(struct fstype));
+    default_fs->name = strdup("ext4");
+    insert_fstype_tail(&ret, default_fs);
+
+    return ret;
+}
+
+int parse_cmdline(struct bootargs_t **ret)
+{
+    FILE *fp;
+    char *cmdline = NULL;
+    struct fstype *fs = NULL;
+    char str[1024] = {0};
+    char *root = NULL;
+    char *rootfs = NULL;
+    struct bootargs_t *bootargs = NULL;
+
+    fp = fopen("/proc/cmdline", "r");
+
+    if (!fp)
+    {
+        fprintf(stderr, "get cmdline failed:%s\n", strerror(errno));
+        return -1;
+    }
+
+    if (fgets(str, sizeof(str) - 1, fp) == NULL)
+    {
+        fprintf(stderr, "cmdline empty\n");
+        fclose(fp);
+        return -1;
+    }
+
+    fclose(fp);
+
+    cmdline = strtok(str, " ");
+
+    do
+    {
+        if (!cmdline)
+            continue;
+
+        if (strstr(cmdline, "root="))
+            root = cmdline;
+        if (strstr(cmdline, "rootfstype="))
+            rootfs = cmdline;
+
+    } while ((cmdline = strtok(NULL, " ")) != NULL);
+
+    if (parse_root(root, &root) < 0)
+    {
+        fprintf(stderr, "root args error\n");
+        return -1;
+    }
+
+    if ((fs = parse_rootfs(&rootfs)) == NULL)
+    {
+        fprintf(stderr, "fstype error\n");
+        return -1;
+    }
+
+    bootargs = calloc(1, sizeof(struct bootargs_t));
+
+    if (!bootargs)
+    {
+        fprintf(stderr, "alloc bootargs failed\n");
+        free(fs);
+        free(root);
+        return -1;
+    }
+
+    bootargs->root = root;
+    bootargs->fstype = fs;
+
+    *ret = bootargs;
+
+    return 0;
+}
+
+void free_bootargs(struct bootargs_t **args)
+{
+    struct bootargs_t *bootargs = *args;
+    struct fstype *curr = NULL;
+    struct fstype *next = NULL;
+
+    if (!bootargs)
+        return;
+
+    if (bootargs->root)
+        free(bootargs->root);
+
+    curr = bootargs->fstype;
+
+    do
+    {
+        if (curr)
+        {
+            if (curr->name)
+                free(curr->name);
+
+            next = curr->next;
+            free(curr);
+        }
+
+        curr = next;
+
+    } while (curr);
+
+    free(bootargs);
+}
diff --git a/package/rdloader/src/cmdline.h b/package/rdloader/src/cmdline.h
new file mode 100644
index 0000000..9c8e9ab
--- /dev/null
+++ b/package/rdloader/src/cmdline.h
@@ -0,0 +1,24 @@
+//
+// Created by juno on 2022/1/11.
+//
+
+#ifndef INIT_CMDLINE_H
+#define INIT_CMDLINE_H
+
+struct fstype
+{
+	char *name;
+	struct fstype *next;
+};
+
+struct bootargs_t
+{
+	char *root;
+	struct fstype *fstype;
+};
+
+int parse_cmdline(struct bootargs_t **ret);
+
+void free_bootargs(struct bootargs_t **args);
+
+#endif //INIT_CMDLINE_H
diff --git a/package/rdloader/src/insmod.c b/package/rdloader/src/insmod.c
new file mode 100644
index 0000000..4cffbd0
--- /dev/null
+++ b/package/rdloader/src/insmod.c
@@ -0,0 +1,161 @@
+//
+// Created by juno on 2022/1/7.
+//
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <sys/syscall.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <byteswap.h>
+#include <limits.h>
+#include "insmod.h"
+
+#define init_module(module, len, opts) syscall(__NR_init_module, module, len, opts)
+
+#if __BYTE_ORDER == __BIG_ENDIAN
+#define SWAP_BE32(x) (x)
+#define SWAP_BE64(x) (x)
+#else
+#define SWAP_BE32(x) bswap_32(x)
+#define SWAP_BE64(x) bswap_64(x)
+#endif
+
+static char *parse_cmdline_module_options(const char **argv, int quote_space)
+{
+    char *options;
+    int optlen;
+
+    options = calloc(1, sizeof(char));
+    optlen = 0;
+
+    while (*++argv)
+    {
+        const char *fmt;
+        const char *var;
+        const char *val;
+
+        var = *argv;
+
+        options = realloc(options, optlen + 2 + strlen(var) + 2);
+
+        fmt = "%.*s%s ";
+
+        var = strchrnul(var, '=');
+
+        if (quote_space)
+        {
+            if (*val)
+            {
+                val++;
+                if (strchr(val, ' '))
+                    fmt = "%.*s\"%s\" ";
+            }
+        }
+
+        optlen += sprintf(options + optlen, fmt, (int)(val - var), var, val);
+    }
+
+    return options;
+}
+
+static void *mmap_read(int fd, size_t size)
+{
+    return mmap(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0);
+}
+
+static void *try_to_map_module(const char *filename, size_t *image_size_p)
+{
+    void *image = NULL;
+    struct stat st;
+    int fd;
+
+    fd = open(filename, O_RDONLY);
+
+    if (fd < 0)
+    {
+        fprintf(stderr, "open %s failed:%s\n", filename, strerror(errno));
+        return NULL;
+    }
+
+    fstat(fd, &st);
+
+    if (st.st_size <= *image_size_p)
+    {
+        size_t image_size = st.st_size;
+        image = mmap_read(fd, image_size);
+
+        if (image == MAP_FAILED)
+        {
+            image = NULL;
+        }
+        else if (*(u_int32_t *)image != SWAP_BE32(0x7f454C46))
+        {
+            munmap(image, image_size);
+        }
+        else
+        {
+            *image_size_p = image_size;
+        }
+    }
+
+    close(fd);
+    return image;
+}
+
+static void *malloc_open_zipped_read_close(const char *filename, size_t *image_size_p)
+{
+    return NULL;
+}
+
+int do_insmod(const char *modname, const char **argv)
+{
+    int mmaped = 0;
+    size_t image_size = INT_MAX - 4095;
+    void *image = NULL;
+    int ret;
+
+    if (!modname)
+    {
+        return -1;
+    }
+
+    char *options = *argv == NULL ? "" : parse_cmdline_module_options(argv, 0);
+
+    image = try_to_map_module(modname, &image_size);
+
+    if (image)
+    {
+        mmaped = 1;
+    }
+    else
+    {
+        errno = ENOMEM;
+        image = malloc_open_zipped_read_close(modname, &image_size);
+        if (!image)
+            return -ENOMEM;
+    }
+
+    errno = 0;
+
+    init_module(image, image_size, options);
+
+    ret = errno;
+
+    if (mmaped)
+        munmap(image, image_size);
+    else
+        free(image);
+
+    if (ret)
+    {
+        fprintf(stderr, "insmod failed:%s\n", strerror(ret));
+    }
+
+    return ret;
+}
diff --git a/package/rdloader/src/insmod.h b/package/rdloader/src/insmod.h
new file mode 100644
index 0000000..f938ef1
--- /dev/null
+++ b/package/rdloader/src/insmod.h
@@ -0,0 +1,10 @@
+//
+// Created by juno on 2022/1/7.
+//
+
+#ifndef INIT_INSMOD_H
+#define INIT_INSMOD_H
+
+int do_insmod(const char *modname, const char **argv);
+
+#endif //INIT_INSMOD_H
diff --git a/package/rdloader/src/main.c b/package/rdloader/src/main.c
new file mode 100644
index 0000000..adf8498
--- /dev/null
+++ b/package/rdloader/src/main.c
@@ -0,0 +1,261 @@
+#include <sys/mount.h>
+#include <stdio.h>
+#include <stddef.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <inttypes.h>
+#include <sys/wait.h>
+
+#include "insmod.h"
+#include "mknod.h"
+#include "mkdev_node.h"
+#include "cmdline.h"
+#include "switch_root.h"
+
+static void hang(void);
+
+static int mount_fs(void)
+{
+	int ret;
+
+	unsigned long flags = MS_NOEXEC | MS_NOSUID | MS_RELATIME | MS_NODEV;
+
+	ret = mount(NULL, "/proc", "proc", flags, NULL);
+
+	if (ret < 0)
+		goto err;
+
+	ret = mount(NULL, "/sys", "sysfs", flags, NULL);
+
+	if (ret < 0)
+		goto err;
+
+	ret = mount(NULL, "/dev", "tmpfs", MS_RELATIME, NULL);
+
+	if (ret < 0)
+		goto err;
+
+	return 0;
+err:
+	ret = errno;
+	return ret;
+}
+
+struct dev_node_t
+{
+	const char *mode;
+	const char *name;
+	char type;
+	uint8_t major;
+	uint8_t minor;
+} dev_nodes[] = {
+	{
+		.mode = "0666",
+		.name = "/dev/tty",
+		.type = 'c',
+		.major = 5,
+		.minor = 0,
+	},
+	{
+		.mode = "0622",
+		.name = "/dev/console",
+		.type = 'c',
+		.major = 5,
+		.minor = 1,
+	},
+	{
+		.mode = "0666",
+		.name = "/dev/null",
+		.type = 'c',
+		.major = 1,
+		.minor = 3,
+	},
+	{
+		.mode = "0666",
+		.name = "/dev/zero",
+		.type = 'c',
+		.major = 1,
+		.minor = 5,
+	},
+};
+
+static int make_node(void)
+{
+	for (int i = 0; i < sizeof(dev_nodes) / sizeof((dev_nodes)[0]); i++)
+	{
+		if (do_mknod(dev_nodes[i].mode, dev_nodes[i].name, dev_nodes[i].type, dev_nodes[i].major, dev_nodes[i].minor) < 0)
+		{
+			if (errno == EEXIST)
+				continue;
+
+			fprintf(stderr, "make %s failed:%s\n", dev_nodes[i].name, strerror(errno));
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static int insert_kernel_module(const char *path, const char **argv)
+{
+	int ret;
+	FILE *fp = NULL;
+	char module_name[1024] = {0};
+
+	if (access(path, F_OK) != 0)
+	{
+		fprintf(stderr, "%s not found\n", path);
+		return -1;
+	}
+
+	fp = fopen(path, "r");
+	if (!fp)
+	{
+		fprintf(stderr, "open %s failed:%s\n", path, strerror(errno));
+		return -1;
+	}
+
+	while ((fgets(module_name, sizeof(module_name) - 1, fp)) != NULL)
+	{
+		for (int i = 0; i < sizeof(module_name); i++)
+		{
+			if (module_name[i] == '\n')
+			{
+				module_name[i] = '\0';
+				break;
+			}
+		}
+
+		ret = do_insmod(module_name, argv);
+
+		if (ret)
+		{
+			break;
+		}
+	}
+
+	fclose(fp);
+
+	return ret;
+}
+
+static void e2fsck(const char *dev_path)
+{
+	int pid, status;
+	pid = fork();
+	if (pid < 0)
+	{
+		printf("fork failed");
+		hang();
+	}
+	if (pid == 0)
+	{
+		execl("/bin/e2fsck", "-f", "-y", dev_path, NULL);
+		printf("execl failed");
+		hang();
+	}
+	else
+	{
+		waitpid(pid, &status, 0);
+	}
+}
+
+static int mount_rootfs(struct bootargs_t *bootargs)
+{
+	int ret = 0;
+	char realroot[PATH_MAX];
+	struct fstype *fstype = NULL;
+
+	if (strncmp(bootargs->root, "ubi", 3) == 0)
+		return mount(bootargs->root, "/root", "ubifs", MS_RELATIME, NULL);
+
+	// OpenWrt dont have /dev/disk/by-* yet, use realpath as workaround.
+	if (realpath(bootargs->root, realroot) == NULL)
+		return -1;
+
+	fstype = bootargs->fstype;
+
+	for (struct fstype *next = fstype->next; fstype; next = fstype->next, fstype = next)
+	{
+		if (strcmp(fstype->name, "ext4") == 0)
+		{
+			e2fsck(realroot);
+		}
+		ret = mount(realroot, "/root", fstype->name, MS_RDONLY | MS_RELATIME, NULL);
+		if (ret == 0)
+			break;
+	}
+
+	return ret;
+}
+
+static void hang()
+{
+	exit(-1);
+	while (1)
+	{
+	}
+}
+
+int main(int argc, const char *argv[])
+{
+	int ret;
+	struct bootargs_t *bootargs = NULL;
+
+	if (getpid() != 1)
+	{
+		fprintf(stderr, "must run PID 1\n");
+		hang();
+	}
+
+	if ((ret = mount_fs()) < 0)
+	{
+		fprintf(stderr, "mount ramdisk fs failed:%s\n", strerror(ret));
+		hang();
+	}
+
+	if (make_node() < 0)
+	{
+		fprintf(stderr, "make ramdisk dev node failed\n");
+		hang();
+	}
+
+	if ((ret = parse_cmdline(&bootargs)) < 0)
+	{
+		fprintf(stderr, "cmdline format error\n");
+		hang();
+	}
+
+	if (insert_kernel_module("/etc/rdloader_list", argv + 1) != 0)
+	{
+		fprintf(stderr, "failed to load kmods\n");
+		hang();
+	}
+
+	printf("Waiting for root: %s\n", bootargs->root);
+
+	do
+	{
+		ret = mkdev_node();
+
+		if (ret)
+			continue;
+
+		ret = mount_rootfs(bootargs);
+	} while (ret != 0);
+
+	free_bootargs(&bootargs);
+
+	umount("/dev");
+	umount("/proc");
+	umount("/sys");
+
+	switch_root("/root", "/etc/preinit");
+
+	return 0;
+}
diff --git a/package/rdloader/src/mkdev_node.c b/package/rdloader/src/mkdev_node.c
new file mode 100644
index 0000000..9207116
--- /dev/null
+++ b/package/rdloader/src/mkdev_node.c
@@ -0,0 +1,272 @@
+//
+// Created by juno on 2022/1/10.
+//
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <blkid/blkid.h>
+
+#include "mkdev_node.h"
+#include "mknod.h"
+#include "blkid2.h"
+
+static int parse_devno(const char *devname, int *maj, int *min)
+{
+    FILE *fp;
+    char *major_s, *minor_s;
+    int major, minor;
+    char dev_path[1024] = {0};
+    char dev_no[32] = {0};
+
+    snprintf(dev_path, sizeof(dev_path) - 1, "/sys/class/block/%s/dev", devname);
+
+    fp = fopen(dev_path, "r");
+
+    if (fp == NULL)
+        return -1;
+
+    if (!fgets(dev_no, 31, fp))
+        return -1;
+
+    fclose(fp);
+    major_s = strtok(dev_no, ":");
+    minor_s = strtok(NULL, ":");
+
+    major = (int)strtoul(major_s, NULL, 0);
+
+    minor = (int)strtoul(minor_s, NULL, 0);
+
+    *maj = major;
+    *min = minor;
+
+    return 0;
+}
+
+static int mkpartion_node(const char *devname)
+{
+    int ret = 0;
+    dev_t part_devno;
+    dev_t disk_devno;
+    char *disk_name;
+    blkid_probe disk_pr;
+    blkid_partlist ls;
+    blkid_partition par;
+    const char *uuid;
+    char *dev_path = NULL;
+
+    asprintf(&dev_path, "/dev/%s", devname);
+
+    if (dev_path == NULL)
+        return -1;
+
+    blkid_probe part_pr = blkid_new_probe_from_filename(dev_path);
+
+    if (!part_pr)
+    {
+        ret = -1;
+        goto out1;
+    }
+
+    part_devno = blkid_probe_get_devno(part_pr);
+
+    if (!part_devno)
+    {
+        ret = -1;
+        goto out2;
+    }
+
+    disk_devno = blkid_probe_get_wholedisk_devno(part_pr);
+
+    if (!disk_devno)
+    {
+        ret = -1;
+        goto out2;
+    }
+
+    disk_name = blkid_devno_to_devname(disk_devno);
+
+    if (!disk_name)
+    {
+        ret = -1;
+        goto out2;
+    }
+
+    disk_pr = blkid_new_probe_from_filename(disk_name);
+
+    if (!disk_pr)
+    {
+        ret = -1;
+        goto out3;
+    }
+
+    ls = blkid_probe_get_partitions(disk_pr);
+
+    if (!ls)
+    {
+        ret = -1;
+        goto out4;
+    }
+
+    par = blkid_partlist_devno_to_partition(ls, part_devno);
+
+    uuid = blkid_partition_get_uuid(par);
+
+    if (uuid)
+    {
+        char long_path[1024] = {0};
+        snprintf(long_path, sizeof(long_path) - 1, "/dev/disk/by-partuuid/%s", uuid);
+
+        if (access(long_path, F_OK) == 0)
+            goto out4;
+
+        if (access(dev_path, F_OK) != 0)
+            goto out4;
+
+        symlink(dev_path, long_path);
+    }
+    else
+    {
+        ret = -1;
+    }
+
+out4:
+    blkid_free_probe(disk_pr);
+out3:
+    free(disk_name);
+out2:
+    blkid_free_probe(part_pr);
+out1:
+    free(dev_path);
+    return ret;
+}
+
+static int dev_by_partuuit(void)
+{
+    DIR *dir;
+    DIR *disk_dir;
+    struct dirent *filename;
+    struct dirent *partname;
+    char *disk = NULL;
+
+    mkdir("/dev/disk/by-partuuid", 0755);
+
+    dir = opendir("/sys/block");
+
+    if (!dir)
+    {
+        return -1;
+    }
+
+    while ((filename = readdir(dir)))
+    {
+        if (filename->d_type != DT_LNK)
+            continue;
+
+        asprintf(&disk, "/sys/block/%s", filename->d_name);
+
+        disk_dir = opendir(disk);
+
+        if (disk)
+            free(disk);
+
+        if (disk_dir)
+        {
+            while ((partname = readdir(disk_dir)))
+            {
+                char *dev = NULL;
+                asprintf(&dev, "/sys/block/%s/%s/dev", filename->d_name, partname->d_name);
+
+                if (access(dev, F_OK) == 0)
+                {
+                    mkpartion_node(partname->d_name);
+                }
+
+                if (dev)
+                    free(dev);
+            }
+        }
+
+        closedir(disk_dir);
+    }
+
+    closedir(dir);
+
+    return 0;
+}
+
+int mkdev_node(void)
+{
+    int ret;
+    struct dirent *filename;
+    DIR *dir = NULL;
+    char dev_path[1024];
+    char uuid_node[1024];
+
+    dir = opendir("/sys/class/block");
+
+    ret = mkdir("/dev/disk", 0755);
+
+    if (ret < 0 && errno != EEXIST)
+    {
+        fprintf(stderr, "create /dev/disk directory failed:%s\n", strerror(errno));
+        return -1;
+    }
+
+    ret = mkdir("/dev/disk/by-uuid", 0755);
+
+    if (ret < 0 && errno != EEXIST)
+    {
+        fprintf(stderr, "create /dev/disk/by-uuid directory failed:%s\n", strerror(errno));
+        return -1;
+    }
+
+    while ((filename = readdir(dir)))
+    {
+        if (filename->d_type == DT_LNK)
+        {
+            int major, minor;
+            char *uuid = NULL;
+
+            memset(dev_path, 0, sizeof(dev_path));
+
+            snprintf(dev_path, sizeof(dev_path) - 1, "/dev/%s", filename->d_name);
+
+            if (access(dev_path, F_OK) == 0)
+                continue;
+
+            if (parse_devno(filename->d_name, &major, &minor) < 0)
+                continue;
+
+            ret = do_mknod("0755", dev_path, 'b', major, minor);
+
+            if (ret < 0)
+                return ret;
+
+            ret = get_blkid(dev_path, &uuid);
+
+            if (ret < 0)
+                continue;
+
+            memset(uuid_node, 0, sizeof(uuid_node));
+            snprintf(uuid_node, sizeof(uuid_node) - 1, "/dev/disk/by-uuid/%s", uuid);
+
+            symlink(dev_path, uuid_node);
+            if (uuid)
+            {
+                free(uuid);
+                uuid = NULL;
+            }
+        }
+    }
+
+    closedir(dir);
+
+    dev_by_partuuit();
+
+    return 0;
+}
\ No newline at end of file
diff --git a/package/rdloader/src/mkdev_node.h b/package/rdloader/src/mkdev_node.h
new file mode 100644
index 0000000..998b77b
--- /dev/null
+++ b/package/rdloader/src/mkdev_node.h
@@ -0,0 +1,10 @@
+//
+// Created by juno on 2022/1/10.
+//
+
+#ifndef INIT_MKDEV_NODE_H
+#define INIT_MKDEV_NODE_H
+
+int mkdev_node(void);
+
+#endif //INIT_MKDEV_NODE_H
diff --git a/package/rdloader/src/mknod.c b/package/rdloader/src/mknod.c
new file mode 100644
index 0000000..a1a2573
--- /dev/null
+++ b/package/rdloader/src/mknod.c
@@ -0,0 +1,217 @@
+//
+// Created by juno on 2022/1/7.
+//
+
+#include <sys/sysmacros.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include "mknod.h"
+
+static const mode_t modes_cubp[] = {
+    S_IFIFO,
+    S_IFCHR,
+    S_IFBLK,
+    S_IFLNK,
+};
+
+#define FILEMODEBITS (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO)
+
+static mode_t parse_mode(const char *s)
+{
+    static const mode_t who_mask[] = {
+        S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO, /* a */
+        S_ISUID | S_IRWXU,                                         /* u */
+        S_ISGID | S_IRWXG,                                         /* g */
+        S_IRWXO                                                    /* o */
+    };
+    static const mode_t perm_mask[] = {
+        S_IRUSR | S_IRGRP | S_IROTH, /* r */
+        S_IWUSR | S_IWGRP | S_IWOTH, /* w */
+        S_IXUSR | S_IXGRP | S_IXOTH, /* x */
+        S_IXUSR | S_IXGRP | S_IXOTH, /* X -- special -- see below */
+        S_ISUID | S_ISGID,           /* s */
+        S_ISVTX                      /* t */
+    };
+    static const char who_chars[] ALIGN1 = "augo";
+    static const char perm_chars[] ALIGN1 = "rwxXst";
+
+    const char *p;
+    mode_t wholist;
+    mode_t permlist;
+    mode_t new_mode;
+    char op;
+
+    if ((unsigned char)(*s - '0') < 8)
+    {
+        unsigned long tmp;
+        char *e;
+
+        tmp = strtoul(s, &e, 8);
+        if (*e || (tmp > 07777U))
+        { /* Check range and trailing chars. */
+            return -1;
+        }
+        return tmp;
+    }
+
+    new_mode = 0666;
+
+    /* Note: we allow empty clauses, and hence empty modes.
+     * We treat an empty mode as no change to perms. */
+
+    while (*s)
+    { /* Process clauses. */
+        if (*s == ',')
+        { /* We allow empty clauses. */
+            ++s;
+            continue;
+        }
+
+        /* Get a wholist. */
+        wholist = 0;
+    WHO_LIST:
+        p = who_chars;
+        do
+        {
+            if (*p == *s)
+            {
+                wholist |= who_mask[(int)(p - who_chars)];
+                if (!*++s)
+                {
+                    return -1;
+                }
+                goto WHO_LIST;
+            }
+        } while (*++p);
+
+        do
+        { /* Process action list. */
+            if ((*s != '+') && (*s != '-'))
+            {
+                if (*s != '=')
+                {
+                    return -1;
+                }
+                /* Since op is '=', clear all bits corresponding to the
+                 * wholist, or all file bits if wholist is empty. */
+                permlist = ~FILEMODEBITS;
+                if (wholist)
+                {
+                    permlist = ~wholist;
+                }
+                new_mode &= permlist;
+            }
+            op = *s++;
+
+            /* Check for permcopy. */
+            p = who_chars + 1; /* Skip 'a' entry. */
+            do
+            {
+                if (*p == *s)
+                {
+                    int i = 0;
+                    permlist = who_mask[(int)(p - who_chars)] & (S_IRWXU | S_IRWXG | S_IRWXO) & new_mode;
+                    do
+                    {
+                        if (permlist & perm_mask[i])
+                        {
+                            permlist |= perm_mask[i];
+                        }
+                    } while (++i < 3);
+                    ++s;
+                    goto GOT_ACTION;
+                }
+            } while (*++p);
+
+            /* It was not a permcopy, so get a permlist. */
+            permlist = 0;
+        PERM_LIST:
+            p = perm_chars;
+            do
+            {
+                if (*p == *s)
+                {
+                    if ((*p != 'X') || (new_mode & (S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH)))
+                    {
+                        permlist |= perm_mask[(int)(p - perm_chars)];
+                    }
+                    if (!*++s)
+                    {
+                        break;
+                    }
+                    goto PERM_LIST;
+                }
+            } while (*++p);
+        GOT_ACTION:
+            if (permlist)
+            { /* The permlist was nonempty. */
+                mode_t tmp = wholist;
+                if (!wholist)
+                {
+                    mode_t u_mask = umask(0);
+                    umask(u_mask);
+                    tmp = ~u_mask;
+                }
+                permlist &= tmp;
+                if (op == '-')
+                {
+                    new_mode &= ~permlist;
+                }
+                else
+                {
+                    new_mode |= permlist;
+                }
+            }
+        } while (*s && (*s != ','));
+    }
+
+    return new_mode;
+}
+
+static mode_t char_to_mode(char type)
+{
+    switch (type)
+    {
+    case 'f':
+        return modes_cubp[0];
+    case 'c':
+        return modes_cubp[1];
+    case 'b':
+        return modes_cubp[2];
+    case 'l':
+        return modes_cubp[3];
+    }
+
+    return -1;
+}
+
+int do_mknod(const char *mod, const char *name, char type, int maj, int min)
+{
+    int ret;
+    mode_t mode;
+    dev_t dev;
+
+    mode = parse_mode(mod);
+    if (mode != (mode_t)-1)
+        umask(0);
+    else
+    {
+        fprintf(stderr, "mode failed\n");
+        return -1;
+    }
+
+    dev = makedev(maj, min);
+
+    mode |= char_to_mode(type);
+
+    ret = mknod(name, mode, dev);
+
+    if (ret < 0)
+        ret = errno;
+
+    return ret;
+}
diff --git a/package/rdloader/src/mknod.h b/package/rdloader/src/mknod.h
new file mode 100644
index 0000000..0580959
--- /dev/null
+++ b/package/rdloader/src/mknod.h
@@ -0,0 +1,11 @@
+//
+// Created by juno on 2022/1/7.
+//
+
+#ifndef INIT_MKNOD_H
+#define INIT_MKNOD_H
+
+#define ALIGN1 __attribute__((aligned(1)))
+int do_mknod(const char *mod, const char *name, char type, int maj, int min);
+
+#endif //INIT_MKNOD_H
diff --git a/package/rdloader/src/switch_root.c b/package/rdloader/src/switch_root.c
new file mode 100644
index 0000000..e571af8
--- /dev/null
+++ b/package/rdloader/src/switch_root.c
@@ -0,0 +1,108 @@
+//
+// Created by juno on 2022/1/12.
+//
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <sys/mount.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "switch_root.h"
+
+static char *last_char_is(const char *s, int c)
+{
+    if (!s[0])
+        return NULL;
+    while (s[1])
+        s++;
+
+    return (*s == (char)c) ? (char *)s : NULL;
+}
+
+static char *concat_path_file(const char *path, const char *filename)
+{
+    char *lc;
+    char *ret;
+
+    if (!path)
+        path = "";
+
+    lc = last_char_is(path, '/');
+
+    while (*filename == '/')
+        filename++;
+
+    asprintf(&ret, "%s/%s/%s", path, (lc == NULL ? "/" : ""), filename);
+
+    return ret;
+}
+
+static void delete_contents(const char *directory, dev_t rootdev)
+{
+    DIR *dir;
+    struct dirent *d;
+    struct stat st;
+
+    if (lstat(directory, &st) || st.st_dev != rootdev)
+        return;
+
+    if (S_ISDIR(st.st_mode))
+    {
+        dir = opendir(directory);
+        if (dir)
+        {
+            while ((d = readdir(dir)))
+            {
+                char *newdir = d->d_name;
+
+                if (DOT_OR_DOTDOT(newdir))
+                    continue;
+
+                newdir = concat_path_file(directory, newdir);
+                delete_contents(newdir, rootdev);
+                free(newdir);
+            }
+            closedir(dir);
+            rmdir(directory);
+        }
+        else
+        {
+            unlink(directory);
+        }
+    }
+}
+
+void switch_root(const char *new_root, const char *prog)
+{
+    struct stat st;
+    dev_t root_dev;
+
+    chdir(new_root);
+    stat("/", &st);
+
+    root_dev = st.st_dev;
+
+    stat(".", &st);
+
+    if (st.st_dev == root_dev)
+    {
+        fprintf(stderr, "%s must be a mountpoint\n", new_root);
+        return;
+    }
+
+    delete_contents("/", root_dev);
+    if (mount(".", "/", NULL, MS_MOVE, NULL))
+    {
+        fprintf(stderr, "failed to moving root\n");
+        return;
+    }
+
+    chroot(".");
+
+    execl(prog, prog, NULL);
+}
diff --git a/package/rdloader/src/switch_root.h b/package/rdloader/src/switch_root.h
new file mode 100644
index 0000000..443a468
--- /dev/null
+++ b/package/rdloader/src/switch_root.h
@@ -0,0 +1,12 @@
+//
+// Created by juno on 2022/1/12.
+//
+
+#ifndef INIT_SWITCH_ROOT_H
+#define INIT_SWITCH_ROOT_H
+
+#define DOT_OR_DOTDOT(s) ((s)[0] == '.' && (!(s)[1] || ((s)[1] == '.' && !(s)[2])))
+void switch_root(const char *newroot, const char *prog);
+
+
+#endif //INIT_SWITCH_ROOT_H
diff --git a/scripts/gen-rddependencies.sh b/scripts/gen-rddependencies.sh
new file mode 100755
index 0000000..bd091ba
--- /dev/null
+++ b/scripts/gen-rddependencies.sh
@@ -0,0 +1,12 @@
+#!/bin/sh
+TARGETS=$*
+READELF="${READELF:-readelf}"
+XARGS="${XARGS:-xargs -r}"
+
+find $TARGETS -type f -a -exec file {} \; | \
+  sed -n -e 's/^\(.*\):.*ELF.*\(executable\|shared object\).*,.*/\1/p' | \
+  $XARGS -n1 $READELF -l | grep 'Requesting' | cut -d':' -f2 | tr -d ' ]' | \
+  $XARGS basename
+
+cd `dirname ${0}`
+./gen-dependencies.sh ${TARGETS}
diff --git a/scripts/mkits.sh b/scripts/mkits.sh
index bb629d6..7533baf 100755
--- a/scripts/mkits.sh
+++ b/scripts/mkits.sh
@@ -23,18 +23,30 @@ usage() {
 	printf "\n\t-c ==> set config name 'config'"
 	printf "\n\t-a ==> set load address to 'addr' (hex)"
 	printf "\n\t-e ==> set entry point to 'entry' (hex)"
+	printf "\n\t-f ==> set device tree compatible string"
+	printf "\n\t-i ==> include initrd Blob 'initrd'"
 	printf "\n\t-v ==> set kernel version to 'version'"
 	printf "\n\t-k ==> include kernel image 'kernel'"
 	printf "\n\t-D ==> human friendly Device Tree Blob 'name'"
 	printf "\n\t-n ==> fdt unit-address 'address'"
 	printf "\n\t-d ==> include Device Tree Blob 'dtb'"
-	printf "\n\t-o ==> create output file 'its_file'\n"
+	printf "\n\t-r ==> include RootFS blob 'rootfs'"
+	printf "\n\t-H ==> specify hash algo instead of SHA1"
+	printf "\n\t-o ==> create output file 'its_file'"
+	printf "\n\t-O ==> create config with dt overlay 'name:dtb'"
+	printf "\n\t\t(can be specified more than once)\n"
 	exit 1
 }
 
 FDTNUM=1
+ROOTFSNUM=1
+INITRDNUM=1
+HASH=sha1
+LOADABLES=
+DTOVERLAY=
+DTADDR=
 
-while getopts ":A:a:c:C:D:d:e:k:n:o:v:" OPTION
+while getopts ":A:a:c:C:D:d:e:f:i:k:n:o:O:v:r:S" OPTION
 do
 	case $OPTION in
 		A ) ARCH=$OPTARG;;
@@ -44,9 +56,14 @@ do
 		D ) DEVICE=$OPTARG;;
 		d ) DTB=$OPTARG;;
 		e ) ENTRY_ADDR=$OPTARG;;
+		f ) COMPATIBLE=$OPTARG;;
+		i ) INITRD=$OPTARG;;
 		k ) KERNEL=$OPTARG;;
 		n ) FDTNUM=$OPTARG;;
 		o ) OUTPUT=$OPTARG;;
+		O ) DTOVERLAY="$DTOVERLAY ${OPTARG}";;
+		r ) ROOTFS=$OPTARG;;
+		S ) HASH=$OPTARG;;
 		v ) VERSION=$OPTARG;;
 		* ) echo "Invalid option passed to '$0' (options:$*)"
 		usage;;
@@ -62,26 +79,120 @@ fi
 
 ARCH_UPPER=$(echo "$ARCH" | tr '[:lower:]' '[:upper:]')
 
+if [ -n "${COMPATIBLE}" ]; then
+	COMPATIBLE_PROP="compatible = \"${COMPATIBLE}\";"
+fi
+
+[ "$DTOVERLAY" ] && {
+	dtbsize=$(wc -c "$DTB" | cut -d' ' -f1)
+	DTADDR=$(printf "0x%08x" $(($LOAD_ADDR - $dtbsize)) )
+}
+
 # Conditionally create fdt information
 if [ -n "${DTB}" ]; then
 	FDT_NODE="
-		fdt@$FDTNUM {
+		fdt-$FDTNUM {
 			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree blob\";
+			${COMPATIBLE_PROP}
 			data = /incbin/(\"${DTB}\");
 			type = \"flat_dt\";
+			${DTADDR:+load = <${DTADDR}>;}
+			arch = \"${ARCH}\";
+			compression = \"none\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	FDT_PROP="fdt = \"fdt-$FDTNUM\";"
+fi
+
+if [ -n "${INITRD}" ]; then
+	INITRD_NODE="
+		initrd-$INITRDNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} initrd\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${INITRD}\");
+			type = \"ramdisk\";
+			arch = \"${ARCH}\";
+			os = \"linux\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	INITRD_PROP="ramdisk=\"initrd-${INITRDNUM}\";"
+fi
+
+
+if [ -n "${ROOTFS}" ]; then
+	dd if="${ROOTFS}" of="${ROOTFS}.pagesync" bs=4096 conv=sync
+	ROOTFS_NODE="
+		rootfs-$ROOTFSNUM {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} rootfs\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${ROOTFS}.pagesync\");
+			type = \"filesystem\";
 			arch = \"${ARCH}\";
 			compression = \"none\";
 			hash@1 {
 				algo = \"crc32\";
 			};
 			hash@2 {
-				algo = \"sha1\";
+				algo = \"${HASH}\";
 			};
 		};
 "
-	FDT_PROP="fdt = \"fdt@$FDTNUM\";"
+	LOADABLES="${LOADABLES:+$LOADABLES, }\"rootfs-${ROOTFSNUM}\""
 fi
 
+# add DT overlay blobs
+FDTOVERLAY_NODE=""
+OVCONFIGS=""
+[ "$DTOVERLAY" ] && for overlay in $DTOVERLAY ; do
+	overlay_blob=${overlay##*:}
+	ovname=${overlay%%:*}
+	ovnode="fdt-$ovname"
+	ovsize=$(wc -c "$overlay_blob" | cut -d' ' -f1)
+	echo "$ovname ($overlay_blob) : $ovsize" >&2
+	DTADDR=$(printf "0x%08x" $(($DTADDR - $ovsize)))
+	FDTOVERLAY_NODE="$FDTOVERLAY_NODE
+
+		$ovnode {
+			description = \"${ARCH_UPPER} OpenWrt ${DEVICE} device tree overlay $ovname\";
+			${COMPATIBLE_PROP}
+			data = /incbin/(\"${overlay_blob}\");
+			type = \"flat_dt\";
+			arch = \"${ARCH}\";
+			load = <${DTADDR}>;
+			compression = \"none\";
+			hash@1 {
+				algo = \"crc32\";
+			};
+			hash@2 {
+				algo = \"${HASH}\";
+			};
+		};
+"
+	OVCONFIGS="$OVCONFIGS
+
+		config-$ovname {
+			description = \"OpenWrt ${DEVICE} with $ovname\";
+			kernel = \"kernel-1\";
+			fdt = \"fdt-$FDTNUM\", \"$ovnode\";
+			${LOADABLES:+loadables = ${LOADABLES};}
+			${COMPATIBLE_PROP}
+			${INITRD_PROP}
+		};
+	"
+done
+
 # Create a default, fully populated DTS file
 DATA="/dts-v1/;
 
@@ -90,7 +201,7 @@ DATA="/dts-v1/;
 	#address-cells = <1>;
 
 	images {
-		kernel@1 {
+		kernel-1 {
 			description = \"${ARCH_UPPER} OpenWrt Linux-${VERSION}\";
 			data = /incbin/(\"${KERNEL}\");
 			type = \"kernel\";
@@ -103,19 +214,26 @@ DATA="/dts-v1/;
 				algo = \"crc32\";
 			};
 			hash@2 {
-				algo = \"sha1\";
+				algo = \"$HASH\";
 			};
 		};
+${INITRD_NODE}
 ${FDT_NODE}
+${FDTOVERLAY_NODE}
+${ROOTFS_NODE}
 	};
 
 	configurations {
 		default = \"${CONFIG}\";
 		${CONFIG} {
-			description = \"OpenWrt\";
-			kernel = \"kernel@1\";
+			description = \"OpenWrt ${DEVICE}\";
+			kernel = \"kernel-1\";
 			${FDT_PROP}
+			${LOADABLES:+loadables = ${LOADABLES};}
+			${COMPATIBLE_PROP}
+			${INITRD_PROP}
 		};
+		${OVCONFIGS}
 	};
 };"
 
diff --git a/target/linux/ramips/dts/mt7621_hatlab_gateboard-one.dts b/target/linux/ramips/dts/mt7621_hatlab_gateboard-one.dts
new file mode 100644
index 0000000..91de1dd
--- /dev/null
+++ b/target/linux/ramips/dts/mt7621_hatlab_gateboard-one.dts
@@ -0,0 +1,384 @@
+#include "mt7621.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	compatible = "hatlab,gateboard-one", "mediatek,mt7621-soc";
+	model = "HATLab GateBoard-One";
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	aliases {
+		led-boot = &led_sys;
+		led-failsafe = &led_sys;
+		led-running = &led_sys;
+		led-upgrade = &led_sys;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led_sys: sys {
+			label = "green:sys";
+			gpios = <&gpio 0 GPIO_ACTIVE_HIGH>;
+		};
+
+		usb {
+			label = "blue:usb";
+			gpios = <&gpio 16 GPIO_ACTIVE_HIGH>;
+			trigger-sources = <&xhci_ehci_port1>;
+			linux,default-trigger = "usbport";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+
+		reset {
+			label = "reset";
+			gpios = <&gpio 17 GPIO_ACTIVE_HIGH>;
+			linux,code = <KEY_RESTART>;
+		};
+	};
+
+	gpio_export {
+		compatible = "gpio-export";
+		#size-cells = <0>;
+
+		power_peripheral {
+			gpio-export,name = "power_peripheral";
+			gpio-export,output = <0>;
+			gpios = <&gpio 18 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	cpu_fan: cpu_fan {
+		compatible = "gpio-fan";
+		gpios = <&gpio 13 GPIO_ACTIVE_HIGH
+				 &gpio 14 GPIO_ACTIVE_HIGH>;
+		gpio-fan,speed-map = <	0		0
+								2000	1
+								4000	2
+								6000	3>;
+		#cooling-cells = <2>;
+	};
+
+	thermal-zones {
+		cpu-thermal {
+			polling-delay = <1000>;
+			polling-delay-passive = <250>;
+
+			thermal-sensors = <&cpu_sensor>;
+
+			trips {
+				cpu_warm: cpu-warm {
+					temperature = <26000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_hot: cpu-hot {
+					temperature = <37000>;
+					hysteresis = <2000>;
+					type = "active";
+				};
+
+				cpu_alert: cpu-alert {
+					temperature = <75000>;
+					hysteresis = <2000>;
+					type = "hot";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_warm>;
+					cooling-device = <&cpu_fan THERMAL_NO_LIMIT 2>;
+				};
+
+				map1 {
+					trip = <&cpu_hot>;
+					cooling-device = <&cpu_fan 3 THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+	};
+
+	crypto: crypto@1e004000 {
+		status = "okay";
+
+		compatible = "mediatek,mtk-eip93";
+		reg = <0x1e004000 0x1000>;
+
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_SHARED 19 IRQ_TYPE_LEVEL_HIGH>;
+	};
+	
+	i2c_gpio: i2c-gpio {
+		compatible = "i2c-gpio";
+
+		sda-gpios = <&gpio 3 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&gpio 4 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		status = "disabled";
+	};
+
+	i2c_sfp: i2c-sfp {
+		compatible = "i2c-gpio";
+
+		sda-gpios = <&expender0 1 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&expender0 2 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+	i2c_sfp_alias_0: i2c-sfp-alias-0 {
+		compatible = "i2c-gpio";
+
+		sda-gpios = <&expender0_alias_0 1 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+		scl-gpios = <&expender0_alias_0 2 (GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN)>;
+
+		#address-cells = <1>;
+		#size-cells = <0>;
+	};
+
+	sfp: sfp {
+		compatible = "sff,sfp";
+		i2c-bus = <&i2c_sfp>;
+
+		maximum-power-milliwatt = <5000>;
+
+		mod-def0-gpios = <&expender0 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+
+		// los-gpios = <&expender0 3 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
+		// rate-select0-gpios = <&expender0 4 GPIO_ACTIVE_HIGH>;
+		// tx-disable-gpios = <&expender0 6 GPIO_ACTIVE_HIGH>;
+		// tx-fault-gpios = <&expender0 7 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
+	};
+
+	sfp_alias_0: sfp-alias-0 {
+		compatible = "sff,sfp";
+		i2c-bus = <&i2c_sfp_alias_0>;
+
+		maximum-power-milliwatt = <5000>;
+
+		mod-def0-gpios = <&expender0_alias_0 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
+
+		// los-gpios = <&expender0_alias_0 3 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
+		// rate-select0-gpios = <&expender0_alias_0 4 GPIO_ACTIVE_HIGH>;
+		// tx-disable-gpios = <&expender0_alias_0 6 GPIO_ACTIVE_HIGH>;
+		// tx-fault-gpios = <&expender0_alias_0 7 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;
+	};
+};
+
+&spi0 {
+	status = "okay";
+
+	spi-nor@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <30000000>;
+
+		partitions@0 {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0 {
+				label = "u-boot";
+				reg = <0x0 0x70000>;
+				read-only;
+			};
+
+			partition@70000 {
+				label = "u-boot-env";
+				reg = <0x70000 0x8000>;
+			};
+
+			factory: partition@75000 {
+				label = "factory";
+				reg = <0x78000 0x8000>;
+			};
+		};
+	};
+
+	spi-nand@1 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "spi-nand";
+		reg = <1>;
+		spi-max-frequency = <30000000>;
+
+		partition@0 {
+			label = "nand0-ubi";
+			reg = <0x0 0x0>;
+		};
+	};
+};
+
+&uartlite2 {
+	status = "okay";
+};
+
+&uartlite3 {
+	status = "okay";
+};
+
+&state_default {
+	gpio {
+		groups = "wdt", "jtag", "i2c";
+		function = "gpio";
+	};
+};
+
+&pcie {
+	status = "okay";
+};
+
+&pcie0 {
+	mt76@0,0 {
+		reg = <0x0000 0 0 0 0>;
+		mediatek,eeprom-file = "mt76.pcie0.eeprom";
+	};
+};
+
+&pcie1 {
+	mt76@0,0 {
+		reg = <0x0000 0 0 0 0>;
+		mediatek,eeprom-file = "mt76.pcie1.eeprom";
+	};
+};
+
+&pcie2 {
+	mt76@0,0 {
+		reg = <0x0000 0 0 0 0>;
+		mediatek,eeprom-file = "mt76.pcie2.eeprom";
+	};
+};
+
+&sdhci {
+	status = "okay";
+	max-frequency = <20000000>;
+};
+
+&mdio {
+	ephy7: ethernet-phy@7 {
+		reg = <7>;
+		eee-broken-1000t;
+		eee-broken-100tx;
+		realtek,autotxid;
+	};
+};
+
+&gmac0 {
+	label = "dsa0";
+	mtd-mac-address = <&factory 0x0>;
+	phy-mode = "trgmii";
+};
+
+&gmac1 {
+	status = "okay";
+	label = "eth5";
+
+	mtd-mac-address = <&factory 0x0>;
+	mtd-mac-address-increment = <6>;
+
+	phy-handle = <&ephy7>;
+	phy-mode = "rgmii-rxid";
+};
+
+&switch0 {
+	ports {
+		port@0 {
+			status = "okay";
+			label = "eth0";
+			mtd-mac-address = <&factory 0x0>;
+			mtd-mac-address-increment = <1>;
+		};
+
+		port@1 {
+			status = "okay";
+			label = "eth1";
+			mtd-mac-address = <&factory 0x0>;
+			mtd-mac-address-increment = <2>;
+		};
+
+		port@2 {
+			status = "okay";
+			label = "eth2";
+			mtd-mac-address = <&factory 0x0>;
+			mtd-mac-address-increment = <3>;
+		};
+
+		port@3 {
+			status = "okay";
+			label = "eth3";
+			mtd-mac-address = <&factory 0x0>;
+			mtd-mac-address-increment = <4>;
+		};
+
+		port@4 {
+			status = "okay";
+			label = "eth4";
+			mtd-mac-address = <&factory 0x0>;
+			mtd-mac-address-increment = <5>;
+		};
+
+		port@6 {
+			reg = <6>;
+			label = "cpu";
+			ethernet = <&gmac0>;
+			phy-mode = "trgmii";
+
+			fixed-link {
+				speed = <1000>;
+				full-duplex;
+			};
+		};
+	};
+};
+
+&i2c_gpio {
+	status = "okay";
+
+	expender0: pcf8574a@38 {
+		compatible = "nxp,pcf8574a";
+		reg = <0x38>;
+		interrupt-parent = <&gpio>;
+		interrupts = <15 IRQ_TYPE_EDGE_FALLING>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+	};
+
+	expender0_alias_0: pcf8574@20 {
+		compatible = "nxp,pcf8574";
+		reg = <0x20>;
+		interrupt-parent = <&gpio>;
+		interrupts = <15 IRQ_TYPE_EDGE_FALLING>;
+		gpio-controller;
+		#gpio-cells = <2>;
+		interrupt-controller;
+		#interrupt-cells = <2>;
+	};
+
+	rtc0: pcf8563@51 {
+		compatible = "nxp,pcf8563";
+		reg = <0x51>;
+	};
+
+	cpu_sensor: lm75@4f {
+		compatible = "national,lm75";
+		reg = <0x4f>;
+		#thermal-sensor-cells = <0>;
+	};
+};
diff --git a/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c b/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c
index 188e015..4b84115 100644
--- a/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c
+++ b/target/linux/ramips/files/drivers/mmc/host/mtk-mmc/sd.c
@@ -99,6 +99,7 @@
 #define MAX_SGMT_SZ         (MAX_DMA_CNT)
 #define MAX_REQ_SZ          (MAX_SGMT_SZ * 8)
 
+static int host_max_mclk = HOST_MAX_MCLK;
 static int cd_active_low = 1;
 
 //=================================
@@ -455,7 +456,7 @@ static void msdc_tasklet_card(struct work_struct *work)
 	host->card_inserted = inserted;
 
 	if (!host->suspend) {
-		host->mmc->f_max = HOST_MAX_MCLK;
+		host->mmc->f_max = host_max_mclk;
 		mmc_detect_change(host->mmc, msecs_to_jiffies(20));
 	}
 
@@ -2233,10 +2234,13 @@ static int msdc_drv_probe(struct platform_device *pdev)
 		goto host_free;
 	}
 
+	if (of_property_read_u32(pdev->dev.of_node, "max-frequency", &ret) == 0)
+		host_max_mclk = ret;
+
 	/* Set host parameters to mmc */
 	mmc->ops        = &mt_msdc_ops;
 	mmc->f_min      = HOST_MIN_MCLK;
-	mmc->f_max      = HOST_MAX_MCLK;
+	mmc->f_max      = host_max_mclk;
 	mmc->ocr_avail  = MSDC_OCR_AVAIL;
 
 	mmc->caps   = MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED;
diff --git a/target/linux/ramips/image/Makefile b/target/linux/ramips/image/Makefile
index 5937970..464c2d7 100644
--- a/target/linux/ramips/image/Makefile
+++ b/target/linux/ramips/image/Makefile
@@ -14,7 +14,7 @@ DEVICE_VARS += SERCOMM_PAD JCG_MAXSIZE
 
 loadaddr-y := 0x80000000
 loadaddr-$(CONFIG_TARGET_ramips_rt288x) := 0x88000000
-loadaddr-$(CONFIG_TARGET_ramips_mt7621) := 0x80001000
+loadaddr-$(CONFIG_TARGET_ramips_mt7621) := 0x81001000
 
 ldrplatform-y := ralink
 ldrplatform-$(CONFIG_TARGET_ramips_mt7621) := mt7621
diff --git a/target/linux/ramips/image/mt7621.mk b/target/linux/ramips/image/mt7621.mk
index c62087d..25c7985 100644
--- a/target/linux/ramips/image/mt7621.mk
+++ b/target/linux/ramips/image/mt7621.mk
@@ -26,6 +26,73 @@ define Build/gemtek-trailer
 	printf "%s%08X" ".GEMTEK." "$$(cksum $@ | cut -d ' ' -f1)" >> $@
 endef
 
+define Build/hatlab-gateboard-combined
+  rm -fR $@.bootfs.img
+
+	mkfs.fat $@.bootfs.img -C 16384
+	mcopy -i $@.bootfs.img $(IMAGE_KERNEL) ::vmlinux.itb
+
+	( \
+		set $$(ptgen -o $@ -h 4 -s 63 -l 1024 -g -p 16M -p "${CONFIG_TARGET_ROOTFS_PARTSIZE}M" -G ${IMG_PART_DISKGUID}); \
+		BOOTFSOFFSET="$$(($$1 / 512))"; \
+		ROOTFSOFFSET="$$(($$3 / 512))"; \
+		dd if="$@.bootfs.img" of="$@" bs=512 seek="$${BOOTFSOFFSET}" conv=notrunc; \
+		dd if="${IMAGE_ROOTFS}" of="$@" bs=512 seek="$${ROOTFSOFFSET}" conv=notrunc; \
+	)
+endef
+
+define Build/hatlab-gateboard-kernel
+	rm -fR $@.initrd
+	rm -fR $@.initrd.cpio $@.initrd.cpio.gz
+
+	mkdir -p $@.initrd/{bin,dev,proc,sys,lib,etc}
+	mkdir -p $@.initrd/lib/modules/$(LINUX_VERSION)
+
+	$(CP) $(STAGING_DIR)/rdloader/bin/* $@.initrd/bin/
+  $(CP) $(STAGING_DIR)/rdloader/lib/* $@.initrd/lib/
+  $(CP) $(STAGING_DIR)/rdloader/etc/* $@.initrd/etc/
+
+  $(RSTRIP) $@.initrd/bin/
+  $(RSTRIP) $@.initrd/lib/
+
+  chmod +x $@.initrd/bin/*
+  ln -s ./bin/rdloader $@.initrd/init
+
+	( \
+		KMODS=(usb-common nls_base usbcore xhci-hcd xhci-mtk jbd2 mbcache ext4 scsi_mod usb-storage sd_mod mmc_core mmc_block mtk_sd crc32c_generic loop); \
+		for kmod in "$${KMODS[@]}"; do \
+			$(CP) \
+				$(TARGET_DIR)/lib/modules/$(LINUX_VERSION)/$$kmod.ko \
+				$@.initrd/lib/modules/$(LINUX_VERSION)/; \
+			echo /lib/modules/$(LINUX_VERSION)/$$kmod.ko \
+				>> $@.initrd/etc/rdloader_list; \
+		done; \
+	)
+
+	( \
+		if [ -f $(STAGING_DIR_HOST)/bin/cpio ]; then \
+			CPIO=$(STAGING_DIR_HOST)/bin/cpio; \
+		else \
+			CPIO="cpio"; \
+		fi; \
+		cd $@.initrd; \
+		find . | cpio -o -H newc -R 0:0 > $@.initrd.cpio; \
+	)
+
+	gzip -9 $@.initrd.cpio
+
+	$(TOPDIR)/scripts/mkits.sh \
+		-D $(DEVICE_NAME) -o $@.its -k $@ \
+		-C gzip -d $(KDIR)/image-$(DEVICE_DTS).dtb \
+		-i $@.initrd.cpio.gz \
+		-a $(KERNEL_LOADADDR) -e $(KERNEL_LOADADDR) \
+		-c config-1 -A $(LINUX_KARCH) -v $(LINUX_VERSION)
+
+	PATH=$(LINUX_DIR)/scripts/dtc:$(PATH) mkimage -f $@.its $@.new
+
+	@mv $@.new $@
+endef
+
 define Build/iodata-factory
 	$(eval fw_size=$(word 1,$(1)))
 	$(eval fw_type=$(word 2,$(1)))
@@ -610,6 +677,27 @@ define Device/gnubee_gb-pc2
 endef
 TARGET_DEVICES += gnubee_gb-pc2
 
+define Device/hatlab_gateboard-one
+  $(Device/dsa-migration)
+  DEVICE_VENDOR := HATLab
+  DEVICE_MODEL := GateBoard-One
+  DEVICE_PACKAGES := rdloader 8563-watchdog kmod-i2c-gpio kmod-gpio-pcf857x kmod-sdhci-mt7620 kmod-usb3 kmod-usb-storage kmod-usb-ledtrig-usbport kmod-fs-ext4 kmod-hwmon-lm75 kmod-thermal kmod-hwmon-gpiofan kmod-rtc-pcf8563 kmod-phy-realtek kmod-sfp
+  MKUBIFS_OPTS := -m 2048 -e 124KiB -c 1024
+  KERNEL := kernel-bin | gzip | hatlab-gateboard-kernel
+  IMAGE/kernel.itb := append-kernel
+  IMAGE/rootfs.img := append-rootfs
+  IMAGE/rootfs.img.gz := append-rootfs | gzip
+  IMAGE/combined.img := hatlab-gateboard-combined | append-metadata
+  IMAGE/combined.img.gz := hatlab-gateboard-combined | gzip | append-metadata
+  IMAGES := kernel.itb
+  ifeq ($(CONFIG_TARGET_IMAGES_GZIP),y)
+    IMAGES += rootfs.img.gz combined.img.gz
+  else
+    IMAGES += rootfs.img combined.img
+  endif
+endef
+TARGET_DEVICES += hatlab_gateboard-one
+
 define Device/hiwifi_hc5962
   $(Device/dsa-migration)
   BLOCKSIZE := 128k
diff --git a/target/linux/ramips/mt7621/base-files/etc/board.d/02_network b/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
index 4d081be..17e528d 100755
--- a/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/mt7621/base-files/etc/board.d/02_network
@@ -76,6 +76,9 @@ ramips_setup_interfaces()
 		ucidef_set_interface_lan "lan1 lan2 lan3 lan4"
 		ucidef_set_interface "qtn" ifname "eth1" protocol "static" ipaddr "1.1.1.1" netmask "255.255.255.0"
 		;;
+	hatlab,gateboard-one)
+		ucidef_set_interfaces_lan_wan "eth0 eth1 eth2 eth3 eth4" "eth5"
+		;;
 	*)
 		ucidef_set_interfaces_lan_wan "lan1 lan2 lan3 lan4" "wan"
 		;;
diff --git a/target/linux/ramips/mt7621/base-files/lib/upgrade/hatlab.sh b/target/linux/ramips/mt7621/base-files/lib/upgrade/hatlab.sh
new file mode 100644
index 0000000..420f1bb
--- /dev/null
+++ b/target/linux/ramips/mt7621/base-files/lib/upgrade/hatlab.sh
@@ -0,0 +1,88 @@
+. /lib/functions.sh
+
+hatlab_check_image() {
+	local diskdev partdev diff
+
+	export_bootdevice && export_partdevice diskdev 0 || {
+		echo "Unable to determine upgrade device"
+		return 1
+	}
+
+	get_partitions "/dev/$diskdev" bootdisk
+
+	# Extract the boot sector from the image
+	get_image "$@" | dd of=/tmp/image.bs count=1 bs=512b 2>/dev/null
+
+	get_partitions /tmp/image.bs image
+
+	# Compare tables
+	diff="$(grep -F -x -v -f /tmp/partmap.bootdisk /tmp/partmap.image)"
+
+	rm -f /tmp/image.bs /tmp/partmap.bootdisk /tmp/partmap.image
+
+	if [ -n "$diff" ]; then
+		echo "Partition layout has changed. Full image will be written."
+		ask_bool 0 "Abort" && exit 1
+		return 0
+	fi
+}
+
+hatlab_copy_config() {
+	local partdev parttype=ext4
+
+	if export_partdevice partdev 2; then
+		mount -t $parttype -o rw,noatime "/dev/$partdev" /mnt
+		cp -af "$UPGRADE_BACKUP" "/mnt/$BACKUP_FILE"
+		umount /mnt
+	fi
+}
+
+hatlab_do_upgrade() {
+	local diskdev partdev diff
+
+	export_bootdevice && export_partdevice diskdev 0 || {
+		echo "Unable to determine upgrade device"
+		return 1
+	}
+
+	sync
+
+	if [ "$UPGRADE_OPT_SAVE_PARTITIONS" = "1" ]; then
+		get_partitions "/dev/$diskdev" bootdisk
+
+		# Extract the boot sector from the image
+		get_image "$@" | dd of=/tmp/image.bs count=1 bs=512b
+
+		get_partitions /tmp/image.bs image
+
+		# Compare tables
+		diff="$(grep -F -x -v -f /tmp/partmap.bootdisk /tmp/partmap.image)"
+	else
+		diff=1
+	fi
+
+	if [ -n "$diff" ]; then
+		get_image "$@" | dd of="/dev/$diskdev" bs=4096 conv=fsync
+
+		# Separate removal and addtion is necessary; otherwise, partition 1
+		# will be missing if it overlaps with the old partition 2
+		partx -d - "/dev/$diskdev"
+		partx -a - "/dev/$diskdev"
+
+		return 0
+	fi
+
+	# Iterate over each partition from the image and write it to the boot disk
+	while read part start size; do
+		if export_partdevice partdev $part; then
+			echo "Writing image to /dev/$partdev..."
+			get_image "$@" | dd of="/dev/$partdev" ibs="512" obs=1M skip="$start" count="$size" conv=fsync
+		else
+			echo "Unable to find partition $part device, skipped."
+		fi
+	done < /tmp/partmap.image
+
+	# Copy partition uuid
+	echo "Writing new UUID to /dev/$diskdev..."
+	get_image "$@" | dd of="/dev/$diskdev" bs=1 skip=440 count=4 seek=440 conv=fsync
+}
diff --git a/target/linux/ramips/mt7621/base-files/lib/upgrade/platform.sh b/target/linux/ramips/mt7621/base-files/lib/upgrade/platform.sh
index c2ad4d3..a604c5d 100755
--- a/target/linux/ramips/mt7621/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ramips/mt7621/base-files/lib/upgrade/platform.sh
@@ -9,6 +9,28 @@ RAMFS_COPY_BIN='fw_printenv fw_setenv'
 RAMFS_COPY_DATA='/etc/fw_env.config /var/lock/fw_printenv.lock'
 
 platform_check_image() {
+	local board=$(board_name)
+
+	case "$board" in
+	hatlab,gateboard-one)
+		hatlab_check_image "$1"
+		return $?;
+		;;
+	esac
+
+	return 0
+}
+
+platform_copy_config() {
+	local board=$(board_name)
+
+	case "$board" in
+	hatlab,gateboard-one)
+		hatlab_copy_config
+		return $?;
+		;;
+	esac
+
 	return 0
 }
 
@@ -109,6 +131,9 @@ platform_do_upgrade() {
 		CI_KERNPART="Kernel"
 		nand_do_upgrade "$1"
 		;;
+	hatlab,gateboard-one)
+		hatlab_do_upgrade "$1"
+		;;
 	*)
 		default_do_upgrade "$1"
 		;;
diff --git a/target/linux/ramips/mt7621/base-files/sbin/fixup-mac-address b/target/linux/ramips/mt7621/base-files/sbin/fixup-mac-address
index dad15c5..375db51 100755
--- a/target/linux/ramips/mt7621/base-files/sbin/fixup-mac-address
+++ b/target/linux/ramips/mt7621/base-files/sbin/fixup-mac-address
@@ -13,6 +13,10 @@ case $board in
 		partname=factory
 		offset=$((0xe000))
 	;;
+	hatlab,gateboard-one)
+		partname=factory
+		offset=$((0x0))
+	;;
 	*)
 		echo "Unsupported board"
 		exit 1
diff --git a/target/linux/ramips/mt7621/config-5.4 b/target/linux/ramips/mt7621/config-5.4
index 057c782..d11f77d 100644
--- a/target/linux/ramips/mt7621/config-5.4
+++ b/target/linux/ramips/mt7621/config-5.4
@@ -1,10 +1,12 @@
 CONFIG_ARCH_32BIT_OFF_T=y
+CONFIG_ARCH_BINFMT_ELF_STATE=y
 CONFIG_ARCH_CLOCKSOURCE_DATA=y
 CONFIG_ARCH_HIBERNATION_POSSIBLE=y
 CONFIG_ARCH_MMAP_RND_BITS_MAX=15
 CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=15
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_AT803X_PHY=y
+CONFIG_BLK_DEV_NVME=y
 CONFIG_BLK_MQ_PCI=y
 CONFIG_BOARD_SCACHE=y
 CONFIG_BOUNCE=y
@@ -32,6 +34,7 @@ CONFIG_CPU_MIPSR2_IRQ_EI=y
 CONFIG_CPU_MIPSR2_IRQ_VI=y
 CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
 CONFIG_CPU_R4K_CACHE_TLB=y
+CONFIG_CPU_R4K_FPU=y
 CONFIG_CPU_RMAP=y
 CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
 CONFIG_CPU_SUPPORTS_HIGHMEM=y
@@ -50,6 +53,7 @@ CONFIG_CRYPTO_NULL2=y
 CONFIG_CRYPTO_RNG2=y
 CONFIG_CSRC_R4K=y
 CONFIG_DEBUG_PINCTRL=y
+CONFIG_DECOMPRESS_GZIP=y
 CONFIG_DIMLIB=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_DMA_NONCOHERENT_CACHE_SYNC=y
@@ -141,6 +145,7 @@ CONFIG_MIPS_CPS=y
 # CONFIG_MIPS_CPS_NS16550_BOOL is not set
 CONFIG_MIPS_CPU_SCACHE=y
 # CONFIG_MIPS_ELF_APPENDED_DTB is not set
+CONFIG_MIPS_FP_SUPPORT=y
 CONFIG_MIPS_GIC=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_MIPS_MT=y
@@ -161,6 +166,7 @@ CONFIG_MTD_NAND_MT7621=y
 CONFIG_MTD_PHYSMAP=y
 CONFIG_MTD_RAW_NAND=y
 CONFIG_MTD_ROUTERBOOT_PARTS=y
+CONFIG_MTD_SPI_NAND=y
 CONFIG_MTD_SPI_NOR=y
 CONFIG_MTD_SPLIT_FIT_FW=y
 CONFIG_MTD_SPLIT_MINOR_FW=y
@@ -185,6 +191,8 @@ CONFIG_NET_SWITCHDEV=y
 CONFIG_NET_VENDOR_MEDIATEK=y
 # CONFIG_NET_VENDOR_RALINK is not set
 CONFIG_NR_CPUS=4
+CONFIG_NVME_CORE=y
+CONFIG_NVME_MULTIPATH=y
 CONFIG_OF=y
 CONFIG_OF_ADDRESS=y
 CONFIG_OF_EARLY_FLATTREE=y
@@ -221,6 +229,7 @@ CONFIG_RALINK=y
 CONFIG_RATIONAL=y
 CONFIG_RCU_NEED_SEGCBLIST=y
 CONFIG_RCU_STALL_COMMON=y
+CONFIG_RD_GZIP=y
 CONFIG_REGMAP=y
 CONFIG_REGMAP_MMIO=y
 CONFIG_REGULATOR=y
diff --git a/target/linux/ramips/patches-5.4/9900-spi-nor-add-p25d40h.patch b/target/linux/ramips/patches-5.4/9900-spi-nor-add-p25d40h.patch
new file mode 100644
index 0000000..17ca98b
--- /dev/null
+++ b/target/linux/ramips/patches-5.4/9900-spi-nor-add-p25d40h.patch
@@ -0,0 +1,12 @@
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -2410,6 +2410,9 @@ static const struct flash_info spi_nor_ids[] = {
+ 	{ "pm25lv010",   INFO(0,        0, 32 * 1024,    4, SECT_4K_PMC) },
+ 	{ "pm25lq032",   INFO(0x7f9d46, 0, 64 * 1024,   64, SECT_4K) },
+ 
++	/* PUYA */
++	{ "p25d40h", INFO(0x856013, 0, 64 * 1024,  8,  SECT_4K) },
++
+ 	/* Spansion/Cypress -- single (large) sector size only, at least
+ 	 * for the chips listed here (without boot sectors).
+ 	 */
diff --git a/target/linux/ramips/patches-5.4/9901-gpio-mt7621-irq-workaround.patch b/target/linux/ramips/patches-5.4/9901-gpio-mt7621-irq-workaround.patch
new file mode 100644
index 0000000..dc2add1
--- /dev/null
+++ b/target/linux/ramips/patches-5.4/9901-gpio-mt7621-irq-workaround.patch
@@ -0,0 +1,11 @@
+--- a/drivers/gpio/gpio-mt7621.c
++++ b/drivers/gpio/gpio-mt7621.c
+@@ -312,7 +312,7 @@ mediatek_gpio_probe(struct platform_devi
+ 	mtk->dev = dev;
+ 	platform_set_drvdata(pdev, mtk);
+ 
+-	for (i = 0; i < MTK_BANK_CNT; i++) {
++	for (i = MTK_BANK_CNT - 1; i >= 0; i--) {
+ 		ret = mediatek_gpio_bank_probe(dev, np, i);
+ 		if (ret)
+ 			return ret;
diff --git a/target/linux/ramips/patches-5.4/9902-rtl8211fs.patch b/target/linux/ramips/patches-5.4/9902-rtl8211fs.patch
new file mode 100644
index 0000000..c02c922
--- /dev/null
+++ b/target/linux/ramips/patches-5.4/9902-rtl8211fs.patch
@@ -0,0 +1,149 @@
+Copyright (C) 2022 Aodzip <aodzip@gmail.com>
+--- a/drivers/net/phy/realtek.c	2022-02-11 16:07:52.000000000 +0800
++++ b/drivers/net/phy/realtek.c	2022-03-26 18:52:58.728003873 +0800
+@@ -39,6 +39,11 @@
+ #define RTL8366RB_POWER_SAVE			0x15
+ #define RTL8366RB_POWER_SAVE_ON			BIT(12)
+ 
++#define RTL8211FS_SGMII_ESR			0x0F
++#define RTL8211FS_MODE_MASK			0xC000
++#define RTL8211F_MODE_UTP			0
++#define RTL8211FS_MODE_SGMII			1
++
+ #define RTL_SUPPORTS_5000FULL			BIT(14)
+ #define RTL_SUPPORTS_2500FULL			BIT(13)
+ #define RTL_SUPPORTS_10000FULL			BIT(0)
+@@ -49,6 +54,11 @@
+ 
+ #define RTL_GENERIC_PHYID			0x001cc800
+ 
++struct rtl8211f_priv {
++	int lastmode;
++	int autotxid;
++};
++
+ MODULE_DESCRIPTION("Realtek PHY driver");
+ MODULE_AUTHOR("Johnson Leung");
+ MODULE_LICENSE("GPL");
+@@ -443,6 +453,105 @@
+ 	       rtlgen_supports_2_5gbps(phydev);
+ }
+ 
++static int rtl8211f_probe(struct phy_device *phydev)
++{
++	struct device *dev = &phydev->mdio.dev;
++	struct rtl8211f_priv *priv;
++
++	priv = devm_kzalloc(dev, sizeof(struct rtl8211f_priv), GFP_KERNEL);
++	if (!priv)
++		return -ENOMEM;
++	
++	memset(priv, 0x00, sizeof(struct rtl8211f_priv));
++
++	priv->lastmode = RTL8211F_MODE_UTP;
++	priv->autotxid = device_property_read_bool(dev, "realtek,autotxid");
++
++	phydev->priv = priv;
++
++	return 0;
++}
++
++static void rtl8211f_remove(struct phy_device *phydev)
++{
++	struct device *dev = &phydev->mdio.dev;
++	struct rtl8211f_priv *priv = phydev->priv;
++
++	if (priv)
++		devm_kfree(dev, priv);
++}
++
++static int rtl8211f_mode(struct phy_device *phydev)
++{
++	u16 val;
++
++	val = phy_read(phydev, RTL8211FS_SGMII_ESR);
++	val &= RTL8211FS_MODE_MASK;
++
++	if (val)
++		return RTL8211FS_MODE_SGMII;
++
++	return RTL8211F_MODE_UTP;
++}
++
++static int rtl8211f_config_aneg(struct phy_device *phydev)
++{
++	int ret;
++
++	struct rtl8211f_priv *priv = phydev->priv;
++
++	ret = genphy_read_abilities(phydev);
++	if(ret < 0)
++		return ret;
++
++	linkmode_copy(phydev->advertising, phydev->supported);
++
++	if (rtl8211f_mode(phydev) == RTL8211FS_MODE_SGMII) {
++		dev_info(&phydev->mdio.dev, "SGMII Mode");
++		priv->lastmode = RTL8211FS_MODE_SGMII;
++		return genphy_c37_config_aneg(phydev);
++	}
++
++	dev_info(&phydev->mdio.dev, "UTP Mode");
++	priv->lastmode = RTL8211F_MODE_UTP;
++	return genphy_config_aneg(phydev);
++}
++
++static int rtl8211f_read_status(struct phy_device *phydev)
++{
++	int val, ret;
++	struct rtl8211f_priv *priv = phydev->priv;
++
++	if (rtl8211f_mode(phydev) != priv->lastmode) {
++		ret = rtl8211f_config_aneg(phydev);
++		if (ret < 0)
++			return ret;
++
++		ret = genphy_restart_aneg(phydev);
++		if (ret < 0)
++			return ret;
++	}
++
++	if (rtl8211f_mode(phydev) == RTL8211FS_MODE_SGMII) {
++		ret = genphy_c37_read_status(phydev);
++	} else {
++		ret = genphy_read_status(phydev);
++	}
++	if (ret < 0)
++		return ret;
++
++	if (priv->autotxid) {
++		val = 0;
++		if (phydev->speed < SPEED_1000)
++			val = RTL8211F_TX_DELAY;
++
++		ret = phy_modify_paged_changed(phydev, 0xd08, 0x11,
++			RTL8211F_TX_DELAY, val);
++	}
++
++	return ret;
++}
++
+ static struct phy_driver realtek_drvs[] = {
+ 	{
+ 		PHY_ID_MATCH_EXACT(0x00008201),
+@@ -513,10 +622,14 @@
+ 		.write_page	= rtl821x_write_page,
+ 	}, {
+ 		PHY_ID_MATCH_EXACT(0x001cc916),
+-		.name		= "RTL8211F Gigabit Ethernet",
++		.name		= "RTL8211F(S) Gigabit Ethernet",
++		.probe		= rtl8211f_probe,
++		.remove		= rtl8211f_remove,
+ 		.config_init	= &rtl8211f_config_init,
+ 		.ack_interrupt	= &rtl8211f_ack_interrupt,
+ 		.config_intr	= &rtl8211f_config_intr,
++		.config_aneg	= rtl8211f_config_aneg,
++		.read_status	= rtl8211f_read_status,
+ 		.suspend	= genphy_suspend,
+ 		.resume		= genphy_resume,
+ 		.read_page	= rtl821x_read_page,
\ No newline at end of file
diff --git a/target/linux/ramips/patches-5.4/9909-mt7621-add-l2c-er35-workaround.patch b/target/linux/ramips/patches-5.4/9909-mt7621-add-l2c-er35-workaround.patch
new file mode 100644
index 0000000..07da3d2
--- /dev/null
+++ b/target/linux/ramips/patches-5.4/9909-mt7621-add-l2c-er35-workaround.patch
@@ -0,0 +1,142 @@
+--- a/arch/mips/Kconfig
++++ b/arch/mips/Kconfig
+@@ -2466,6 +2466,17 @@ config SB1_PASS_2_1_WORKAROUNDS
+ 	depends on CPU_SB1 && CPU_SB1_PASS_2
+ 	default y
+ 
++config MIPS_ER35_WORKAROUNDS
++	bool
++	depends on SYS_SUPPORTS_MIPS_CPS
++	select ZONE_DMA
++	default y
++
++config MIPS_ER35_RESERVED_SPACE
++	hex
++	default 0x1000000
++	depends on MIPS_ER35_WORKAROUNDS
++
+ choice
+ 	prompt "SmartMIPS or microMIPS ASE support"
+ 
+--- a/arch/mips/include/asm/dma.h
++++ b/arch/mips/include/asm/dma.h
+@@ -87,6 +87,8 @@
+ #if defined(CONFIG_SGI_IP22) || defined(CONFIG_SGI_IP28)
+ /* don't care; ISA bus master won't work, ISA slave DMA supports 32bit addr */
+ #define MAX_DMA_ADDRESS		PAGE_OFFSET
++#elif defined(CONFIG_MIPS_ER35_WORKAROUNDS)
++#define MAX_DMA_ADDRESS		(PAGE_OFFSET + CONFIG_MIPS_ER35_RESERVED_SPACE)
+ #else
+ #define MAX_DMA_ADDRESS		(PAGE_OFFSET + 0x01000000)
+ #endif
+--- a/arch/mips/kernel/head.S
++++ b/arch/mips/kernel/head.S
+@@ -22,6 +22,7 @@
+ #include <asm/irqflags.h>
+ #include <asm/regdef.h>
+ #include <asm/mipsregs.h>
++#include <asm/cacheops.h>
+ #include <asm/stackframe.h>
+ 
+ #include <kernel-entry-init.h>
+@@ -93,6 +94,67 @@ NESTED(kernel_entry, 16, sp)			# kernel entry point
+ 
+ 	setup_c0_status_pri
+ 
++#ifdef CONFIG_MIPS_ER35_WORKAROUNDS
++	/* Jump to KSEG1 so that we can perform cache related operations */
++	PTR_LA	t0, 0f
++	li	t1, 5
++	ins	t0, t1, 29, 3
++	jr	t0
++	nop
++0:
++
++	/* Calculate L2 Cache size */
++	MFC0	t0, CP0_CONFIG, 2
++	ext	t1, t0, 4, 4
++	li	t2, 2
++	sllv	t1, t2, t1		/* Cache line size */
++
++	ext	t2, t0, 8, 4
++	li	t3, 64
++	sllv	t2, t3, t2		/* Sets per way */
++
++	ext	t3, t0, 0, 4
++	addiu	t3, 1			/* Number of ways */
++
++	mul	t2, t2, t3		/* Number of sets */
++
++
++	/* Flush L2 Cache before setting CCA overrides */
++	move	t3, zero
++1:
++	cache	Index_Writeback_Inv_SD, 0(t3)
++	sub	t2, 1
++	add	t3, t3, t1
++	bne	t2, zero, 1b
++	nop
++
++	sync
++
++	/*
++	 * Override bottom CONFIG_MIPS_ER35_RESERVED_SPACE of DDR to
++	 * Uncached (which will be reserved as DMA zone)
++	 */
++	MFC0	t0, CP0_CMGCRBASE
++	PTR_SLL	t0, t0, 4
++	li	t1, 5
++	ins	t0, t1, 29, 3
++
++	/* GCR_REG2_MASK */
++	lui	t1, (~((CONFIG_MIPS_ER35_RESERVED_SPACE - 1) >> 16)) & 0xffff
++	ori	t1, t1, 0x0051
++	sw	t1, 0xb8(t0)
++
++	/* GCR_REG2_BASE */
++	sw	zero, 0xb0(t0)
++
++	/* Set default override to Write-through */
++	lw	t1, 0x08(t0)
++	li	t2, 0xffff8000
++	and	t1, t1, t2
++	ori	t1, 0x10
++	sw	t1, 0x08(t0)
++#endif
++
+ 	/* We might not get launched at the address the kernel is linked to,
+ 	   so we jump there.  */
+ 	PTR_LA	t0, 0f
+--- a/arch/mips/ralink/Kconfig
++++ b/arch/mips/ralink/Kconfig
+@@ -59,6 +59,8 @@ choice
+ 		select HAVE_PCI if PCI_MT7621
+ 		select WEAK_REORDERING_BEYOND_LLSC
+ 		select GENERIC_CLOCKEVENTS_BROADCAST
++		select MIPS_ER35_WORKAROUNDS
++
+ endchoice
+ 
+ choice
+--- a/arch/mips/ralink/Platform
++++ b/arch/mips/ralink/Platform
+@@ -30,5 +30,5 @@ cflags-$(CONFIG_SOC_MT7620)	+= -I$(srctree)/arch/mips/include/asm/mach-ralink/mt
+ 
+ # Ralink MT7621
+ #
+-load-$(CONFIG_SOC_MT7621)	+= 0xffffffff80001000
++load-$(CONFIG_SOC_MT7621)	+= 0xffffffff80001000+$(CONFIG_MIPS_ER35_RESERVED_SPACE)
+ cflags-$(CONFIG_SOC_MT7621)	+= -I$(srctree)/arch/mips/include/asm/mach-ralink/mt7621
+--- a/kernel/dma/direct.c
++++ b/kernel/dma/direct.c
+@@ -91,6 +91,10 @@ struct page *__dma_direct_alloc_pages(struct device *dev, size_t size,
+ 	struct page *page = NULL;
+ 	u64 phys_mask;
+ 
++#ifdef CONFIG_MIPS_ER35_WORKAROUNDS
++	gfp |= __GFP_DMA;
++#endif
++
+ 	if (attrs & DMA_ATTR_NO_WARN)
+ 		gfp |= __GFP_NOWARN;
+ 
diff --git a/target/linux/ramips/patches-5.4/999-add-esp-hw-offload.patch b/target/linux/ramips/patches-5.4/999-add-esp-hw-offload.patch
new file mode 100644
index 0000000..42a0565
--- /dev/null
+++ b/target/linux/ramips/patches-5.4/999-add-esp-hw-offload.patch
@@ -0,0 +1,11 @@
+--- a/net/ipv4/Kconfig
++++ b/net/ipv4/Kconfig
+@@ -353,6 +353,7 @@
+ config INET_ESP
+ 	tristate "IP: ESP transformation"
+ 	select XFRM_ALGO
++	select XFRM_OFFLOAD
+ 	select CRYPTO
+ 	select CRYPTO_AUTHENC
+ 	select CRYPTO_HMAC
+
diff --git a/target/linux/ramips/patches-5.4/9999-mt7621-disable-highmem.patch b/target/linux/ramips/patches-5.4/9999-mt7621-disable-highmem.patch
new file mode 100644
index 0000000..186d1e5
--- /dev/null
+++ b/target/linux/ramips/patches-5.4/9999-mt7621-disable-highmem.patch
@@ -0,0 +1,13 @@
+--- a/arch/mips/ralink/mt7621.c	2022-05-07 15:37:03.999765557 +0800
++++ b/arch/mips/ralink/mt7621.c	2022-05-07 13:52:33.624212000 +0800
+@@ -172,8 +172,8 @@
+ 	/* addr doesn't wrap around at dm + 256M, assume 512M memory. */
+ 	add_memory_region(MT7621_LOWMEM_BASE, MT7621_LOWMEM_MAX_SIZE,
+ 			  BOOT_MEM_RAM);
+-	add_memory_region(MT7621_HIGHMEM_BASE, MT7621_HIGHMEM_SIZE,
+-			  BOOT_MEM_RAM);
++	// add_memory_region(MT7621_HIGHMEM_BASE, MT7621_HIGHMEM_SIZE,
++	// 		  BOOT_MEM_RAM);
+ }
+ 
+ void __init ralink_clk_init(void)
-- 
2.39.2 (Apple Git-143)

